[
  {
    "passed": false,
    "name": "강병준",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/76"
    }
  },
  {
    "passed": true,
    "name": "권지호",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/29"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/35"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/40"
    }
  },
  {
    "passed": true,
    "name": "김소희",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/74"
    }
  },
  {
    "passed": true,
    "name": "김수민",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/69"
    }
  },
  {
    "passed": true,
    "name": "김수현",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/39"
    }
  },
  {
    "passed": false,
    "name": "김연수",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/70"
    }
  },
  {
    "passed": false,
    "name": "김유현",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/22"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/72"
    }
  },
  {
    "passed": true,
    "name": "김효진",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/53"
    }
  },
  {
    "passed": true,
    "name": "김휘린",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/13"
    }
  },
  {
    "passed": true,
    "name": "박상수",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/66"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/17"
    }
  },
  {
    "passed": false,
    "name": "박의근",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/61"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박준형",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/38"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박창준",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/18"
    }
  },
  {
    "passed": true,
    "name": "신홍준",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/77"
    }
  },
  {
    "passed": false,
    "name": "신희원",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/16"
    }
  },
  {
    "passed": true,
    "name": "양성진",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/60"
    }
  },
  {
    "passed": true,
    "name": "양창훈",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/23"
    }
  },
  {
    "passed": true,
    "name": "여진석",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/50"
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/20"
    }
  },
  {
    "passed": true,
    "name": "오하늘",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/59"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/10"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "윤영서",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/2"
    }
  },
  {
    "passed": false,
    "name": "이가은",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/54"
    }
  },
  {
    "passed": true,
    "name": "이민재",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/11"
    }
  },
  {
    "passed": true,
    "name": "이유진",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/71"
    }
  },
  {
    "passed": true,
    "name": "이은지",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/64"
    }
  },
  {
    "passed": true,
    "name": "이의찬",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/15"
    }
  },
  {
    "passed": true,
    "name": "이정우",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/55"
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/27"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/58"
    }
  },
  {
    "passed": false,
    "name": "이진희",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/41"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/46"
    }
  },
  {
    "passed": false,
    "name": "임규원",
    "feedback": "안녕하세요 규원님~\n이번에 시간이 많이 부족했나보네요 ㅠㅠ\n2주차는 잘 진행할 수 있기를 바랍니다!\n고생하셨어요!",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/43"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "임두현",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/31"
    }
  },
  {
    "passed": false,
    "name": "장루빈",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/57"
    }
  },
  {
    "passed": true,
    "name": "장희진",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/68"
    }
  },
  {
    "passed": true,
    "name": "정건휘",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/65"
    }
  },
  {
    "passed": true,
    "name": "정도은",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/12"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "정민기",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/33"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "정유열",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/28"
    }
  },
  {
    "passed": false,
    "name": "조영민",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/45"
    }
  },
  {
    "passed": true,
    "name": "주산들",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/14"
    }
  },
  {
    "passed": true,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/75"
    }
  },
  {
    "passed": true,
    "name": "최용훈",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/24"
    }
  },
  {
    "passed": true,
    "name": "최재환",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/42"
    }
  },
  {
    "passed": true,
    "name": "한아름",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/67"
    }
  },
  {
    "passed": true,
    "name": "허정석",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/19"
    }
  },
  {
    "passed": true,
    "name": "현지수",
    "feedback": "",
    "assignment": {
      "name": "STEP01 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/51"
    }
  },
  {
    "passed": false,
    "name": "강병준",
    "feedback": "안녕하세요 강병준님, 제출해주신 과제를 검토했습니다. \n\n이번 과제는 프레임워크 없이 순수 JavaScript로 SPA를 구현하면서, 현대 프레임워크들이 해결하고자 하는 문제들을 직접 경험해보는 것이 목적이었습니다. 상태 관리, 라우팅, 렌더링 최적화 등의 핵심 개념을 직접 구현하면서 깊이 있는 학습이 이루어지길 기대했습니다.\n\n이번 과제의 코드 구현이 이루어지지 않아 아쉽게도 이번 과제는 불합격처리됩니다.\n\n혹시 기술적인 어려움이나 시간 부족 등의 문제가 있으셨다면, 다음 과제 진행 시에는 미리 질문 채널을 통해 도움을 요청하시는 것을 권장드립니다. 또한 부분적으로라도 구현한 내용이 있다면 제출하시는 것이 학습 측면에서 더 도움이 될 것입니다.\n\n다음 기회에는 꼭 완성된 과제를 만나뵐 수 있기를 기대합니다. 화이팅입니다!",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/76"
    }
  },
  {
    "passed": true,
    "name": "권지호",
    "feedback": "안녕하세요 지호님!\n1주차 과제 잘 진행해주셨군요 ㅎㅎ 너무 고생 많으셨어요!!\n\n> 서론이 길었지만, 결론은 완주(과제 통과)를 목표로 하고, \"ai를 최대한 다루면서 ai가 짠 코드에 의문이 있다면 하나라도 그냥 넘어가지 않고 많이 물어보자\" 를 경험하기로 했습니다. 어떻게든 만들어 내야된다는 집착(?)으로 ai로 점점 원하는 결과를 내는 정확도가 올라갔습니다. 활용능력 + 10..\n\n이 또한 이 시대에 살아남는 혹은 성장하는 방법이라고 생각합니다 ㅋㅋ\nAI를 활용하는 능력도 이제 무척 중요하니까요!\n다만 AI를 잘 활용하려면 기본기도 중요하기 때문에 잘 소화하는 시간도 꼭 가져주세요!\n\n> 상태관리와 이벤트버스\n\n직접 이벤트 버스를 구현해주셨군요 ㅎㅎ\n다만 이벤트 버스의 경우 어디서 어떻게 무슨 이유 때문에 트리거가 되었는지 추적하기가 어렵달까... 이런 부분만 조심해주시면 무척 좋답니다!\n실제로 저희 팀에서도 잘 쓰이고 있는 방식 중에 하나랍니다.\n\n> 라우팅 설계에 대해 코멘트 들어보고 싶습니다! 다른 분들은 어떻게 구현하셨을지, 혹은 코치님이 생각하시는 best practice가 무엇인지 궁금합니다. SPA에 적절한 설계를 한 것인지 잘 모르겠습니다(?)\n\n좋은 코드는 내가 만든 프로젝트 뿐만 아니라 다른 사람이 만든 프로젝트에서도 잘 동작하고 결합할 수 있어야 한다고 생각합니다 ㅎㅎ\n\n이런 측면에서 생각해보면 나쁘지 않은 방식이라고 생각해요!\nNotFoundComponent의 경우 이걸 지금 처럼 내제화 하는 방법이 있고, 혹은 외부에 위임하는 방법도 있는데 이 또한 잘 만들어주신 것 같네요!\n\nSPA에 적합한 방식은... 무엇으로 판단해야 좋을지에 대해 먼저 생각해봐야 합니다.\n\n**핵심 기능**\n- 클라이언트 사이드 라우팅 지원\n- 브라우저 히스토리 API 활용 (pushState/popState)\n- 페이지 새로고침 없는 네비게이션\n\n**라우팅 기능**\n- 동적 라우트 매칭 (파라미터, 쿼리스트링)\n- 중첩 라우팅 지원\n- 프로그래매틱 네비게이션 (코드로 라우트 이동)\n- 라우트 가드/보호 기능 (인증, 권한)\n\n**성능 최적화**\n- 지연 로딩 (Lazy Loading) 지원\n- 코드 스플리팅 호환성\n- 가벼운 번들 사이즈\n\n**개발 편의성**\n- 선언적 라우팅 구문\n- TypeScript 지원\n- 개발 도구 지원\n- 에러 바운더리 처리\n\n**호환성**\n- SSR/SSG 지원\n- 메타 태그 관리 (SEO)\n- 404 에러 처리\n- 뒤로가기/앞으로가기 정상 동작\n\n위와 같은 조건들이 있는데, 저는 여기서 제일 중요한게 \n뒤로가기/앞으로가기/동적라우팅/라우트가드 등이라고 생각해요 ㅎㅎ\n\n다만 지금 요구사항에서 라우트가드나 중첩 라우팅 같은건 이야기 해놓질 않기 때문에 고려하지 못했을 것 같네요..!\n\n---\n\n고생하셨습니다 지호님!",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/29"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "민지님 첫 과제 고생많이 하셨습니다.\n회고 남겨주신걸 보니 약간 힘들어보이시는데요 ㅎㅎㅎ\n너무 자신감을 잃지 않으셨으면 좋겠네요.\n과제 자체가 양이 많기도 했고 정신이 없는 상황이 많기도 했구요.\n결국 중요한건 굉장히 많은 비즈니스 로직을 구현하는 것 보다는 민지님이 남겨주신 회고처럼 어느 부분에서 어려움을 겪었는지 다시 정확히 정리해보고 내가 사용하는 프레임워크에서는 또는 기술에서는 이걸 어떻게 해결하는지 찾아보는 것 같아요. \n문제 겪으신 부분을 리액트나 뷰에서는 이런 과정을 명확하게 하기위해 어떻게 관리하는지, 라이프 사이클은 어떻게 제어할지 그런 고민들을 해보면 좋을 것 같아요. 말씀해주신 렌더링 과정에 대한 이해도 포함이 되겠죠. 그리고 그 내용을 다시 본인의 코드로 옮기는 연습을 하는거죠. 사실 저건 해당 문제를 해결하기 위한 각 프레임워크의 해결책이고 정답은 아니니 제것에 맞게 옮기는 연습을 하는게 중요한 것 같아요.\n여담으로 저도 늘 어렵지만, 테스트 코드에서 라우터 이동을 감지 못해서 그런줄 알고 많은 시간을 쏟으셨지만 알고 보니 바인딩 이슈였던 것 처럼  문제를 명확하게 정의하는 연습도 함께 하면 더 시간을 아낄 수 있지 않을까 싶어요. 추측은 그 과정에서 배우는 것은 많겠지만 실패했을 때 낭비되는 시간이 너무 많은 것 같아서요. 문제를 명확하게 하고 움직이는 걸로 ㅎㅎ\n\n고생하셨고 충분히 잘하셨으니까 다음주도 화이팅하시구요! 이번주에 부족하다고 느끼셨던 부분들도 그냥 넘기지 말고 잘 모아둔다음 시간 여유가 생길때 꼭 해결해보는 습관 만드시면 좋겠습니다~",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/35"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "고생하셨습니다 상수님ㅎㅎㅎ\n근본없는 괴물이라뇨 잘하셨습니다 ㅋㅋㅋ\n개인적으로 이번 과제를 통해 명확하게 사용하는 기술들이 해결하려고 했던 문제들은 무엇이고, 어떤 식으로 해결했는지 고민해볼수 있으셨던 것 같아서 훌륭한 경험이 되지 않았을까 싶네요 :+1\nAI 활용도 작성해주신 것처럼 만들고자 하는 목표와 참고할 수 있는 명확한 자료를 넣어서 구현을 잘 해주셨네요.\n\n질문 주신거 답변드려보면, 라이프 사이클과 렌더링에 대해서는 명시적인 함수를 컴포넌트에서 만들어서 사용하는 것이 필요해보여요. 라이프 사이클 함수가 있다면 결국 명확한 제어와 사용자의 행동을 주입받아 실행시킨다는 의미이기 때문에 명시적인 구현이 필요할 것 같구요! 상태 관리에 대한 리렌더링 관련해서는 이미 알고 계신것처럼 상태를 클로저로 물고 있으면서 setState를 할 때 명시적으로 렌더링을 발생시키거나, 좀 더 우아하게 처리하고 싶다면 쉽게 인터넷에서 확인할 수 있는 여러 반응형 상태 라이브러리를 구현해 사용해보는 거도 방법일 것 같아요! 사실 구현해보면 어렵지 않거든요.\n꼭 도전해볼법한 주제들이니, 상태를 모니터링 하는 곳들에서 변화가 발생할 때 어떤 동작을 할 지 등등 고민들을 해보시면 좋겠네요.\n\n고생하셨습니다!",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/40"
    }
  },
  {
    "passed": false,
    "name": "김소희",
    "feedback": "소희님 이번에는 과제 하실 시간이 부족하셨던 것 같습니다 :)\n나중에 솔루션 코드가 나오면 코드를 살펴보시고 복기하시는 시간을 꼭 가지시면 좋을 것 같아요!",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/74"
    }
  },
  {
    "passed": true,
    "name": "김수민",
    "feedback": "수민님 수고많으셨습니다!\n\n* (리뷰는 아닌데 궁금한 점) MVC 패턴이랑 SPA가 궁합이 맞지 않는 것인지 아니면 해결할 방법이 있었는데 제가 잘 몰랐던 것인지 궁금합니다!\n\nSPA와 MVC 패턴은 궁합이 딱히 안맞다고는 할 수 없을 것 같아요.\nMVC보다 나은 것들이 나왔다고 보는 편이 좋을 것 같습니다 :)\n사실 무엇이 궁금한것인지 좀더 자세히 질문을 해주시면 좋을 것 같아요!\n제가 알고 있는 MVC패턴으로 구현한 SPA 프레임웍으로는 백본이라는 녀석이 있어요! 그 프레임웍의 코드 모양세를 조금 살펴보시면 조금 힌트가 되실 것 같습니다!\n\n* 제가 구현한 라우터와 Component class가 과한 렌더링을 유발하지는 않는지 궁금합니다. 코드만으로 몇 회 불필요한 렌더링이 일어나는지 이런 걸 생각하는 게 어려운데 잘하고 싶어요..!\n\n이런건 사실 코드만으로는 측정하기가 힘들 수 있어요. 이럴때 사용하기 좋은 것아 바로 크롬 개발자 도구인 것 같아요. 퍼포먼스탭을 활용해보세요!\nhttps://developer.chrome.com/docs/devtools/performance/reference?hl=ko\n처음에는 익숙하지 않은데 막상 보시면 금세 익숙해지실 것 같아요!\n저도 코드로 예측한대로 동작하지 않아 이런 도구를 활용해서 실제로 어떻게 실행되는지 의도한 대로 동작하는지 아닌지 확인해봅니다.\n\n* 디스코드로 질문 드렸던 내용인데, 단위 테스트 환경에서 query가 {}로 인식되어 통과하지 못하는 문제가 있었어요. 테스트 환경에서 window 객체가 없는데 window에 바인딩한 router를 사용해서 그런 걸까요? 근데.. 테스트 환경에서 window 객체 없는 거 맞..나..?\n\n아마 jsdom 때문인 것 같은데요. 이상하네요 jsdom에도 window는 있을텐데요. 아무래도 모킹이다보니 실제 브라우저의 동작과 달라서 그럴수도 있는데요.\n움 해당 코드에 준하는 솔루션 코드의 조각을 살펴보시면 좋을 것 같습니다!",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/69"
    }
  },
  {
    "passed": true,
    "name": "김수현",
    "feedback": "안녕하세요 수현님~\n1주차 과제 잘 진행해주셨네요!! 너무 고생 많으셨어요.\n\n> 무한 스크롤 부분에서 스크롤이 내려올 때 다시 그 스크롤의 위치를 기억하고 render을 진행하게 되는데 이 방법 말고 다른 방법이 있을까요?\n무한 스크롤은 구현이 되지만 다시 render을 하는 점에서 너무 무겁게 느껴지고 ui 상에서 매끄럽게 이어지지 않습니다. 이 부분에 대해 다시 코드를 짜보려 했는데 시간이 부족해서 못 해봤습니다 ㅜㅜ\n\n이건 API 와의 연계가 필요해요 ㅎㅎ\n스크롤 위치와 현재 위치에 도달했을 때의 query를 기억하고,\n새로고침을 했을 때 query와 limit을 기반으로 최초에 렌더링 할 때 필요한 데이터를 API로 불러와야 합니다. \n즉, 렌더 함수만 어떻게 한다고 될 문제는 아니고 router, api 등 다양한 장치와의 연계가 필요해요.\n\n> 다만, AI가 제시하는 코드를 무조건 사용하는 것이 아니라, \"이 코드가 왜 이렇게 동작하는지 이해하고 사용해야 한다\"는 점도 중요하다는 걸 느꼈습니다.\n\n중요한 지점이네요 ㅎㅎ 그래서 저는 앞으로 AI를 사용할 때 기본기가 더 중요하다고 생각해요. AI가 생성하는 코드는 더 많고 다양해질 것이고, 그 코드가 서로 어떻게 상호작용하는지 연계되는지 이해하지 못하면 지금 당장의 문제는 해결할 수 있어도, 리스크가 점점 커질 수 있으니까요!\n\n",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/39"
    }
  },
  {
    "passed": false,
    "name": "김연수",
    "feedback": "안녕하세요 연수님 아쉽지만 채점을 할 수 있을 만큼의 기준이 되지 못하여서 불합격 드리도록 하곘습니다. 2주차에는 조금이라도 진행이 될 수 있기를 바래요. 수고하셨습니다.\n",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/70"
    }
  },
  {
    "passed": false,
    "name": "김유현",
    "feedback": "안녕하세요 유현님!\n\n다음에는 과제 제출하실 때 PR 링크를 올려주시면 좋을 것 같아요!\n지금은 저장소 링크를 올려주셨네요 ㅎㅎ\n\n---\n\n과제 진행해주신 내용 보니까 \n라우터 기능과 정렬, 장바구니 등의 기능이 누락되어있네요 ㅠㅠ\n그래도 끝까지 포기하지 않고 잘 진행해주셔서 감사해요!\n\n---\n\n> SPA 구조/라우터 설계가 더 깔끔하게 개선될 여지가 있는지\n\n저는 이럴 때 \"요구사항\"을 확장해서 생각해보면 좋다고 생각합니다!\n가령 지금은 유현님의 어플리케이션에 강하게 종속된 라우터인데요(pages 폴더에 있는 코드를 가져와 사용하고 있음),\n\n이걸 다른 사람이 만들어놓은 어플리케이션에 적용한다고 했을 때 정상적으로 동작하도록 만들 수 있는 방법을 고민해보시면 좋답니다!\n\n> 현재 구현된 옵저버 기반 상태 관리의 한계점과 개선 방안\n\n무척 세심하게 설계해주셨네요 ㅎㅎ\n이건 제가 선호하는 방식이긴 한데, observer와 상태를 분리해주는 방식이면 좋겠어요! 옵저버는 어디서는 쓰일 수 있는 개념이니까요. 라우터랑도 결합할 수 있고?\n\n그리고 notify를 할 때, 항상 notify를 할 것인지 아닌지에 대한 판단이 필요해요 ㅎㅎ\n가령 state가 변경된게 없는지 깊은 비교를 통해 검사하여, 실제로 변경된 경우에만 notify를 실행하는거죠.\n\n> 현재 테스트코드가 안전하게 작동하도록 설계된 구조인지에 대한 피드백\n\n프론트엔드에서 테스트가 안전하게 동작하기 위한 조건은 이벤트 관리라고 생각합니다. 이벤트를 잘 초기화 해준다거나, 이미 등록된 이벤트를 다시 등록하지 않도록 해준다거나?\n\n다만 이번 기본과제에서 제공하는 단위 테스트의 경우 제가 적절하게 작성하질 못한 것 같아요 ㅠㅠ\n그래서 코드의 문제라기보단 테스트의 문제가 많아서 발생했던 것들이 많았으리라 생각해요. ",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/22"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "- 컴포넌트 간 의존성 분리: 현재 Home.js와 Cart.js에서 cartStore에 직접 의존하고 있어서 테스트하기 어렵고 재사용성이 떨어집니다. 컴포넌트들이 서로 너무 밀접하게 연결되어 있어서 나중에 수정하기 어려울 것 같습니다. 컴포넌트들을 더 독립적으로 만들 수 있는 방법이 있을까요? 예를 들어 Cart 컴포넌트를 다른 프로젝트에서도 사용할 수 있도록 만들려면 어떻게 해야 할지 궁금합니다.\n\nCart컴포넌트를 일반적인 장바구나 형태로 구현해서 어느 프로젝트에서도 사용할 수 있게 만든다고하면 기본적으로 외부와의 인풋은 모두 일반적인 객체로 데이터를 전달 받을 것 같아요. \n리액트 컴포넌트가 아니기 때문에 자바스크립트 객체형태로 인터페이스를 제공하게될 것 같고요.  ….  ..그런데 적다보니 궁금하신 부분은 이것이 아닌 것 같아요.\n저라면 이렇게 구현할 것 같아요. 제어의 역전이라고 하죠 SOLID 원칙중 DIP요 이것을 활용할 것 같아요.\nCart내부에서 cartStore를 직접 사용하는 것이 아니라 생성자에서 cartStore를 주입받는 것이죠.\n테스트할때는 cartStore를 임의로 모킹 객체로 주입해서 원하는 동작을 하도록 만드는 것이죠.\n디커플링에는 이런 류의 스킬이 자주 사용됩니다!\n(사실 모킹은 테스트할 때 피해야하지만 어쩔 수 없는 부분도 있는 것 같습니다.)\n\n\n- 이벤트 리스너 중복 제거: Cart.js의 bindEventListeners() 메서드에서 10개 이상의 이벤트 리스너를 개별적으로 추가하고 있는데, 이벤트 위임을 사용해서 더 효율적으로 관리하는 방법이 있을까요? 특히 data-product-id 속성을 활용한 이벤트 위임 패턴을 적용하면 코드가 더 간단해질 것 같은데, 막상 하려니 떠오르지 않았습니다. 어떤 방식으로 구현하는 것이 좋을지 조언해 주시면 좋겠습니다.\n\n말씀하셨던 대로 이벤트 위임을 사용하셔도 되는데요 결국 어디서 처리하느냐의 문제 인 것이지 코드의 복잡도는 줄어들지 않을 것 같아요.\n그런데 이벤트 위임은 따로 설명할만한 내용이 없을 것 같은데 이벤트 위임 자체가 궁금하신 것일까요?\n카트  root엘리먼트에 이벤트를 걸고 버블링을 활용해서 엘리먼트를 판별하고 data-product-id와 같은 추가 데이터를 활용해서 필요한 동작을 수행하도록 할 수 있을 것 같아요! \n하지만 그보다 더 좋은 것은 실제 리액트가 그렇듯 이벤트 위임으로 처리하지만 위임은 프레임웍 내부에서 처리하고 컴포넌트 코드래밸에서는 컴포넌트 내부에서 이벤트를 바인드하는 코드를 작성하는 것이 코드 리더빌리티가 더 좋은 것 같아요 :) \n\n- 상태 업데이트 로직 최적화: store.js에서 increaseQuantity, decreaseQuantity, toggleItemSelection 등의 메서드들이 비슷한 패턴으로 배열을 조작하고 있습니다. 이런 중복된 로직을 하나의 공통 함수(예: updateItem)로 합쳐서 코드를 더 간결하게 만들 수 있을까요? 그리고 배열을 매번 새로 만드는 것보다 불변성을 유지하면서 성능을 개선하는 방법이 있는지 궁금합니다.\n\n일반적인동작을 하는 공통함수를 만어도 되긴 하지만 저는 map 사용하는 것만 동일하고 실제로 콜백의 코드는 다르기때문에 중복이라고 보진 않습니다. 오히려 이상황에서는 말씀하신 공통합수는 map이라는 인터페이스로 배열이 이미 구현된 것이 아닌가 싶어요.\n\n배열을 매번 새로 만드는 것보다 불변성을 유지하면서 성능을 개선하는 방법이 있긴 있는데요. 이게 직접 구현은 굉장히 어렵습니다.\n그런 리스트를 퍼시스턴트 리스트라고 하는데요. 하스켈이나 리스프같은 언어가 제공하는 리스트들은 기본적으로 퍼시스턴트 리스트를 제공하고 있지만 자바스크립트는 쉽게 구현은 힘들어요 ㅎㅎ\nimmer.js라는 도구가 어느정도 유사하게 동작하도록 구현한 도구입니다. 리스트만 구현한 건 아니지만요 :)\n그리고 생각보다 배열을 새로생성하는 것은 비용이 크지 않습니다. 배열에 들어가는 데이터를 만드는 것이 비용이 크죠.\n\n- 함수명과 변수명 개선: AI의 피드백으로는 Cart.js의 templateContent(), itemCountText() 같은 함수명들이 직관성이 떨어지다고 예를 들어 templateContent()를 renderCartContent()로 바꾸는 것을 제안하는데 어떻게 생각하시는지 궁금합니다. 그리고 어떤 함수와 변수를 더 명확하게 이름 지을 수 있는 방법에 대해 조언받을 수 있을까요?\n\n이부분은 사실 너무 이야기할 것이 많아서 차라리 책을 추천하는 것이 좋을 것 같아요!\n클린코드라는 책의 두번째 챕터가 그런 내용을 다룹니다!\n그리고  함수명은 함수의 의도가 들어나는 이름이면 될 것 같습니다. 지혜님이 생각하기에는 어떤 이름이 지혜님이 작성항 코드의 의도를 드러낸다고 생각하시나요~",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/72"
    }
  },
  {
    "passed": true,
    "name": "김효진",
    "feedback": "안녕하세요 김효진님, 수고하셨습니다. 이번 과제는 프레임워크 없이 순수 JavaScript로 SPA를 구현하면서 현대 프레임워크들이 해결하는 문제들을 직접 경험해보는 것이 목표였습니다. 옵저버 패턴을 적용한 상태 관리와 라우터 구현, 이벤트 핸들러 분리 등 중요한 개념들을 잘 적용해주셨네요.\n\n특히 `src/store/productStore.js`에서 구현한 옵저버 패턴 기반 스토어가 인상적입니다. \n\nconst subscribe = (callback) => {\n  subscribers.push(callback);\n  return () => {\n    const idx = subscribers.indexOf(callback);\n    if (idx > -1) subscribers.splice(idx, 1);\n  };\n};\n```\n\n특히나 return값을 통해서 구독 해제 함수를 반환하는 패턴으로 메모리 누수를 방지한 점이 좋습니다.\n\n아쉽지만 심화과정이 기대요건을 충족하지 못해서 코드의 완성도와 무관하게 심화 과정은 불합격을 드리도록 하겠습니다. 개발자에게 있어서 좋은 코드와 구조는 중요하지만 그 이유가 버그가 없이 요구사항을 만족하는 가치를 전달하는데 있는 것인만큼 우선 완성을 제일 먼저 생각해주기를 발바니다.\n\nAI 도구를 활용하면서도 핵심 개념을 이해하려 노력하신 점이 좋습니다. 다음 과제에서는 꼭 완성부터 하고 나서 테스트를 먼저 확인하며 진행하시면 더 좋은 결과를 얻으실 수 있을 것입니다.\n\n2주차도 화이팅입니다! 😊",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/53"
    }
  },
  {
    "passed": true,
    "name": "김휘린",
    "feedback": "휘린님 수고하셨습니다!\n\n* 저는 작은 컴포넌트 단위에서 해당 컴포넌트만 다시 렌더링을 시킬 수 있는지 궁금합니다.\n\n지금은 렌더링을 컨트롤할 수 있는 방법이 없기때문에 부분렌더링을 할 수 없는 것이 맞습니다.\n향후 과제를 진행하면서는 좀 더 리액트에 가까운 과제로 진행되는데요 그때 해결될 수 있을 것 같아욥!\n\n* 제가 현재 이해한 바로는 리액트는 가상돔이 있어서 돔트리를 비교해서 반영하지만, 가상돔이 없는 제 코드에서는 그게 불가능 하다고 생각하는데, 혹시 가상돔이 없어도 구현할만한 방법이 있는지 궁금합니다.\n\n현재 제출해주신 과제를 기반으로는 불가능하고요.\n가상돔이 없이 선언적으로 구현한다고 하면 컴포넌트가 개별적으로 렌더링을 할 수 있는 방법이 일단 마련되어야할 것 같아요.\n즉 컴포넌트가 렌더링되면 부분적으로 업데이트가 가능해야겠죠\n그러려면 컴포넌트가 어떤 엘리먼트에 속해있는지를 알아야합니다. 현재로는 고려할 것이 많네요 ㅎㅎ\n만약 그런 구조가 만들어졌다면\n만들어주신 스토어를 조금 개선해서\n특정 관심사가 업데이트될때 해당 컴포넌트를 재실행하는 옵저버패턴을 구현하면 될 것 같아요~\n어차피 과제가 진행되면서 해당부분들을 배워나갈 것이라서 지금은 일단 이정도만 생각하셔도 되지 않을까 싶습니다 :)\n\n나중에 추가로 확인하시기 좋게 말씀드리면 react는 해당문제를 리컨실레이션(vdom)을 활용해서 해결했고요 뷰는 반응형 시스템을 활용해서 해결했습니다!\n",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/13"
    }
  },
  {
    "passed": false,
    "name": "박상수",
    "feedback": "안녕하세요 상수님! 1주차 과제 잘 진행해주셨네요 ㅎㅎ\n다만 배포는 해주셨는데, 배포된 페이지가 정상적으로 동작하지 않고 있어요..!\n배포 후 정상동작까지가 심화과제의 채점 범위이다보니.. 이 부분은 아쉽지만 불합격으로 남겨놓겠습니다 ㅠㅠ\n\n그리고 과제 제출 후에도 PR의 내용은 수정해도 무방하기 때문에,\n꼭 PR에 질문이 있으면 남겨주세요!\n\n고생하셨씁니다~",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/66"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "안녕하세요 박소연님! 수고하셨습니다. :) \n\n이번 과제는 프레임워크 없이 SPA의 핵심 기능들을 직접 구현하면서, 현대 프론트엔드 프레임워크들이 해결하고 있는 문제들을 깊이 이해하는 것이 목표였습니다. 우리가 그냥 쓰고 있는 도구들을 직접 만들어 보며 그 작동원리를 이해하면서 우리의 도구를 더 잘 쓸 수 있게 되기를 바랍니다.\n\n과제를 보면서 특히 Pub/Sub 패턴을 활용한 반응형 상태 관리 시스템 구현이 인상적이었습니다. React의 useState와 유사한 방식으로 구현하신 점, 그리고 이에 대한 한계점까지 명확히 인지하고 계신 점이 훌륭합니다. 또한 테스트 코드를 모두 통과시키며 요구사항을 충실히 구현하신 점도 잘하셨습니다.\n\n스스로 작성해둔 라우터의 복잡성 문제나 subscribe를 해제하는 부분이 없는 것에 대한 반성(?)도 좋았습니다. 만약 아는데 어떻게 해야할지 잘 모르겠다면, 그래도 한번 시도를 해보고 피드백을 받아 본다면 앞으로 과제할 때 조금 더 잘 피드백을 드릴 수 있겠네요\n\n회고에서 \"오랜만에 신입때처럼 몰두해서 개발했다\"는 말씀이 인상 깊었습니다. 이런 열정과 도전 정신이 있다면 앞으로도 계속 성장하실 수 있을 것입니다. 2주차도 화이팅입니다! :)\n\n다음은 질문 주신 내용에 대한 구체적인 답변입니다.\n\n---\n\nQ) router 함수를 어떻게 분리해야 할까요?\n\n=> 이미 스스로 주석을 하나씩 달아두었고 스스로 평가하기를 너무 많은 책임을 가지고 있다고 말하는 것처럼 책임과 하나의 책임에 대한 적절한 크기감각은 이미 있는 것 같네요. 그런 쎄함(?)을 느끼면 우선 크기를 나눠줄 생각을 먼저 합시다. 책임을 너무 잘 분리하지 않아도 좋으니 우선 주석을 달아준 그 구간을 분리해서 함수로 빼내는 일을 먼저합니다.\n\n=> 함수로 분리를 하는건 간단합니다. 우선 함수로 감싸고 밖으로 보낸다음 모든 인자만 연결하면 되죠. 심지어 이런건 VSCode에 기능으로도 제공하고 있습니다.\n\n1)\nfunction outerModule() {\n // 원래 코드\n}\nouterModule()\n\n2) 인자 맞춰주고 바깥으로..\nfunction outerModule(a,b,c) {\n // 원래 코드\n}\nouterModule(a,b,c)\n\n=> 그렇게 잘라두고 나면 조금 더 잘 보입니다. 책임에 맞게 분리했는데 괜한 분리를 했는지. 그리고 모듈을 분리하면 해당 로직을 내부에 두는게 맞는지 외부에 위임해야 하는게 맞는지 알 수 있습니다. 특히나 내가 새롭게 라우트를 만드는데 불필요하게 또 적어줘야만 하는게 있는지 정말 내가 적어주지 않으면 안되는 것들로만 구성이 되어 있는지 말이죠..\n\n설명이 엄청 길어질것 같아서 우선 다음번 과제에서는 이런 부분을 만나면 과감하게 함수를 분리해서 책임을 나눠보세요. 우선 시도를 해야 그 다음 피드백을 받을 수 있겠지요. 화이팅입니다 :)\n\n\nQ) 컴포넌트 의존성 주입 패턴 개선 방안\n\n=> 지금 주입받고 있는 공톨 모듈을 받아 줄 수 있는 Context 패턴을 고려해보세요. 의존성들을 하나의 context 객체로 묶어 전달하면 됩니다. 이런 경우 모두에게 의존하게 하는게 아니라 중간 담당자를 두면 변화를 한군데에서 관리를 할 수 있게 됩니다.\n\n```javascript\nconst context = { state, setState, actions: { openCartModal, addToCart, navigateTo } };\npage = ProductListPage(context);\n```\n\nQ) Pub/Sub 패턴 구현의 성능 최적화\n\n=> React의 경우 지금처럼 모든 상태를 1개씩 전달하나 불변성을 통해서 비교의 횟수를 줄이는 방법이고 사실 React는 성능을 희생하고 DX를 높이는 방법을 택했죠.\n\n=> React가 아닌 Vue를 비롯한 다른 모든 프레임워크들은 각 key, path별로 여러개의 pub/sub를 통해서 최소한의 업데이트만 할 수 있도록 만들고 있습니다. 하나의 setState가 아니라 여려개의 signal을 만들수 있겠죠. \n\n\nQ) Router 코드 역할 분리와 복잡성 개선\n\n=> 라우터를 단순히 라우팅만 담당하도록 하고, 페이지별 초기화 로직은 각 페이지 컴포넌트의 생명주기 메서드로 이동시키세요. 예를 들어:\n```javascript\nclass Page {\n  onMount() { /* 초기화 로직 */ }\n  onUnmount() { /* 정리 로직 */ }\n}\n```\n이렇게 하면 라우터는 단순히 페이지 전환과 생명주기 호출만 담당하게 됩니다.\n\n다 아는 패턴이죠? 만들다보면 그렇게 나오는 고민들이 이미 세련된 해법으로 우리가 잘 쓰고 있죠. 모를때에는 내가 아는 정답(!)을 참고해보세요.\n\n\n수고하셨습니다! 다음 주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/17"
    }
  },
  {
    "passed": false,
    "name": "박의근",
    "feedback": "안녕하세요 박의근님, 수고하셨습니다. 이번 과제는 프레임워크 없이 순수 JavaScript로 복잡한 SPA를 구현하면서, 프레임워크가 해결해주는 문제들을 직접 경험해보는 것이 목표였습니다. 이를 통해 DOM 조작, 상태 관리, 라우팅 등의 핵심 개념을 깊이 있게 이해하셨기를 바랬습니다.\n\n아쉽지만 현재 공유해준 코드만으로는 피드백을 할 수 있는 완성도나 채점을 할 수 있는 수준이 아닌것 같아서 불합격을 드립니다. 혹시 PR을 잘못 올린거라면 알려주세요.\n\nQ) Vitest에서 전체/개별 테스트 시 결과가 다른 이유는 무엇인가요?\n\n=> 이는 테스트 간 상태 공유 문제일 가능성이 높습니다. 사실 개별테스트와 전역 테스트마다 독립된 상태를 만들어서 독립성을 만들어야 하는 데 상태에 의존하는 형태로 코딩을 하게 되면 초기 설정에서 테스트를 하는 동안 상태값이 변하게 되고 이에 의존해서 테스트 코드를 만들면 반드시 순서대로 테스트를 해야만 정상동작하는 경우가 생길 수 있습니다.\n\nQ) 웹앱은 정상 동작하나 테스트가 실패하는 경우 어떻게 접근해야 하나요?\n\n=> 테스트는 특정 DOM 구조와 타이밍을 기대합니다. FE는 특정 결과를 눈으로 보이도록 하게 하기 위해서 다양한 방법과 시간차가 존재하는데 테스트 코드는 오로지 데이터의 구조와 값의 유무로만 판단하기에 정상적인 결과라도 테스트의 정상유무를 테스트하는 방법에 따라 실패가 될 수 도 있습니다.\n\n=> 만약 본인의 결과가 문제가 없다면 테스트 코드를 그에 맞게 변경해야하는게 맞습니다. 그러나 테스트 코드가 진실의 원천이 되어야 한다면 테스트 코드에 맞게 코드를 수정을 하는 것이 맞지요. 지금 어느 코드를 기준으로 작성해야할지 또한 개발자가 결정을 해야하는 부분입니다.\n\n\nps.\nAI를 활용하지 않으면 문제 해결이 막막한 것이 과연 정상적인 상황일지.. 궁금합니다.\n\n=> 네 당연합니다. AI가 없던 시절에는 코딩을 할때 어떻게 해야하는지 하루종일 검색해가며 되는 방법을 찾았던 시절이 있었고 검색 엔지니 없던 시절에는 책과 레퍼런스를 보면서 하루종일 사람들이랑 논의하면서 왜 이럴까 고민을 하다가 답을 찾아내는게 개발자의 역할입니다.\n\n=> 설령 AI가 답을 알려주더라도 그 답이 맞는지 안 맞는지, 그 답이 우리의 경우에 맞는 답인 건지, 이걸 어떻게 적용해야하는지 고민하는 것 또한 개발자의 역할입니다.\n\n=> 막연한 상황에서 목표를 정하고 길을 찾고 답을 찾아내 문제를 해결하는 과정을 즐겨주세요! \n\n수고하셨습니다. 2주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/61"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박준형",
    "feedback": "안녕하세요 준형님, 수고하셨습니다. 이번 과제는 프레임워크 없이 SPA를 구현하면서 React와 같은 프레임워크가 해결하는 문제들을 직접 경험해보는 것이 목표였어요. \n\n코드의 구현이 초창기 React의 클래스 컴포넌트의 모습을 보는 것 같아서 인상깊었습니다. 컴포넌트 베이스를 바닐라 자바스크립트로 구현하고, Pub-Sub 패턴 기반의 전역 상태 관리 시스템까지 만들어내셨네요. 특히 메모리 누수 방지를 위한 이벤트 핸들러 관리와 미들웨어 시스템 구현이 인상적입니다.\n\nAI와의 바이브코딩 경험도 흥미롭게 읽었습니다. 단순히 코드를 생성하는 것이 아니라 아키텍처 설계부터 디버깅 미들웨어까지 함께 고민하며 개발하신 과정이 잘 드러나네요.\n\n너무 너무 잘하셨습니다. :)\n\n---\n\nQ) 상속 대신 합성을 어떻게 활용할 수 있을까요?\n\n=> 전통적으로 객체에서 합성을 한다는 건 아래처럼 공통 기능을 만든다음에 this를 넘겨주는 것입니다. this는 baseComponent의 공통 메소드를 가지고 있으니 로직을 분리할수가 있죠.\n\n// 공통 기능을 별도 클래스로 분리\nclass SearchHandler {\n  constructor(component) {\n    this.component = component;  // this를 통째로 받음\n  }\n  \n  handleSearch(query) {\n    this.component.setState({ search: query });\n    this.component.loadProducts();  // component의 메서드 호출\n  }\n}\n```\n\n그렇지만 이런 방식으로 만들면 재사용을 하기 위해 분리를 했는데 Search기능을 활용하기 위한 method들을 각자 만들어줘야 하는 문제가 발생합니다. 내부 구조를 모른채로 재사용을 하고 싶지만 객체지향은 내부 구조의 약속(=인터페이스)를 기준으로 소통하도록 되어 있으니까요.\n\n이러한 이유가 클래스 컴포넌트를 포기하고 hook으로 넘어간 이유이죠. 합성 자체가 잘못된 방식은 아니구요. 명시적으로 좋은 구조를 유지할 수 있다는 장점과 개발자 경험이 더 복잡해진다는 단점을 포기하고 FE 특성상 견고한 구조보다는 단순하고 수정하기 좋은 코드를 만들기 위한 선택이라고 생각해주세요.\n\n수고하셨습니다. 2주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/38"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박창준",
    "feedback": "창준님 첫주차 과제 훌륭하게 해주셨네요!\n작성해주신 내용에 있어서는 다 좋은 방향, 합당한 방향으로 고민을 진행해주신 것 같아요. \n\"브라우저 스토리지를 pub/sub 패턴으로 구독해 상태 변경 시 모달 UI를 자동으로 갱신하도록 개선할 수 있을 것 같습니다.\n다만, 테스트 코드를 변경하지 않고 이런 로직을 도입했을 때 테스트를 통과시킬 수 있을지는 의문입니다.\"\n요 부분에 대해서도 저희들이 전체 수강생들의 채점을 용이하게 하기 위해 어느정도 구현을 강제하게 되는 부분도 없지 않아 있는데요. 이 부분은 쪼금 양해해주시고 여유가 있으실 때 직접 해보고 공유해주시는 것도 좋을 것 같아요 ㅎㅎ\ncursor를 통해서 복잡한 로직을 구현할때는 주석을 통해 어느정도 구현을 해야 하는 부분과 수정하지 말아야 하는 부분을 정의해주시고, 테스트를 만들어서 명확하게 제어하고 변경을 감지하는게 좋다고 많이 이야기 하는데요! 빙글빙글 도는 문제 해결책이 나온다면 AI가 그 문제를 당장 그 컨텍스트 내에서 해결하지 못한다는 증상으로 본다고 하니 새로운 커뮤니케이션을 시작하는것도 방법일 것 같아요.\n\n> Q1. 페이지별 이벤트, 상태 관리, cleanup 추상화를 어떻게 해야할까요?\n현재는 Homepage.js나 ProductDetailPage.js에서 ** 각 페이지에서 이벤트 리스너, 상태 관리, cleanup을 직접 구현하고 있습니다. 그런데 페이지가 많아질수록 공통화할 부분, 추상화할 부분, 컴포넌트화할 부분이 많아지면서 어떤 기준으로 추상화하거나 모듈화하면 좋을지 고민하고 있습니다.\n\n좋은 고민입니다! 어떻게 보면 점점 규모가 커지면서 드는 자연스러운 고민일텐데요. 기준은 사실 이미 잘 만들어진 프레임워크들을 참고하는게 좋은 것 같아요. 각 리액트 컴포넌트, 뷰 컴포넌트에서는 어떤 문제를 해결하기 위해 어떻게 추상화를 했는지와 어떤 일들을 자동으로 해주는지 등을 리스트업 해보면 될 것 같아요. 거기에는 작성해주신것처럼 이벤트 관리나 상태관리, 라이프사이클, 렌더링 로직 등등이 되겠죠! 결국의 이런 추상화는 같은 수준의 이야기를 하고 있는 동작들을 응집시키는 부분이기 때문에, 리스트업 한 동작들이 어떻게 컴포넌트에 묶이는지 고민해보면 추후에 더 도움이 되지 않을까 싶어요.\n\n> Q2. SPA에서 전역 이벤트는 어떤식으로 관리하면 좋을까요?\nApp에서 globalClickHandler()함수가 앱의 전역 이벤트(?) 관리를 하고있는데 이렇게 되면..\n\n넵 맞아요! 정확한 분석입니다. 전역에서 이벤트를 관리하려고 한다면 명확한 제어를 위한 인터페이스가 필요해보이는데요. 말씀해주신것처럼 중복이벤트가 등록되지 않게 하는 것이나 특정 상황에서만 발생하게 하는 경우도 있을거구요.  어떤 기준으로 나눌 수 있는지 구분을 해보면 좋을 것 같아요. 타입화를 시키는 것도 있을것 같고, 페이지 별로 관리를 하는 것도 방법일 수 있구요. 맵이나 셋에 저장을 하면서요 ㅎㅎ \n양이 많지 않다면 이벤트 위임정도로 처리가 가능할 것 같고, 양이 어느정도 많아지면 가장 많이 쓰는 패턴으로 이벤트 버스같은 것을 만드는 것도 방법일 수 있는데 느슨하게 관리를 하면서 문제를 해결하는 것도 좋을 것 같네요.\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/18"
    }
  },
  {
    "passed": true,
    "name": "신홍준",
    "feedback": "안녕하세요 홍준님!\n1주차 과제 잘 진행해주셨네요 ㅎㅎ\n\n제가 과제 제출 주소 변경해달라고 요청 드렸었는데 아마 확인이 잘 안되었나봐요 ㅠㅠ\n\n현빈 매니저님께서 https://github.com/hanghae-plus/front_6th_chapter1-1/pull/77 이 링크로 채점해달라고 요청해주셔서 그렇게 진행하였습니다!\n\n다음에는 유의해서 제출해주세요~\n\n---\n\n> 실무에서는 AI는 커녕 인터넷도 안 되는 환경에서도 종종 일했던 터라 최대한 AI를 활용해 보는 것이 목표였습니다. 하지만 고기도 먹어 본 사람이 더 잘 먹는다는 것처럼 막상 사용하려니 AI와 스스로의 작업 비중이나 역할을 분명하게 나누지 못했습니다.\n\nAI를 활용하여 진행한 과정이 인상깊네요 ㅎㅎ\n저는 컨텍스트를 빠르게 초기화하여 토큰을 절약하는 방식으로 사용하고 있어요.\n대화를 계속 유지하면, 이전 대화의 기록까지 참조해서 토큰 사용량이 많아지는 문제가 있어서요 ㅠㅠ\n\n다음에 기회되면 어떤식으로 사용하는지 보여드리고 싶네요~!\n\n>  목록 페이지에서 상품 목록을 불러오기 전 url에서 검색 조건을 읽어 이를 state와 맞추는 작업을 합니다. 그럼 state가 변경될 것이고 이 state를 구독하고 있는 컴포넌트, 페이지들은 리렌더링이 됩니다. 여기서 의문이 생기는 것이, 결국 모든 기능의 중심은 state인데 정보의 원천이 url인 것이 어색합니다. 보통 실무에선 state와 url의 동기화 문제를 어떻게 해결하나요?\n\n저는 결국 상태관리의 핵심이 원천데이터 관리라고 생각해요.\nurl뿐만 아니라 api를 통해 가져오는 데이터도 원천데이터가 서버에 있는거라서.. 꼭 url에만 해당되진 않으니까요 ㅎㅎ\n\n여튼 query나 param, url 같은 것들을 주소를 통해 가져오고, 가져올 때 값으로 가져온다기보단 함수를 통해 가져오는거죠.\n이 때 저는 getter 를 적극적으로 활용하고 있어요.\n\n자세한건 솔루션 코드를 확인해주세요!\n\n> 위와 같은 렌더링 방식에서 unmount 함수는 어떻게 관리해야 할지 모르겠습니다. innerHTML을 사용하고 있기에 window 이벤트 같은 것을 제외하면 굳이 unmount 함수를 구현할 필요가 없나 싶기도 하지만, advanced.spec 테스트 \"브라우저 뒤로가기/앞으로가기가 올바르게 작동한다\" 항목에서\n너무 빠르게 페이지 이동이 발생하다 보니 url은 목록 페이지인데 뒤늦게 상품 페이지가 렌더링이 된 것 같아 결국 테스트 코드를 손보게 되었습니다. unmount는 언제 사용하는지, 위와 같은 문제를 unmount 함수로 어떻게 해결할 수 있을지 궁금합니다.\n\n저는 unmount가 필요한 이유가 \"클린업\"이라고 생각해요. 컴포넌트가 사라질 때, 페이지를 전환할 때 현재 컴포넌트나 페이지에만 필요한 기능을 없애주는거죠 ㅎㅎ\n\n가령 지금 메인페이지에서는 무한스크롤 기능이 필요한데, 상세페이지에서는 필요없어요. 이런걸 unmount 시점에 없애야 한답니다.\n\n> 옵저버 패턴을 사용해 상태 관리 로직을 구현해 보려 했습니다. 제가 구현한 코드가 옵저버 패턴에 맞게 잘 구성되었는지 검토해 주시고, 보완할 부분을 제안해 주실 수 있을까요? (예시 질문에 있던 항목이지만 제 생각과 너무 일치하여 가져왔습니다!)\n\n굳이 개선해야 한다면, 지금은 key에 옵저버가 걸려있는데요,\n가령 a와 b가 구독하고 있는 함수가 똑같다면, a와 b가 동시에 변경될 때 한 번의 알림만 보내면 될 것 같아요.\n지금은 두 번의 알림을 보내는 방식이라서, 이를 어떻게 해결할 수 있을지 고민해보면 좋답니다!\n\n그리고 key의 값이 변경될 때 옵저버를 실행하고 있는데, 값이 만약 객체거나 배열일 때는 값이 실제로 변경되지 않아도 참조하고 있는 메모리가 달라질 때에도 notify가 발생할 수 있답니다 ㅎㅎ\n\n이에 대한 고민도 필요해요!",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/77"
    }
  },
  {
    "passed": false,
    "name": "신희원",
    "feedback": "희원님 수고하셨습니다!\n\nQ. 지금 폴더 구조에 대한 체계적인 개선을 하지 못하고 개발을 진행했었는데, 여기서 개선된다면 어떤 구조로 정리 해보기를 추천하시나요?\n\n지금 과제는 폴더구조가 많이 중요하진 않을 것 같아요~ 지금으로도 충분해보입니다. 더 개선해야할 부분은 보이지 않는 것 같아요 다른 것을 제안드릴 순 있지만 더 나은 것은 아닐것같아요. 지금도 충분합니다 :)\n\nQ. 위와 관련한 질문인데, 어떤 개념을 공부하면 좋을지 피드백 부탁드립니다.\n\n요즘은 FSD라는 방법론이 많이 논의되고 있어요.\nFSD자체가 뭐 끝판왕은 아니지만 FSD가 어떤 고민이 있었고 그 고민과 문제를 어떻게해결했는지를 이해하는 것은 큰 도움이 될 것 같습니다~\n\nQ. main.js 함수에서 이벤트에 대한 핸들러 함수를 만들었는데, 렌더링이 된 후 이벤트 위임하는 코드를 넣어줬습니다. (cursor이용) 보통은 렌더링이 된 후, 이벤트를 위임시키는 함수를 적용하는게 맞는 것인지 궁금합니다. (아직까지 AI가 짜주는 코드가 좋은 코드인지 아닌지 구분하는게 어렵습니다.)\n\n이벤트 위임(event delegation)은 렌더링 후에 적용하는 것이 맞습니다. 이는 DOM 요소가 실제로 존재해야 이벤트를 바인딩할 수 있으니까요~ 이벤트 위임이라는 기법은 상위 컨테이너에 이벤트 리스너를 붙이고, 이벤트가 발생했을 때 특정 조건(예: cursor나 dataset 속성 등)을 기반으로 이벤트 핸들러를 호출합니다. 이런 방식은 여러 개의 자식 요소가 동적으로 생성될 때 성능과 관리 측면에서 효율적이에요~ 사실 나중에 배우시겠지만 근본적으로는 리액트도 이 방법을 활용하고 있습니다!\n\n\n저도 vscode를 사용하지 않아서요 ㅜㅜ 익스텐션관련해서는 준일님에게 물어보시면 좋을 것 같아요!",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/16"
    }
  },
  {
    "passed": false,
    "name": "양성진",
    "feedback": "안녕하세요 성진님~\n1주차 과제 잘 진행해주셨네요 ㅎㅎ \nAI 활용에 대한 복잡 미묘한 감정을 느끼신것 같군요 ㅋㅋ\n지금은 소화할 시간이 부족해써 그랬으리라 생각해요.\n1주일이라는 시간이 짧기도 했고..!?\n다만 내가 혼자서 할 수 없는 일을 AI와 팀의 도움을 받아서 함께 해결하는 경험도 무척 중요하다고 생각합니다! 우리가 할 수 있는 일의 범위를 넓혀주는거니까요! 대신 소화하는 과정도 꼭 챙겨주세요!\n\n---\n\n> store을 만들때 옵저버 패턴을 이용해서 만들었는데 store를 두가지로 나눠서 작업을했는데 보완할 내용이 있는지 구성은 잘한건지 잘모르겠습니다.\n\n나눠서 하는건 큰 문제되가 되지 않는다고 생각해요! 다만 공통으로 사용할 수 있는 로직이 있을 것 같은데, 지금은 이런게 추상화 되지 않았은 상태라서 아쉽네요!\n옵저버 같은걸 store가 공통으로 사용할 수 있게 하면 어떨까요?\n\n> Home.js에서 기본과제 1-1 테스트 때문에 원래 Store을 썻다가 loading하는 부분만 모듈 스코프를 이용했는데.. 왜 store을 사용하면 테스트가 통과가 안되는지 알수가 있을까요..\n\n이 부분은 AS-IS와 TO-BE의 코드를 보여주셔야 이해할 수 있을 것 같아요 ㅎㅎ; 텍스트만 보고는 뭘 어떻게 하려고 했다는 뜻인지 이해하기가 어렵네요 ㅠㅠ\n\n아니면 커밋 링크라도 주셨으면 좋았을 것 같아요.\n\n> infinitescroll.js) 무한스크롤을 구현할때, e2e테스트에서 추가상품대기 부분에서 20개씩 카드가 40개가 나오면 되는 부분에서 다음페이지로 추가로 api호출이 안됐습니다. 로컬환경에서는 잘되었는데, 테스트에서는 왜 안되는지 궁금합니다.\n\n성진님..!\n이건 테스트를 통과하는게 이상한 것 같아요.\n지금 배포된 페이지에서도, 로컬에서도, 로컬 테스트에서도 저는 다 실패하네요 ㅎㅎ ㅠㅠ",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/60"
    }
  },
  {
    "passed": true,
    "name": "양창훈",
    "feedback": "안녕하세요 양창훈님, 수고하셨습니다. 이번 과제는 프레임워크 없이 순수 JavaScript로 SPA를 구현하면서 상태 관리, 라우팅, 렌더링 최적화 등의 핵심 개념을 체득하는 것이 목표였습니다. 특히 이벤트 바인딩과 재렌더링 타이밍에 대한 이해를 얻으셨다니 좋은 성과네요. \n\n사실 이러한 코딩은 프레임워크를 쓰기에 할 필요는 없지만 이러한 개발을 직접 경험하게 되면 알게 되는 이해의 선명도가 달라지는 만큼 어려웠던 경험을 해본 것이 큰 자산이 될거에요.\n\n말씀해주신대로 코드를 살펴보니 `productPage.js`의 `bindEvents` 함수에서 이벤트 리스너를 중복 등록하는 문제가 있네요. 매번 `removeEventListener` 없이 `addEventListener`만 호출하면 동일한 핸들러가 누적됩니다.\n\n이를 해결하기 위해서 React는 실제로 DOM이벤트는 한번만 위임을 하고 나머지는 컴포넌트의 여부에 따라 이벤트 핸들러를 위임하는 방식을 하고 있습니다. 다른 프레임워크들은 컴포넌트가 등록할때 이벤트를 연결하고 제거될때마다 자동으로 이벤트 핸들러를 떼어내는 방법을 쓰고 있죠.\n\n이 코드의 경우 라우트 단위로 이벤트를 연결하고 있기에 라우트가 바뀌고 bindEvents를 하기전에 모든 이벤트를 다 해제해주는 방식으로 내재화 시키는 방향으로 만들 수 있었겠네요.\n\n사실 지금 쓰고 있는 구조가 일종의 정답지인만큼 더 잘하기 위해서는 현대 프론트엔드 구조가 어떻게 되어있나 생각하시면서 구조를 만들어가면 더 이해가 잘되고 좋은 구조의 코드를 작성하실 수 있을거에요.\n\n다음은 질문 주신 내용에 대한 구체적인 답변입니다.\n\n---\n\nQ) bindEvent 중복 문제와 removeEventListener\n=> 피드백에 설명을 이미 했군요. DOM 이벤트는 하나만 쓰고 위임을 하거나 컴포넌트 등록시 이벤트를 등록하고 해제시 삭제하는 방식으로 만들면 됩니다. 대게 eventListner등록을 하고 해제하는 코드를 return해서 보관하고 있다가 일괄로 호출하는 방법을 사용합니다.\n\nQ) 컴포넌트 분리 기준\n=> 내가 현재 쓰고 있는 현대적 방식과 최대한 닯게 작성해보려고 하세요. 독특하고 유니크한 해법을 하지 않아도 됩니다. 어차피 현업에서는 오랫동안 검증된 방식으로 하게 될거잖아요? 그러니 내가 현재 쓰고 있는 프론트엔드 개념과 최대한 일치하도록 만들어 보세요.\n\nQ) 상세페이지 로딩 속도\n\n=> `render()` 함수가 여러 번 호출되거나 불필요한 DOM 재생성이 원인일 수 있습니다. 이벤트나 렌더의 중복으로 인해 불필요한 로직이 있을거라 생각합니다. 로그를 통해서 확인보시죠.\n\n=> 그리고 이러한 고민보다도 일단 시간내 요구사항을 다 만족시키는 코드를 작성하는 것을 더 우선시해서 2주차 코드는 꼭 테스트 코드가 다 통과되는 코드를 한번 만들어 봅시다! \n\n수고하셨습니다. 2주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/23"
    }
  },
  {
    "passed": true,
    "name": "여진석",
    "feedback": "안녕하세요 여진석님, 수고하셨습니다. 이번 과제는 프레임워크 없이 SPA의 핵심 기능들을 직접 구현하면서 React가 해결해온 문제들을 깊이 이해하는 것이 목표였습니다. 일부 코드들은 TypeScript로 마이그레이션하면서 완성도 높은 구조를 만들어주신 점이 인상적이네요.\n\ncommon쪽 설계구조를 참 탄탄하게 잘 고민해서 구성한 것 같아요. Component 추상 클래스의 생명주기 관리와 EventDelegator의 타입 안전한 이벤트 위임 구현이 잘 되어있습니다. MVC 구조로 관심사를 분리하고 옵저버 패턴으로 상태 관리를 구현한 접근도 좋았습니다.\n\n아쉬운 점이 있다면 구조는 잘 잡아두었는데 상태 변경 -> 렌더링 -> 이벤트 연동 -> 이벤트 -> 상태 변경 ... 등의 사이클이 내재화되어 동작하지 못하고 계층을 넘나들며 호출을 하고 있는 부분입니다.\n\n그리고 코드 전반적으로 이벤트를 연동하는 방식이나 상태를 업데이트를 하는 방법,  DOM을 사용하는 방식들에서 일관성이 부족하다 느껴졌습니다. \n\n1주차인만큼 그렇게 여러가지 시도를 하게 되면서 이런 방법은 이런게 좋구나 혹은 이건 분명 여기에 안 써도 될 코드인걸 알겠는데 어떻게 하면 좋을까? 하는 고민들로 하여금 성장의 발판이 되어 주었기를 바랍니다.\n\n앞으로도 함께 성장해나가요. 2주차도 화이팅입니다! :)\n\n---\n\nQ) MVC 구조가 잘 구성되었는지\n=> 전반적으로 잘 구성되었습니다. Store(Model), Component(View), Controller(API 핸들링) 분리가 명확합니다. 다만 시간 부족으로 일관성을 지키지 못하고 구조가 지켜지지 않거나 DOM이 추가가 된다거나 render나 subsctibe를 수동으로 작업하고 있는 부분들이 아쉽습니다.\n\n\nQ) 옵저버 패턴 구현\n=> SearchParams → Controller → Store → Component 흐름이 잘 구성되어 있습니다. 단방향 데이터 흐름이 명확해서 디버깅과 유지보수가 용이할 것 같네요. 다만 구독 해제 로직이 누락되기 쉬운 구조라 메모리 누수 위험이 있어 보입니다.\n\n**Q) mount/unmount 보일러플레이트 개선**\n=> 컴포넌트 트리 구조를 만들어 자식 컴포넌트를 자동으로 관리하면 어떨까요? 부모 컴포넌트가 mount/unmount될 때 자식들도 자동으로 처리되도록 하면 보일러플레이트를 크게 줄일 수 있습니다.\n\n```javascript\nabstract class Component {\n  children: Component[] = [];\n  \n  addChild(child: Component) {\n    this.children.push(child);\n  }\n  \n  mount(target: HTMLElement) {\n    // ...기존 로직\n    this.children.forEach(child => child.mount(this.el));\n  }\n}\n```\n\n**Q) 구현 방식의 완성도**\n=> 핵심 개념(라우터, 컴포넌트, 이벤트 위임)은 80% 정도 잘 구현되었습니다. 심화 과제 실패는 주로 라우터의 쿼리 파라미터 처리와 새로고침 시 상태 복원 로직 때문으로 보입니다. History API 사용 시 `pushState`와 `replaceState`의 차이를 명확히 하고, URL 파싱/생성 로직을 더 견고하게 만들면 해결될 것 같습니다.",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/50"
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "안녕하세요 찬규님! 1주차 과제 잘 진행해주셨네요 ㅎㅎ 너무 고생하셨어요!\n\n> 회사 제품 특성상 요구사항이 빠르게 변경되기 때문에 실무에서 사용하기는 다소 어려울 것 같다는 생각도 들지만, 테스트라는 것 자체가 어떻게 보면 제품의 히스토리와 경험을 쌓는 과정이기 때문에 시도해볼 만하다고 생각합니다.\n\n요구사항이 빠르게 변할수록 오히려 테스트가 더 필요하다고 생각합니다 ㅎㅎ\n이에 대한 부분은 아마 7주차~8주차 때 알게되리라 생각해요.\n꼭 지금처럼 단위테스트 방식으로 작성하지 않아도 e2e 테스트 방식으로 작성되어있다면 요구사항에도 더 빠르게 더 정확하게 대응할 수 있다고 생각해요.\n\nplaywright autogen 같은 기능을 이용해보시면 알 수 있답니다 ㅋㅋ\n\n> 빠르게 변경되는 요구사항이 문제라면 런타임이나 완전한 서비스 비즈니스 로직을 테스트하는 것이 아닌, 코어 레벨의 코드만 테스트해봐도 충분히 의미가 있을 것 같아요.\n\n이에해 완전히 동의합니다! 코어로직에 대한 테스트는 필수라고 생각해요!\n\n> 이벤트 관리 관련\n\n바닐라로 작성한다고 했을 때, 사실 지금이 최선의 방식이지 않을까? 라는 생각이 들어요 ㅎㅎ\n\n다만 이벤트 위임에 대한 코드를 추상화해서 관리하면 좋답니다.\n제가 만들어놓은 솔루션을 토대로 참고해보세요!\n저는 이벤트를 하나의 파일에 만들어서 관리했는데, 사실 각각의 컴포넌트에 만들어서 관리하는게 더 좋다고 생각해요. ",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/20"
    }
  },
  {
    "passed": true,
    "name": "오하늘",
    "feedback": "하늘님 수고하셨습니다!\n\n라이프 사이클 함수는 실행 위치가 중요하기 때문에 말씀하신 대로 정해진 위치에서 반복적이지만 if문을 활용해서 체크하는 수밖에 없을 것 같아요.\n만약 정해진 위치가 없고 단순히 정해진 함수만 실행한다면\n[‘init’, ‘mount’, ‘unmount’].forEach(k => Page[key]?.()) 이런식으로 할 수 있겠죠?\n일단 저는 저렇게 생각하는데요 해당 부분은 vue의 코드를 살펴보시면 참고가 될 수 있을 것 같아요!\n어떻게든 if문을 제거해 동작하는 코드를 만들 수는 있겠지만 배보다 배꼽이 더 커보입니다. ㅎㅎ",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/59"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "안녕하세요 유윤우님, 프레임워크 없이 SPA를 구현하시느라 정말 수고하셨습니다. 이번 과제는 React나 Vue 같은 프레임워크가 내부적으로 해결하고 있는 라우팅, 상태관리, 렌더링 최적화 등의 문제를 직접 경험해보는 것이 목표였습니다. 참고 자료 없이 순수하게 도전하신 점이 정말 인상적이네요.\n\n특히 잘하신 부분은 `createState`를 통한 전역 상태 관리 구현과 이벤트 위임 패턴의 활용입니다. `src/utils/store.js`에서 Map을 활용한 상태 저장소 구현은 간결하면서도 효과적입니다. 또한 페이지별 라이프사이클을 `onMount`/`onUnmount` 메서드로 구현하신 아이디어도 좋았습니다.\n\n조금 개선을 해야할 부분이 있다면 현대 프레임워크의 핵심 구조인 데이터와 렌더링의 책임을 완전히 분리하고 데이터가 변경이 되면 자동으로 렌더링을 해준다라는 것을 구현이 되었다면 좋았을 것 같네요. 현재는 데이터의 처리와 화면을 그리는 과정이 하나의 프레임워크로 만들어지지 않았기 때문에 코드 곳곳에서 수동으로 updateCurrent()가 여러 곳에서 호출되고 있네요.\n\n이러한 점은 개발자의 DX측면에서도 혹은 불필요한 업데이트를 여러번하게 만들 수 있는 패턴이니 setState와 render의 책임을 core로 주도록 만들어 보는 건 어떨까요?\n\n나아가 현재 렌더링, 이벤트연동, 로직처리 등의 레이어 분리 구조까지는 되어 있으나 이를 하나로 묶어주는 컴포넌트 단위로 만들 수 있는 구조가 없다보니 결과적으로 events.js가 너무 비대해졌죠.\n\n작성해야하는 코드 중 내가 꼭 이걸 써야 해? 하는 부분을 core로 넘겨주고 관련이 없는 코드가 한 군데 같이 있지 않도록 만들어주는 법을 다음번 과제를 통해 해결해보기를 바랍니다!\n\n---\n\nQ) 코어한 기능에 문제가있는데 조금만 건드려도 문제가 다발적으로 터지는 상황에서 리팩토링을 진행하시는 플로우가 궁금합니다.\n\n=> 우선 코드를 작게 만드는게 제일 중요합니다. 코드가 커질 수록 생각해야하는 경우의 수가 많죠. 그러니 문제는 없지만 코드를 작게 만드는게 제일 중요합니다. 나중에 발제로 만나게 될거라 설명하면서 너무 길어지므로 AI에게 \"지금 이 코드를 순수함수로 최대한 많이 단일 책임의 의미단위로 분리해줘\"라고 한번 해보시고 코드의 변화가 없이 코드를 잘게 쪼갠다는게 무슨 의미인지 아실꺼에요.\n\n=> 그 다음은 이러한 문제 없는 코드들의 순서를 통해서 코드를 만들어가면 내가 결과적으로는 큰 코드를 만들지만 작은 코드를 다루게 되면서 다발적 에러 발생을 줄일 수 있습니다.\n\n\nQ) 이벤트 위임 코드 개선 방법이 궁금합니다.\n\n=> 해당 코드는 단순히 위치의 문제입니다. 해당 코드들이 꼭 events.js에 모여있어야 할 필요는 없죠. 관련있는것들은 최대한 가까이 둔다는 원칙에 맞게 적절히 이벤트가 필요로 하는 곳에 분리를 해보세요. 그것만으로로 충분히 응집도를 높이 좋은 코드가 될거에요.\n\n\nQ) 리렌더링 플로우를 정상적으로 만들려면?\n\n=> 상태의 변경 -> 변화 감지 -> 자동 렌더링이 될 수 있도록 setState의 함수의 역할을 늘리는 방식으로 만들어야 합니다. 이 과정에서 변하지 않아도 될 부분은 유지하고 변화해야 하는 부분만 수정하는 게 프레임워크의 주요 알고리즘이고 그걸 다 구현한다는건 쉽지 않겠지만 이제 앞으로 배우게 될 부분이라 다음 과제를 기대해주세요!\n\n수고하셨습니다. 2주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/10"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "윤영서",
    "feedback": "안녕하세요 영서님!!!\n이번 주에 제일 고생하신 영서님.... ㅠㅠ 정말 너무너무 감사합니다. 말로 다 표현하기가 어렵네요 ㅋㅋ\n\n> 배포를 진행하면서 다른분들을 도와드리고 gh-pages를 통한 spa 배포에 대한 이해가 높아진 것 같습니다...ㅎㅎ;; 이렇게 다양한 에러를 접하게 될 줄은...\n\n\"배포 오류, 어디까지 경험해봤니?\" 이런 주제로 하나 글을 작성해주셔도 좋겠네요 ㅋㅋ\n\n> 요컨데 지금은 카테고리와 상품을 동시에 불러야한다는 요구사항이 없고, 테스트 코드상에서 다음과 같이 상품은 findByText를 통해 찾고 카테고리는 getByText를 통해서 찾게되어 '동시에 불러야한다는'의미가 조금 모호하지 않나라는 생각이 들었습니다. 그리고 RTL의 내장함수들을 사용하는것이 아닌 querySelector를 사용하는 코드가 많았는데 테스트가 불안정하고, 디버깅도 어렵다는 생각이 들었습니다. 요 부분도 다음 기수에 반영이 되면 어떨까...하는 생각이 들었습니다 ㅎㅎ...\n\n저도 이번에 많이 느낀 부분인데요, 다음에는 아예 1주차에는 단위테스트를 없애버릴 생각입니다. 모호한 부분도 많고, 정확하게 테스트 하지 못하는 부분도 많아서요.\n좋은 의견 너무 감사합니다 영서님!\n\n> 사실 AI를 사용함에 있어서 그렇게까지 잘 사용하고있는지는 모르겠고, 좀 더 제가 처해있는 상황을 설명하려고 하면 말을 잘 알아듣는 느낌이었습니다. (요건 프롬프트 엔지니어링을 잘 몰라 그럴 수도 있겠습니다만) 빠르게 컴포넌트를 분리하는 과정에서 디자인등이 누락되는것들이 있었는데, 그 이전에 디자인을 누락하지 않고 그대로 분리해달라고 좀 더 자세히 명세를 하면 제가 의도한 바와 동일하게 작성해주는것 같았습니다.\n\n어떤 방식으로 명령했는지 기억나는게 있으면 같이 명시해주셔도 좋답니다!\n\n> 한계점이 있다면 전체적인 아키텍처 설계나 근본적인 문제 해결은 여전히 사람이 판단해야 했습니다. AI가 제안한 코드도 결국 테스트를 통해 검증하는 과정이 필요했습니다\n\n이에 대한 내용도 동의합니다 ㅎㅎ 다만 요즘엔 역으로, AI에게 테스트를 작성하게 하는 것 같네요 ㅋㅋ\n\n> 이렇게 로컬스토리지를 명시적으로 초기화하는경우에 어떻게하면 클라이언트에서도 상태가 비워짐을 알 수 있을까요?\n\n사실 이번에 저도 솔루션 만들면서 겪어던 문제인데요,\n\n제가 해결한 방법은, 값을 조회할 때 무조건 localStorage 를 통해 조회하도록 만들었어요. 근데.. 이게 좋은 방법이라는 생각은 안 들어요 ㅋㅋ\n\n정석은 storage 이벤트를 통해 관리하는 방법이 이라고 생각해요.\n\n성호 코치님의 아티클: https://blog.shiren.dev/ko/post/2023-04-18\n공식문서: https://developer.mozilla.org/en-US/docs/Web/API/Window/storage_event\n\n아마 react에서 storage를 관리할 때도 똑같은 문제를 겪는 경우가 많으리라 생각합니다 ㅋㅋ",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/2"
    }
  },
  {
    "passed": false,
    "name": "이가은",
    "feedback": "안녕하세요 가은, 수고하셨습니다. 이번 과제는 프레임워크 없이 SPA를 구현하면서 바닐라 자바스크립트의 핵심 개념들을 깊이 이해하는 것이 목표였습니다. 특히 상태 관리, 라우팅, 이벤트 처리 등 프레임워크가 해결해주던 문제들을 직접 경험해보셨기를 바랍니다.\n\n분명 과제를 하는 동안 여러가지 경험들을 했었지만 결과가 저희가 제시했던 기준을 만족시키지 못했기에 불합격을 드립니다. 개발자에게는 좋은 코드 이전에 요구사항의 완성과 딜리버리가 제일 중요한 만큼 최선을 다해 우선 되는 코드를 먼저 만들고 좋은 코드로 만들자고 계속해서 다짐해주세요. 과제에 주어지는 시간이 많지 않은 만큼 좋은 코드보다 완성을 목표로 삼아주기를 바랍니다.\n\n그리고 모르면 물어보고 함께 하는 경험또한 저희가 꼭 배워가고 익혀하고 경험했으면 하는 부분입니다. 이제 1주차에 깨달음(!)을 얻었으니 완성을 위해서 뭐든 시도해보는 그런 문제해결사적인 개발자의 면모를 남은 주차동안 연습해가기를 바랍니다.\n\n---\n\nQ) 너무 테스트코드에 의존해서 UI를 만드는게 아닐까의 고민\n\n=> 테스트는 요구사항을 명확히 하는 가이드입니다. TDD라는 테스트 주도 개발이라는 방법도 있지만 일반적인 방식인 요구사항을 이해한채로 만들어가면서 놓치는 부분을 테스트를 통해 주도해가면 되죠. \n\n=> 아직 익숙지 않고 테스트의 빨간 경고등에게 계속 주의(?)를 뺴았길 수도 있겠지만 차자 적응해 나갈거라 기대합니다. 화이팅입니다\n\n수고하셨습니다. 2주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/54"
    }
  },
  {
    "passed": true,
    "name": "이민재",
    "feedback": "안녕하세요 민재님!\n과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다.\n다만 배포된 페이지에서는 무한 스크롤이 정상적으로 동작하지 않네요 ㅠㅠ 다음엔 배포 했을 때에도 잘 동작하는지 확인 부탁드립니다!!\n\n---\n\n> 상품 리스트, 상품 상세, 장바구니가 모두 store.js의 인스턴스를 공유하고 있는데(상품 상세와 장바구니는 store를 만들지 않았지만 만들 계획..) 이 방식이 기능 간 상태 충돌을 일으키지는 않을지... 또, 장바구니 같은 경우에 로컬 스토리지와 전역 store로 상태관리를 할 필요가 있을지 궁금합니다.\n\n이럴 때는 충돌 가능성이 있는 코드를 민재님께서 아예 언급을 해주시면 좋답니다!\n\n아마 store 인스턴스를 공유한다고 해서 문제가 발생하진 않을 것 같아요. 오히려 같이 공유하고 있어야 정확하게 동작할 가능성이 높답니다 ㅎㅎ 그래서 이걸 어떻게 나눠서 정교하게 관리하는지가 중요한데, 그게 쉽진 않아요.\n\n이를 위해 redux에서는 slice 라는 개념을 도입해서 store의 관심사를 분리하여 관리하면서도 하나의 store를 통해 사용할 수 있도록 만들어주고 있답니다.\n\n여기서 중요한건, \"하나의 인스턴스\"여야 문제되지 않을 확률이 오히려 높다는 점이랍니다..!\n\n> 현업에서도 종종 URL 쿼리 스트링만으로 UI 상태 관리를 하는 로직을 보기도 하는데 상태 관리를 어떻게 하는 것이 가장 적절한 것일지 조언해주실 수 있을까요?\n\nurl의 상태를 따로 관리한다기보단,\n\n제가 작성한 솔루션을 보시면 \n값을 가져올 땐 항상 url에서 가져오고\n값을 설정할 땐 항상 url에 먼저 set을 하는거죠 ㅎㅎ\n\n원본은 url이고 이를 추상화해서 사용하는 방식을 상상해주시면 좋답니다.\n",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/11"
    }
  },
  {
    "passed": true,
    "name": "이유진",
    "feedback": "유진님 수고하셨습니다!\n\n회고에서 말씀하신대로 이번 기회로 SPA의 기본적인 동작원리와 DOM API 활용법에 대한 이해가 높아진 것으로도 충분한 것 같습니다.\n이런 몰입의 경험을 더 많이 경험하시면 좋을 것 같습니다 :)\n이대로 이과제를 넘기시지 마시고 솔루션 코드가 나오면 코드를 살펴보시며 다시 한번 복습해주시면 좋을 것 같습니다!",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/71"
    }
  },
  {
    "passed": true,
    "name": "이은지",
    "feedback": "은지님 수고 많으셨습니다! \n회고문서도 잘 작성해주셨네요 ㅎㅎ\n코드 내용들도 뭔가 고민하신 흔적이 보입니다. 과제가 기대하는 이상을 해주신 부분도 있고요 ㅎㅎㅎ\n컴포넌트와 스토어등 주요 개념을 추상화해서 프레임웍을 착안하신 부분도 돋보입니다 :)\n\n- Component를 언제 어디서 cleanup/destroy 해야할 지 모르겠습니다.\n지금처럼 라우터에서 처리하면 되지 않을까 싶습니다.  그렇게하려면 자식 컴포넌트를 관리하는 부분도 컴포넌트에서 추상화되어야할 것 같아요 :)\n예를들어 배열로 관리해서 페이지 컴포넌트가 변경될때 기존 컴포넌트의 제거 메서드를 실행하고 해당 컴포넌트는 자식노드가 있으면 자식컴포넌드틀도 해댕 메서드를 실행하는 것이죠.\n\n- Store에 사용된 옵저버 패턴과 그 사용 방식이 적절한 지 모르겠습니다. 컴포넌트에서 setup에서 subscribe하고 cleanup시 unsubscribe시키고 있는데, 그게 맞는지\n넵 일반적인 옵저버패턴으로 보입니다. 사실 이부분은 준일님이 이 과제에서 기대했던 내용은 아니었던 것 같은데 초과해서 과제를 달성하셨네요 :) \n물론 장치가 여러가지가 있고 구조적으로는 다르지만 근본적으로는 뷰가 이런 원리로 만들어졌습니다!\n\n- 라우터 상태값과 메서드들을 편리하게 사용하기 위한 useRouter.js를 만들어 사용했습니다. (hook은 아니지만 hook 폴더에 있음) 좀 더 편리하고 명쾌한 방법이 없을까 고민됩니다.\n네 해당 코드는 비슷한 메서드가 반복되는 것 같은데욥. 사실 우리 과제에서는 훅이란 구조를 끼워맞출필요는 없는 것 같아요.\n저라면 그냥 라우터를 직접 사용했을것 같아요. 라우터가 없는 예외는 언제 발생하는지 지금으로서는 저는 예측이 안되네요!",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/64"
    }
  },
  {
    "passed": false,
    "name": "이의찬",
    "feedback": "넵 의찬님 이번에는 과제 하실 시간이 부족하셨던 것 같습니다 :)\n나중에 솔루션 코드가 나오면 코드를 살펴보시고 복기하시는 시간을 꼭 가지시면 좋을 것 같아요!\n",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/15"
    }
  },
  {
    "passed": true,
    "name": "이정우",
    "feedback": "안녕하세요 이정우님, 수고하셨습니다. 이번 과제는 프레임워크 없이 SPA를 구현하면서 라이브러리와 프레임워크가 해결해온 문제들을 직접 경험해보는 의도를 가진 과제였어요. 특히 라우팅, 상태 관리, 컴포넌트 구조화 등의 핵심 개념들을 바닐라 자바스크립트로 구현하면서 깊이 있는 학습을 하셨기를 바랍니다.\n\n과제를 보면서 특히 폴더 구조를 역할에 맞게 체계적으로 정리하신 점이 인상적이었습니다. controllers, services, pages로 명확하게 분리하여 MVC 패턴에 가까운 구조를 만드셨네요. 또한 Router 클래스를 직접 구현하여 SPA 네비게이션을 처리하신 부분도 잘하셨습니다.\n\n아직은 데이터와 DOM 렌더링이 완전히 분리되지 않은 혼합된 형태가 보이네요. HomePage.js에서 HTML 문자열을 직접 반환하고, HomePageController에서 상태 변경 후 전체를 다시 렌더링하는 구조라거나 이벤트 처리시에 state는 값으로 변경하고 this.render()를 수동으로 실행하는 코드도 보이고, DOM 조작을 직접하는 코드도 종종 섞여있네요.\n\n이렇게 만들게 되면 작은 변경사항에도 큰 DOM 조작이 필요하고, 상태와 뷰의 동기화를 수동으로 관리해야 합니다. 이런 구조가 왜 개발을 어렵게 만드는지를 몸소 체험하는 소중한 경험이 되었을거에요.\n\n앞으로도 이런 low-level 구현 경험이 프레임워크를 더 깊이 이해하는 데 큰 도움이 될 거예요. 2주차도 화이팅입니다! :)\n\nps\n테스트 실패를 보니 **\"총 ㅇㅇ개의 상품\"** 텍스트를 찾지 못하는 문제가 반복적으로 발생하고 있네요. HomePage.js에서 `<span>총 </span><span>${total}</span><span>개의 상품</span>` 형태로 분리되어 있는데, 테스트가 이를 하나의 텍스트로 인식하지 못하는 것 같습니다. `총 ${total}개의 상품`처럼 하나의 문자열로 만들어보세요.\n",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/55"
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "안녕하세요 지현님!\n1주차 과제 잘 진행해주셨네요 ㅎㅎ 너무 고생했어요!\n\n> 어떤 우선순위로 기본 구조를 잡는가에 대해서 궁금증이 일어, 준일 코치님 멘토링때 질문을 드렸었습니다. 야근으로 인해 알려주셨던 구조를 잡지 못해 아쉬운 점이 큽니다.\n\n제가 이야기 했던게 정답은 아니라고 생각해요! 저의 경험적인 측면이니까요. 개인적으로, 나만의 경험을 만들어가는게 중요하다고 생각합니다! 이미 진행해보셨으니까 제가 제안하는 순서보다 지현님께서 \"이렇게 하는게 더 좋을 것 같은데?\" 라고 생각하는 리팩토링 과정이나 순서가 있으면 그대로 시도해보시는걸 추천드려요!\n\n그래야 온전한 나의 것이 된답니다!\n\n> 리팩토링 순서에 대해서 문의드립니다. 이벤트 시스템 > 컴포넌트 라이프 사이클 시스템 > 상태관리 시스템 > 관련 라우팅 시스템 순서가 괜찮을까요?\n\n굳이 저의 기준으로 순서를 정해보자면..\n\n무엇이 제일 중요한가 따져봤을 때, 저는 상태관리 시스템이라고 생각합니다 ㅎㅎ\n\n상태관리 > 라이프 사이클 > 이벤트 시스템> 라우팅 시스템\n\n이런 순서랄까..\n왜냐면 상태에서 부터 렌더링이 전파되고,\n상태를 잘 만들어놓으면 이벤트에서 상태만 변경해도 UI에 반영될 수 있으니까요 ㅎㅎ\n\n",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/27"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이지훈",
    "feedback": "안녕하세요 지훈님!\n1주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 바닐라 자바스크립트로 컴포넌트를 작성한 예시들을 보면 이벤트리스너를 document가 아닌 컴포넌트 요소에 할당하는 예시를 많이 볼 수 있었다.\n\n리액트의 경우 정확히는 root component 에 등록하고 있답니다.\n대신 컴포넌트가 언마운트 될 때 현재 등록된 이벤트를 해제하는? 그런 로직을 수행하고 있을꺼에요!\n\n> queueMicrotask 를 사용하는 것을 추천 받았는데, 알맞게 사용되고 있는지 궁금합니다.\n\n지금은 그냥 실행을 지연할 뿐 모아서 처리되거나 하고 있진 않은 것 같아요!\n즉, queueMicrotask의 실행이 시작될 때 이후에 실행될 함수는 실행하지 않는 방식으로 처리되어야 하지 않을까요!? 이건 솔루션을 참고해보면 좋을 것 같아요!\n\n> observable 내부 observerMap 의 메모리를 최적화 할 수 있는 더 좋은 방법이 있는지 궁긍합니다.\n\n이미지 잘 최적화 해주신 것 같아요 ㅎㅎ\n다만 어차피 map에서 제거하면 set은 자연스럽게 제거되지 않을까!? 라고 추측이 되네요.\n\n아니면 Set 대신에 WeakSet을 사용한다거나!?\nhttps://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\n\n> src/pages/products.js 를 진입점으로 홈 화면 컴포넌트들을 보았을 때 코치님이 해당 src/core/Component.js 컴포넌트를 사용해야 한다면 어떤 점을 개선하고 싶으신가요?\n\n너무 포괄적인 질문이라서요, 지훈님이 문제라고 생각하는 지점을 이야기 해주시면 제가 이에 대한 답변은 드릴 수 있을 것 같아요 ㅎㅎ\n\nhttps://github.com/JunilHwang/black-coffee-study-lv3/blob/main/step3/frontend/src/_core/Component.ts\nhttps://github.com/JunilHwang/black-coffee-study-lv3/blob/main/step3/frontend/src/pages/LinesPage.ts\n\n저는 옛날에 이런식으로 만들었답니다!\n지금은 클래스를 쓰지 않아도 충분히 잘 추상화 할 수 있다고 생각해서 아예 클래스를 쓰고 있지 않아요.\n\nComponent가 쓰이는 모습을 토대로 판단해보면 지금 지훈님께서 만들어주신 모습이 더 직관적이라고 생각해요!\n\n> 생명주기를 관리할 때 꼼꼼하게 봐야할 부분은 어떤게 있을까요?\n\n이 또한 너무 포괄적인 질문이라... 지훈님의 생각을 먼저 이야기 해주시면 좋았을 것 같아요 ㅎㅎ\n저는 \"정확하게 실행되는 것\"이 무엇보다 중요하다고 생각합니다.\nmount 는 정말 마운트를 할 때 실행이 되는가 같은..?\n어떤 생명주기를 만들 것이고 각각의 생명주기마다 어떤 일이 일어나는지 명시하는 문서 같은게 일단 있어야 한다고 생각합니다.\n\n그리고 특히 컴포넌트가 사라지게 되면 없애야할 정보를 꼼꼼하게 없애는 과정이 필요하겠죠?\n이벤트나 상태 같은 것들이요!",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/58"
    }
  },
  {
    "passed": false,
    "name": "이진희",
    "feedback": "안녕하세요 이진희님, 수고하셨습니다. 이번 과제는 프레임워크 없이 SPA를 구현하면서 React와 같은 프레임워크가 해결하는 문제들을 직접 경험해보는 것이 목표였습니다. \n\n코드를 보니 컴포넌트 분리와 구조화에 신경을 많이 쓰신 점이 인상적입니다. 특히 `renderViewComponent`를 통해 React의 컴포넌트 시스템을 구현하려 시도하신 점이 좋았습니다. DOM 조작을 추상화하고 컴포넌트 단위로 관리하려는 접근은 올바른 방향이었습니다.\n\n다만 완성도 면에서 많이 아쉽네요. 짧지 않은 기간인지라 잘 만들어 질수도 있었겠지만 저희가 요구했던 CI 테스트가 모두 실패하고 있기에 '불합격'을 드릴 수 밖에 없습니다.\n\n개발에게 있어서 80%는 되었는데 20%는 한건 사실 안한 것과 다를게 없죠. 99%를 해도 1%의 버그때문에 서비스의 평점이 낮아지는게 개발자인 만큼 좋은 코드 이전에는 마감과 딜리버리가 최우선 역량입니다.\n\n설계에 너무 많은 시간을 투자하셨다고 하셨는데, 잘하고 싶은 마음에 많은 개발자들이 겪는 문제죠. 그렇기에 더더욱 앞으로는 먼저 동작하는 최소한의 구현을 만들고, 점진적으로 개선하는 접근으로 나아갈 수 있기를 바랍니다.\n\n언제나 마감과 딜리버리가 좋은 코드보다 중요하는거 기억해주세요!\n\n---\n\nQ) renderViewComponent의 구조와 업데이트 흐름에 대해\n\n=> 현재 구조는 명시적이어서 나쁘지 않습니다. 그러나 이 프레임워크를 쓰는 사람에게 명시적으로 호출하라고 하는 건 아니겠죠? 지금 구조만으로는 내부에서 자동으로 해줄 것인지 외부 사용자에게 명시적으로 쓰게 해주게 할지 확실치 않네요. \n\n=> 선언적이다라는 것은 내가 원하는 것만 적어주면 내부에서 알아서 한다이므로 내부에서는 이를 한번에 렌더링을 유도하는게 올바른 구조라고 생각합니다. 확신히 안 들때에는 현재 어떤 구조로 되어 있는지 한번 생각해보세요\n\n=> replaceChild는 지금으로썬 괜찮다 생각합니다. 사실 DOM을 전체 교체하는 것은 상당히 비효율적이기에 많은 프레임워크들이 변해야하는 코드만 변하도록 하는게 기술인데 1주차 과제에 그것까지 해주기를 바라는건 너무 큰 욕심이겠죠? (웃음)\n\n\n수고하셨습니다. 다음 과제에서는 먼저 테스트를 통과시키는 것을 목표로 하시고, 그 다음에 리팩토링을 진행하시길 추천드립니다. 화이팅입니다! :)",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/41"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "안녕하세요 태영님! 1주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다.\n\n> 이런 부분은 과제 시작 전 참고 문서나 차라리 사전 스터디를 이런 부분을 하는 것이 더 좋을 것 같습니다.\n\n과제 챕터에 보면 SPA 지식뭉치 문서가 있고, 여기에 있는 내용만 참고해도 충분히 구현할 수 있는 게 많이 있답니다..! 다만 오히려 확인해야 하는 자료가 너무 많아서 탐색하기 힘들 수 있다는 생각이 드네요 ㅠㅠ\n\n> 제 생각은 학교나 학원처럼 지도와 배움이 있는 방식으로 생각을 했지만 그런 시스템으로 프로그램을 진행하고자 하는 의미보다는 '코치'의 의미처럼 내 자신이 진행을 하면서 코치를 받는 것으로 접근 해야 더 많은 것을 얻을 수 있겠다. 생각 했습니다.\n\n저도 이에 동의합니다 ㅎㅎ 더 정확히는, 저는 정답이 있는 교육을 지양하는 편이라서요. 경험이 제일 중요하고, 경험을 해야 나의 진짜 지식이 된다고 생각합니다.\n\n어쨌든 교육 과정이라서 최소한의 답을 제공하긴 하지만... 내가 어떤 지식을 학습할 때는 나 스스로의 경험이 무엇보다 중요하다고 생각해요!\n\n> AI가 일을 더 잘 하게 만든 방법은 만들었다기 보다 내가 어떤 코드를 작성 할 지 함수나 기타 등을 이용 할 지에 대해 이해가 있어야 AI가 더 일을 잘하게 할 수 있다 느꼈습니다.\n\n무척 좋은 인사이트네요! 내가 하고자 하는 일을 명확하게 그리고 구체적으로 설명할 수 있을 때 AI의 활용도가 높아지는 것 같아요.\n반대로, 정말 어떻게 시작해야 할지 모를 때 막막할 때도 AI에게 어느정도 제시해달라고 하면 좋답니다 ㅋㅋ\n저는 창의성을 많이 위임하고 있어요.\n\n> render.js 파일에 모든 이벤트들을 다 모아 두었는데, 이런 구조가 맞는 건지 궁금합니다.\n\n이건 선택이라고 생각해요. 관리해야할 이벤트가 많이 없을 때는 지금고 같은 구조가 좋고, 이벤트의 수가 점점 늘어날 때는 컴포넌트쪽에 위치시키는게 좋다고 생각해요.\n\n> 옵저버 패턴을 사용해 상태 관리 로직을 구현해 보았습니다. 하지만 옳은 방법인지 여부를 묻는 것 이전에 애초에 store는 어떤식으로 구조화하고 로직을 구현하는지 아주 기초적인 부분에 대한 설명 부탁 드립니다.\n\n글쎄요.. 어디까지가 기초일까요?\nstore를 상태관리라고 생각해본다면, 상태를 구조화하는 방식이 너무 다양해서요 ㅎㅎ\n다만 \"값\"과 \"값을 변경하는 함수\" 등은 꼭 필요하다고 생각해요. 여기에 더 나아가서 \"상태를 변경했을 때 어떤식으로 밖에 알릴 것인가?\"에 대한 장치가 필요하죠.\n\n이 장치를 내부에 만들어둘 수도 있고, 혹은 외부에서 주입받을 수도 있답니다.\n가령,  `store.addEventListener('change', callback)` 이런 모습일 수도 있고, 옵저버일수도 있겠죠?\n\n> render.js 파일에 initRender 함수인데 초기 렌더링과 새로고침, 상세페이지 이동 등에 따라 처리되어야 하는 상황이 달라서 이런식으로 늘어지게 코드가 작성되었는데 이런 방법이 아닌 분리시키거나 하는 방법이 있을까요?\n\n현재 작성된 방식을 \"명령형\"으로 코드를 작성했다고 이야기한답니다.\n그리고 이를 개선한다면, \"선언형\"으로 코드를 작성할 수 있겠죠?\n\n`선언형 프로그래밍` 이라는 키워드로 검색해보면 좋답니다 ㅎㅎ\n\n```\n\n// 🔴 기존 명령형: 조건을 체크하고 직접 실행\nproductStore.subscribe(() => {\n  if (renderingDisabled) return;\n  if (isCurrentlyOnDetailPage()) return;\n  \n  const state = productStore.getState();\n  if (state.newlyLoadedProducts.length > 0 && state.isFirstLoad) {\n    appendNewProducts();\n  } else {\n    render();\n  }\n});\n\n// ===============================================\n\n// 🟢 선언형: 규칙을 정의하고 시스템이 실행\nconst renderingRules = {\n  // 렌더링 조건들\n  skipWhen: [\n    () => renderingDisabled,\n    () => isCurrentlyOnDetailPage()\n  ],\n  \n  // 렌더링 액션들  \n  actions: [\n    {\n      condition: (state) => state.newlyLoadedProducts.length > 0 && state.isFirstLoad,\n      action: () => appendNewProducts()\n    },\n    {\n      condition: () => true, // 기본값\n      action: () => render()\n    }\n  ]\n};\n\nproductStore.subscribe(() => executeRules(renderingRules, productStore.getState()));\n```\n\n> 이번 과제를 통해 코치님의 생각보다 더 기대치를 낮춰서 기초 중에 기초라고 생각하는 부분들에 대해 키워드나 참고 할 수 있는 문서 등을 알려 주실 수 있을까요? 아예 코드를 AI나 그 외 도움 없이 자신이 직접 구현 하지 못 한다면요\n\n그게 발제에 있는 자료들이라서요..!\n\n자바스크립트 기초 개념: https://www.notion.so/1-3-Javascript-2262dc3ef51480299f63d27a8d3a3136?pvs=24\nSPA를 만들기 위한 지식 뭉치: https://www.notion.so/teamsparta/1-4-SPA-2262dc3ef51480949a61f934fdae9dc5\n\n혹은 \"프레임워크 없는 프론트엔드 개발\" 이라는 책을 보셔도 좋습니다 ㅎㅎ\nhttps://www.yes24.com/product/goods/96639825",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/46"
    }
  },
  {
    "passed": false,
    "name": "임규원",
    "feedback": "",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "임두현",
    "feedback": "안녕하세요 두현님!\n1주차 과제 무척 잘 진행해주셨네요 ㅎㅎ 너무 고생하셨어요!\n\n> Claude와 Cursor를 사용했습니다. AI는 세션을 적절하게 관리하는 것이 중요합니다. 그래서 진행사항 및 프로젝트의 방향성을 이야기하는 문서들을 docs 폴더에 저장했습니다. 이를 통해 세션을 높은 빈도로 비우면서도 docs의 문서들을 읽음으로써 대화의 연속성을 이어갈 수 있었습니다.\n\n저도 문서가 제일 중요하다고 생각해요! 진행에 필요한 컨텍스트를 docs로 잘 정리해주신게 무척 인상적이네요 ㅎㅎ\n\n> main.js에서 렌더링을 하는 생애주기간 데이터 및 이벤트 핸들러 구독 셋업과 클린업 처리 흐름이 정리가 안되어 그 때 그 때 돌아가게끔 되어있어서 관련하여 리뷰받고자 합니다.\n\nmain 자체에 대한 클린업은.. 사실지금 불필요하다고 생각해요.\n제가 테스트를 잘못작성해서 이런 고민을 하게 되는 것 같네요 ㅠㅠ\n\n대신 컴포넌트에 대한 클린업, 페이지에 대한 클린업은 필요하다고 생각합니다!\n\n> spa에 적합한 구조인지 이야기를 나눠보고 싶습니다.\n\n지금 구조는 충분히 SPA에 적합한 구조라고 생각해요!\n다만 이벤트 관리하는게 아마 제일 마음에 들지 않는 부분이라고 생각될 것 같은데요, 이 또한 2주차 과제를 진행하면서 어느정도는 해소되리라 생각합니다 ㅎㅎ",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/31"
    }
  },
  {
    "passed": false,
    "name": "장루빈",
    "feedback": "안녕하세요 장루빈님, 수고하셨습니다. 이번 과제는 프레임워크 없이 SPA를 구현하면서 내부 동작 원리를 이해하는 것이 목표였습니다. History API와 이벤트 처리의 어려움을 직접 경험하신 것은 좋은 학습경험이 되어주었을거라 기대합니다.\n\n개발자의 첫 번째 책임은 요구사항을 만족하는 작동하는 코드를 제시간에 전달하는 것입니다. 현재 PR을 보면 CI 테스트가 모두 실패하고 있고, 배포 링크도 없으며, 핵심 기능인 장바구니 모달과 토스트가 구현되지 않았습니다. 따라서 채점 기준에 미치지 못했기에 \"불합격\"을 드릴게요.\n\n라우터 구조가 깔끔하고 코드 분리가 잘 되어있는 것은 좋지만, 기본 기능이 작동하지 않는다면 의미가 없습니다. 실무에서는 \"완벽한 구조의 미완성 코드\"보다 \"조금 지저분하더라도 작동하는 코드\"가 우선입니다.\n\n구조와 패턴은 나중에 개선할 수 있지만, 작동하지 않는 코드는 가치가 없기에 피드백을 해드릴 수도 없어요.\n\n2주차에는 코드의 퀄리티보다도 시간내의 완성!을 제일 중요하게 생각하여 진행해주기를 기대합니다.\n\n---\n\nQ) 클래스를 사용하는 이유가 궁금합니다. 개발을 하다보면 결국 객체지향형 프로그래밍을 하게 된다는데 클래스를 사용하지 않더라도 객체 지향적으로 개발하면 되지 않나요?\n\n=> 클래스를 사용하지 않아도 객체지향적으로 개발을 할 수 있습니다. 객체란 key:value 형태의 의미있는 구조체에 상태과 상태를 변화하는 메소드를 통해서 하나의 큰 프로그램을 재사용 가능한 독립적인 모듈로 나누어 메시지의 정보 교환을 통해 프로그래밍을 한는 방법론이죠.\n\n=> 객체지향에서 중요한건 독립적인 모듈들이 메시지 교환을 통해 의미있는 요구사항을 수행한다는 점인데 이를 가능하게 하려면 서로간의 메시지 교환의 규칙이 정확해야 하고 이를 인터페이스라고 합니다. 이러한 타입과 규격 인터페이스등을 정의하는 방법으로 클래스가 필요하지요.\n\n=> js는 class가 없어도 Object를 생성할 수 있지만 타입과 상속, 데코레이션등의 표현력을 가지고 있는 것이 class라고 생각해주세요. class를 쓰는 이유는 객체지향적인 프로그래밍을 해야하는 경우에는 class가 훨씬 더 나은 표현법이니까 사용합니다.\n\n\nQ)  ai를 잘 쓰는 방법이 궁금합니다. 제가 줏대가 없는걸지도 모르겠는데 \"AI한테 알려주고 시키는 것도 실력이다.\", \"AI가 다 하면 나는 대체 가능한 사람이 되는 건데...그러면 어떤 개발자가 되야하는가\" 이런 생각이 공존하는 것 같습니다.\n제가 최근 경험을 예시로 들면 최근 프로젝트에서 shardcn이라는 component/ui를 사용하게 되면서 반복적으로 작업하는 코딩은 ai를 시켜서 작성하고 주요 로직을 구현하는 쪽으로 진행을 하려고 했는데... 그렇게 되면 다른 누군가에게 shardcn사용 경험이 있다고 말 할 수 있을까?라는 생각이 들더라고요. 이것에 대한 테오의 생각이 궁금해요\n\n=> AI가 다 할 수 있는가? 만약 AI가 다 할 수 있는 시기가 정말로 온다면 그때에는 정말로 현업에 있는 모든 개발자들이 사라지겠지요. 그렇지만 아직은 누군가는 여전히 그 AI에 다 할 수 있도록 지시를 하거나 AI가 일을 잘 할 수 있도록 만드는 역할을 해야 합니다.\n\n=> AI가 다 할 수 있는 일을 한다면 당연히 대체가 되겠지요. 물론 다행히 AI는 아직 같이 술자리도 못가고 같이 놀아줄 수는 없네요. 추억을 오랫동안 함께하지도 못합니다. 사람과의 관계라는 건 중요한 역할이지요.\n\n=> 뭐 이런 감성적인 부분이 아니더라도 AI를 활용해서 무언가의 가치를 만들어내는 사람의 가치는 부정할 수 없습니다. 앞으로는 그러한 가치를 만들 수 있는 사람이 대우를 받겠지요.\n\n=> AI에게 가치있는 무언가를 만들기 위해서는 단순히 시켜서는 되지않습니다. 가령 AI가 다 할 줄안다고 \"정말 재밌는 영화 대본을 써줘\" 라고 한들 정말 재밌는 대본이 나올 수 있을까요? AI가 만들어내는 생산성은 인간이 하는 일의 특정한 부분에 대단한 속도를 만들어내지만 속도가 곧 생산성은 아닙니다. 더 낫게 만들기 위해서는 검증하고 뭐가 더 나은 것인지 알아야 하고 목표를 만들고 해석하고 평가하고 재할당하는 원래 하던 일들을 해야만 달성할 수 있어요.\n\n=> 물론 영화를 만들지 않고도 영화평론가가 될 수는 있습니다. 그러나 대부분의 업무를 위한 지시는 경험이 있어야 더 잘 할 수 있더라구요. AI로 인해서 개발자의 업무는 변화하고 있는 중이라고 생각합니다. 다만 아직까지 본질적인 업무인 인간의 요구사항을 이해하고 컴퓨터에게 전달하여 그 가치를 실현하는 부분에 대해서는 크게 달라지지 않은 것 같아요. 내가 뭘 해야하는지 알고 AI를 통해서 생산성을 함꼐 올려보기를 바래요.\n\n\nQ) 얼마전 멘토링에서 FE는 생각보다 빨리 고점에 도달한다고 하셨는데... 이부분 동의 합니다. 제가 물론 고점을 찍을 수 있을지는 모르겠지만 FE는 조만간 AI로 대체가 될거라고 생각해요. 그러면 BE로 가야하는가? 라고하면 그건 너무 단순한 발상인 것 같습니다.\n개발자라는 직업으로 먹고 사는게 그렇게 전망이 좋아보이진 않습니다. 테오는 어떻게 생각하세요?\n\n=> 저는 이 일로 먹고 사는 사람이기에 전망을 비관적으로 보고 싶진 않습니다. 안타까운건 제가 그동안 배웠던 스킬들로만 먹고 살기는 힘들것 같네요. 마치 예전에는 IE버전마다 크롬과의 CSS가 다르게 나와서 그걸 잘하는게 능력이었는데 지금은 전혀 중요하지 않은 스킬이 되었죠. AI가 점점 더 내가 잘하지 않아도 되도록 해주는 역할을 담당하게 될 것이라는 점에서는 동의 합니다.\n\n=> 그렇다고 해도 FE가 AI로 전부 대체될수는 없습니다. 인간의 언어는 모호하고 막연하게 설계가 되어 있기 때문에 여기서 조금만 더 세련되게 만들어달라 라는 말을 100% 정확하게 해석할수가 원천적으로 할 수가 없습니다. 분명 누군가는 그 말을 더 구체적인 언어로 만들어야 해요. 우리가 0과1 로 혹은 기계어로 코딩을 하진 않지만 최소한 언어로는 작성해야하는 것처럼 한 단계 더 높은 레이어의 고급 언어를 가질 수는 있겠지만 지금의 자연어로는 절대 안됩니다.\n\n=> 개발자라는 직업의 가치는 저도 예측이 어렵네요. 그렇지만 분명 지금까지 현재 인간의 돈이 몰리고 있는 분야에 과학과 공학 그리고 IT의 쏠림 현상은 존재하기에 개발자라는 직업 자체가 유망하지 않을거라고 생각지는 않습니다. FE의 유망세는 잘 모르겠지만요.\n\n=> 모두가 1등이어야 하는 건 아니니 그래도 이 분야가 재밌고 즐겁다면 도전해보세요. 최우선은 자기가 제일 잘 할 수 있는지 자기 재능의 영역을 찾는 것이고 그걸 잘 모르겠다면 그래도 재밌는걸 해야 하지 않겠습니까? 잘 찾아가길 바랍니다.\n\nQ) 코드가 전반적으로 구조를 잘 짰다고 보기엔 어려운 것 같습니다. 하지만 제가 회사에서 사용하는 작성법과 크게 다르냐 하면 아닌 것 같습니다. 그런부분에서 봤을 때 구조를 잘 만들려면 어떤 부분을 고려해서 만들어야하는지 3가지만 알려줄 수 있을까요?\n\n=> 다음 번 과제는 구조보다 완성을 해오세요. 그러면 알려줄게요. (웃음) 너무 매정한것 같이 힌트를 드리자면 그리고 정답은 이미 쓰고 있는 React에게 답이 있어요. 10년에 걸쳐서 정답을 찾아온 과정이잖아요?\n\n\n수고하셨습니다. 화이팅입니다!",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/57"
    }
  },
  {
    "passed": true,
    "name": "장희진",
    "feedback": "안녕하세요 희진님!\n1주차 과제 잘 진행해주셨네요!! 너무 고생 많으셨습니다 ㅠㅠ\n\n> 특히 테스트 코드 수정이 여러 번 필요했고, 한 테스트가 다른 테스트에도 영향을 주는 문제가 발생해 혼란스러웠습니다. 이런 점에 대한 사전 안내나 테스트 격리 방법에 대한 가이드가 있으면 좋겠습니다.\n\n이 부분은 저도 많이 느껴서요. 혼란을 드려 죄송합니다..! 나머지 2~3주차 과제는 이런 일이 없도록 주의해볼게요..!\n\n> 현재 정규표현식을 활용한 라우팅 매칭 방식이 간단한 경로에는 적합하지만, 복잡한 동적 라우팅(예: 쿼리파라미터, 중첩 라우트 등)에도 확장 가능할지 궁금합니다.\n\n그럼요 ㅎㅎ 충분히 가능하답니다! 사실 지금 코드를 그대로 사용한다면 어렵겠죠..? 코드는 수정해야할 것 같아요.\n특히 중첩 라우터의 경우 지금과 같은 구조를 그대로 사용하긴 어렵고, 라우터가 다시 라우터를 만드는? 그런 과정이 필요해요.\n라우터 하위에 서브 라우터 같은게 있는거죠 ㅎㅎ\n\n쿼리 파라미터는 쉽게 다룰 수 있을 것 같아요! 이건 지금 라우터랑은 딱히 관련 없고.. 그냥 쿼리 파라미터에 대한 관리 시스템을 추가해주면 된답니다.\n\n> window.onpopstate 이벤트 핸들러로 라우트 재실행을 구현했는데, 향후 복잡한 상태 관리가 필요할 때 더 좋은 설계 방안이나 패턴이 있을지 알고 싶습니다.\n\n\"향후 복잡한 상태관리\"의 상황을 먼저 가정해보면 좋겠죠?\n지금은 뒤로가기/앞으로가기 그리고 직접적으로 실행하기 등에 대한 대응이 되어있는데요,\n이 외에 또 무엇이 있을지 고민해보시면 좋겠어요 ㅎㅎ\n\n> 전반적으로 이 라우터 구조가 규모가 커졌을 때 유지보수나 기능 확장에 유리한지, 아니면 리팩토링이 필요할지 조언을 받고 싶습니다\n\n위에 언급한 내용들을 종합해보시면 좋겠어요.\n이럴 때 희진님께선 \"확장에 유리한 이유\" 등을 다루는게 중요해요. 이를 기반으로 이야기를 전개해야 저희가 더 디테일한 소통이 가능하답니다.\n\n일단 유지보수 상황을 먼저 가정해주세요.\n어떤 상황에 대응을 할 수 있을지 랄까..\n엣지케이스를 정의해보는거죠.\n이 과정 없이 \"대응 가능해?\" 라고 하는건 이야기 하기에 어렵다고 생각해요.",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/68"
    }
  },
  {
    "passed": false,
    "name": "정건휘",
    "feedback": "안녕하세요 정건휘님, 수고하셨습니다. 이번 과제는 프레임워크 없이 순수 JavaScript로 SPA를 구현하며, 상태 관리와 라우팅의 본질을 이해하는 것이 목표였습니다. 바닐라 JS 개발이 익숙하지 않으셨다고 하셨는데, 이런 경험을 통해 프레임워크가 해결하는 문제들을 더 깊이 이해하셨기를 바랍니다.\n\n코드를 살펴보니 특히 라우터 구현(`src/routes/router.js`)이 인상적이네요. 전반적인 구조나 설계 측면에서 상당히 모던하게 잘 구현이 된것 같아 좋습니다. `popstate` 이벤트 처리와 `navigate` 메서드 구현이 체계적이고, production 환경을 고려한 BASE_PATH 처리도 잘 되어있네요. 서비스 레이어를 분리한 아키텍처도 좋은 접근입니다.\n\n코드 전반적으로 폴더 구조나 코드의 폴더구조면에서 실제 역할과 계층구조가 잘 못지켜지고 있어요. utils인데 events-handlers에서 주요 비즈니스 로직을 처리한다거나 라우터가 DOM을 조작하고 있다거나 등등이요.\n\nAI를 이용해서 검증을 할때 이러한 역할과 구조적인 측면으로 많이 물어보고 작성을 해보시기를 권해드립니다\n\n또한 DOM을 직접 건들지 않고 모델과 렌더링을 분리해달라는 조건을 넣어가면서 AI에게 어떻게 하는지를 배워가며 익혀가 보면 더 좋을 것같네요.\n\n---\n\nQ) userEvent.click과 element.click()의 차이는?\n\n=> `userEvent.click()`은 테스트 도구에서 실제 사용자의 클릭을 더 정확히 시뮬레이션합니다. 마우스 이벤트(mousedown, mouseup, click) 순서대로 발생시키고, 포커스 이동, disabled 상태 체크 등을 처리합니다. 반면 `element.click()`은 단순히 click 이벤트를 호출시키는 것이죠. 다른 이유들로 하여금 click이 발생되지 않더라도 강제로 함수 호출을 시킨거라고 생각해주세요.\n\n이번 테스트에는 실제클릭이 동작하지 않을 이유가 없기에 함수호출이나 실제 클릭이나 다를게 없기 때문입니다. 하지만 실제 사용자 인터랙션을 정확히 테스트하려면 `userEvent`를 사용하는 것이 좋습니다.\n\n수고하셨습니다. 2주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/65"
    }
  },
  {
    "passed": true,
    "name": "정도은",
    "feedback": "안녕하세요 정도은님, 수고하셨습니다. 이번 과제는 프레임워크 없이 순수 JavaScript로 SPA를 구현하면서 React가 해결하는 문제들을 직접 경험해보는 의도를 가진 과제였어요. 회고에서 언급하신 것처럼 \"React가 왜 필요한지\" 명확히 체감하셨기를 바랍니다.\n\n특히 Toast 컴포넌트를 클로저로 구현하신 점이 인상적이네요. 전역 상태를 클로저로 캡슐화하여 깔끔한 API(`Toast.success()`)를 제공한 것은 훌륭한 선택입니다. CartStorage의 이벤트 시스템과 카운터 관리도 잘 구현하셨어요.\n\n다만 `productLoader.js`에서 전역 변수(`currentPage`, `isLoading`, `hasMore`)로 무한 스크롤 상태를 관리하는 부분은 개선이 필요해 보입니다. 여러 페이지에서 상품 목록을 사용한다면 상태가 꼬일 수 있으니, 클로저나 클래스로 인스턴스화하여 각 페이지가 독립적인 상태를 가지도록 하는 것이 좋겠네요.\n\n다음은 구체적인 리뷰입니다.\n\n---\n\nQ) 클래스 vs 클로저 선택 기준\n\n=> 자바스크립트는 함수형 패러다임과 객체 지향 패러다임을 둘 다 쓸 수 있기에 두 가지의 장점이 있는 멋진 언어죠.\n\n=> 단일 인스턴스면 클로저(Toast, Modal), 여러 인스턴스가 필요하면 클래스가 적합합니다. 클로저는 private 변수를 자연스럽게 만들 수 있고, 클래스는 상속과 확장이 용이합니다.\n\n=> 자바스크립트가 아무래도 class를 표현하기에 복잡한 문법 체계를 가지고 있는 만큼 상속과 확장이 필요한 다양한 객체 타입을 가져야 하는 경우 ex) Node -> Element -> HTMLElement -> HTMLDiveElement 과 같이 상속과 타입의 확장이 유리한 구조에서는 class가 훨씬 더 좋은 선택입니다.\n\n=> 그밖의 단순한 동작과 모듈등 간결함을 추구하는 코드라면 클로저 방식의 코드가 대개의 경우 더 좋습니다.\n\n=> 그렇지만 너무 이렇게만 알면 안되겠죠? 각 방식의 차이를 실제로 이해하고 적절한 본인만의 판단기준을 찾아가길 바랍니다 :)\n\n\nQ) 상태를 함수 내부에서 유지하는 방법\n\n=> 이미 알고 있는대로 클로저를 활용하여 상태를 만들고 상태와 그것을 조작하는 함수를 함께 반환하는 팩토리 패턴을 사용하면 됩니다:\n\n```js\nfunction createProductList() {\n  let state = { page: 1, loading: false };\n  return {\n    load: () => { /* state 사용 */ },\n    getState: () => ({ ...state })\n  };\n}\n```\n\n다만 이런방식은 값을 변화 했을때 이벤트를 전달하기가 어려우므로 각 함수마다 마지막에는 render() 혹은 noify()등을 호출해야 하는 단점이 있죠. \n\n그러다보니 값이 변할때마가 이벤트를 전달하는 signal과 같은 것들이 현재 표준 객체로 만들려는 시도가 있습니다. 관련해서 찾아보시면 좋겠어요.\n\n수고하셨습니다. 2주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/12"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "정민기",
    "feedback": "안녕하세요 정민기님, 수고하셨습니다. 이번 과제는 프레임워크 없이 순수 JavaScript로 SPA를 구현하면서 상태 관리, 라우팅, 컴포넌트 시스템의 핵심 개념을 직접 경험해보는 것이 목표였습니다. \n\n코드를 보니 컴포넌트 분리와 라우터 구현을 시도해보려고 한건 보이지만 현재의 코드만 가지고는 채점도 피드백도 드리기가 어렵네요.\n\n비록 이번에는 통과하지 못했지만, 바닐라 JS로 SPA를 만들어보신 경험 자체가 큰 자산이 될 것입니다. 2주차도 화이팅입니다! 😊\n\n---\n\nQ) state와 handler를 어떤식으로 나눠서 관리를 해야할지\n\n=> 우선 state를 변경하는 함수를 만들고 그 함수에서 값이 변경이 되면 화면을 업데이트를 하는 가장 단순한 경로를 만들어 봅시다. 그리고 모든 상태 변경시 화면을 업데이트하는 로직을 만들고 값을 변경시켜보는 로직까지 먼저 만들어봐요.\n\n위 멘트를 기준으로 AI와 함께 조금 놀아보시면 무슨 말인지 감을 잡아가기를 바래요.\n\n\nQ) 컴포넌트 단위를 어떤식으로 잘게 쪼개서 관리를 해야할지\n\n=> 컴포넌트는 상태 -> 화면 -> 이벤트 -> 상태 변화 -> 화면 변화 라는 사이클을 돌게 되어 있는데 우선 필요한 화면을 먼저 만들고 화면에서 변해야 하는 데이터를 상태로 분리하고 사용자가 할 수 있는 행동을 이벤트로 만드는 순서대로  진행해보면 됩니다.\n\n우선은 화면을 기준으로 먼저 생각하고 나중에는 상태(데이터)를 기준으로 생각할 수 있도록 발전할 수 있습니다.\n\n과제와 질문이 너무 피상적이어서 답변을 이정도 밖에 못하겠네요. 다음 번 과제는 훨씬 더 구체적인 상황에 대한 질문이길 기대할게요. 수고하셨습니다.",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/33"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "정유열",
    "feedback": "유열님 과제 퀄리티가 엄청 높네요 ㅎㅎ 고생하셨습니다.\n과제의 목표를 명확하게 하고 잘 접근해주신 것 같아요.\n함께 했으면 하는 여러 고민들을 매우 잘 진행해주신 것 같습니다\nAI에 대한 활용도 이상적으로 잘 하신 것 같아 따로 이야기 할 게 없네요 ㅎㅎ \n\n> 페이지 모듈과 컴포넌트 모듈의 역할 분리를 했으나 만족스러운 구조가 나오지 못한것 같습니다. 어떻게 하면 더 나은 구조를 만들 수 있었을까요?\n\n여기서 이제 디자인 패턴이 필요해지는 시점이 아닐까 싶네요!\n실제로 바닐라 자바스크립트만으로 과거에 구현을 진행했었을 시기에는 여러 패턴들을 사용해서 함수를 추상화 하고 제어를 했거든요.\n이벤트에 대해서는 이벤트 버스를 구현해두고 제어를 하기도 했고, 모듈패턴 이나 프로토타입을 사용해 각각의 동작하게 하기도하구요. 요즘은 class 컴포넌트를 명확하게 사용할 수도 있죠.\n공통적으로 수행해야 하는 여러 작업들을 리액트 프레임워크에서 컴포넌트가 해당 작업들을 수행하는 것처럼 작업을 숨기는 것도 좋은 방법일 것 같아요!\n\n> 외부 상태관리 스토어로써 적절한 기능을 하도록 잘 구성하였는지 궁금합니다.\n\n넵 적절하게 구현해주신것 같아요! 쉽게 잘 정리해주신 것 같아요. \n이미 아시겠지만, 바닐라를 통한 다양한 구현 방법이 있는 만큼 여러 방법으로도 구현을 해보시는 것도 재밌을 것 같네요 ㅎㅎ\n\n> 비즈니스로직과 렌더링 로직이 강결합되어 의도한 만큼 깔끔한 코드를 작성하지는 못했는데 어떻게하면 더 좋은 코드를 작성할 수 있었을까요?\n\n말씀해주신대로 지금 컴포넌트는 꽤 많은 작업을 한곳에서 진행중인것 같아요. 일단은 컴포넌트의 단위 단위를 조금 더 작게 잡고 구현을 하는게 필요해 보이구요. 조금 유행이 지났을지 몰라도 MVC와 유사하게 뷰의 영역과 모델의 영역을 제어하도록 분리를 하는 것도 방법일 것 같구요. \n1번 질문과 유사한 답변이겠지만, 컴포넌트 패턴 그리고 사용하는 라이브러리의 패턴을 따라 구현해보고 각각의 동작을 구분하는게 제일 좋은 해결 방법이자 공부가 되지 않을까 싶네요 ㅎㅎ\n\n> 토스트(@/components/toast/index.ts)와 모달(@/components/modal/index.ts) 위치에 대한 고민\n\n이 부분에 있어서 사실 유저 사용성이 가장 중요한 고민이 되는 것 같지만,  공통된 위치를 만드는게 좋을 것 같아요. (크게 중요하진 않은 것 같아서) 공통으로 포털의 위치를 잡고 해당 토스트와 모달에 대한 상태들은 별도 provider 처럼 상태를 다르게 줘 관리하는게 이상적일 것 같아요! 하지만, 별도로 위치가 달라져야 하는 사용성이라면 위치를 주입받을 수 있는 형태의 공통 컴포넌트로 관리하는게 좋지 않을까 싶네요!\n\n고생하셨고 다음 주도 화이팅입니다~~",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/28"
    }
  },
  {
    "passed": false,
    "name": "조영민",
    "feedback": "안녕하세요 영민님!\n1주차 과제 잘 진힝해주셨군요! 고생하셨습니다 ㅎㅎ\n다만 과제를 아직 다 마무리하질 못했군요 ㅠㅠ \n2주차는 잘 마무리할 수 있기를 바랍니다!!\n\n---\n\n현재 특별한 질문이 없는 상태군요..!\n\n> 초기 설계해놓은 코드에 문제가 있으면 기능 구현 중에 코드를 엎어버려서 시간이 오래걸리는데 일단 기능 구현부터 끝내야할지 이게 맞는지 항상 고민임\n\n저는 기능 구현부터 끝내야 한다고 생각해요.\n저희가 실무에서 만들어가는 제품도 어쨌든 \"완성된 상태\"가 중요하고,\n완성된 상태를 유지하면서 리팩토링을 하는게 안전한 방법이라고 생각합니다.",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/45"
    }
  },
  {
    "passed": true,
    "name": "주산들",
    "feedback": "산들님 수고하셨습니다!\n\n* 지금 폴더 구조에 대한 체계적인 개선을 하지 못하고 개발을 진행했었는데, 여기서 개선된다면 어떤 구조로 정리 해보기를 추천하시나요?\n\n저는 간단한 웹사이트를  구성할때 초기 디렉토리는\ncomponents, pages, utils, store 이정도만 구성해두고 필요하면  분기해나가는 편입니다. \n저라묜 지금 구조에서 entity라는 그룹핑은 필요 없었을 것같아요~\n\n\n* cart modal 이나 toast 같은 부분은 전역적으로 관리를 하고 싶었는데 그러려면 여기서 어떻게 작업해 보는 게 좋을까요? 어떤 파일에 넣으면서 시작해야 하나요?\n\n정말 다양한 방법이 있을 수 있을 것 같은데요.\ntoast를 예들들면 toast provider라는 컴포넌트를 루트래밸에 먼저 렌더링해둘 것 같아요. 이럴려면 render.js에서 뭔가 처리가 필요하겠죵?\n그리고 toast provider는 store의 toast등의 적절한 상태를 구독해두고 거기에 상태가 들어오면 해당 상태로 토스트를 띄우도록 처리할 것 같습니다~\n\n* 장바구니 modal을 구현할 때 일부만 리렌더링을 시킬 수 없을 것 같아(비효율적이고 성능에 좋지 못할 것 같아서) 일단은 요소의 content를 변경하는 형태로 작업을 하여 UI를 갱신하였는데, 지금의 구조에서 화면의 일부만 랜더링이 될 수 있도록 하는 최적화 로직을 추가할 수 있을까요?\n\nCartModal을 말씀하시는 것이라면 지금 구조에서는 렌더링 최적화는 굉장히 제한적일 것 같아요~ 향후 버츄어돔울 구현하는 과제를 통해 해결해보시는게 좋을 것 같습니다!\n그것이 아니라면 렌더링을 html단위가 아니라 dom api를 활용해서 렌더링해서 기존의 엘리먼트들을 업데이트해야할 것 같습니다!",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/14"
    }
  },
  {
    "passed": true,
    "name": "차현빈",
    "feedback": "ㅋㅋㅋ 매니저님 피드백은 PR에 남겨놓을게요~\nPR을 확인해주세요!\n\n1주차 너무 고생 많으셨습니다!! 부디 주말엔 푹 쉬셨길...",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/75"
    }
  },
  {
    "passed": true,
    "name": "최용훈",
    "feedback": "안녕하세요 최용훈님, 과제 수고하셨습니다. 이번 과제는 프레임워크 없이 순수 JavaScript로 복잡한 SPA를 구현하면서, 현대 프레임워크들이 해결하는 문제들을 직접 경험해보는 것이 목표였습니다. \n\n각 파일들이 너무 커지지 않도록 역할별로 책임을 나누고 폴더와 파일을 분리를 열심히 나눠준 부분은 참 잘했습니다. 하나의 파일이 너무 커지고 책임이 많아진다면 관리를 하기 어려울테니까요.\n\n현재 코드에서는 안 써도 될 코드들 가령 render()와 같은 부분들을 자동화 할 수 있도로 코드의 책임을 안쪽으로 위임할 부분과 꼭 적어야하만 하는 상태, 템플릿, 이벤트 등을 분리하는 작업과 현재 역할과 계층으로 분리해둔 것과는 별개로 Product, Main등 Route별로, 화면별로, 데이터 별로도 모아서 관리할 수 있도록 구조를 만들어보는 것까지도 목표로 남은 주차들 잘 진행해보시기 바랍니다.\n\n---\n\nQ) 간만에 바닐라로 코드를 작성하다 보니, 디렉토리 구성과 함수 분리에 시간 투자를 하지 못했습니다.\n\n전반적으로 시간에 쫓기면서 기능 구현을 하다보니, 스스로의 코드를 찾아서 수정하는 것 조차 버겁다는 느낌이 들었습니다.. 앞으로 초기 프로젝트 설계 관점에서 기본적으로 확립할 방향과 리팩토링 진행 시, 최소한의 방향성에 대하여 피드백 부탁드립니다...!\n\n=> 우리가 만들고자 하는 과정에 이미 정답지가 있답니다 바로 React죠! 스스로 생각을 해보다가 막히게 되면 한번 그냥 interface나 모양, 구조들을 그냥 한번 따라가보세요. 왜 이렇게 만들었을까? 하면서 그 배경을 따라가다 보면 얻을 수 있는게 많을 거에요. 그간 10년간의 FE들의 시행착오의 집약체이니까요.\n\n=> 하지만 또 VDOM, 이벤트 델리케이트, hook은 상당히 추상화 기능이 깊은게 있다보니 짧은 시간 SPA를 만들어 보기에 이걸 다 만들어내기는 부담스러울수도 있죠. 그럴때는 Vue등에서 사용되는 Signal을 참고해보는 것도 좋겠습니다. React가 아닌 프레임워크는 전부 Signal을 기반으로 하고 있으니까요.\n\n=> 나머지 Router나 기타 형태들은 npm에서 가장 많이 쓰이는 라이브러리에서 특히나 사용자에게 제공하는 interface를 유지하면서 이걸 어떻게 만들 수 있을까? 이렇게 한번 생각해보시면 좋겠습니다.\n\n\nQ) 이벤트 분리와 등록/해제 시점에 대해 피드백 부탁드립니다. 렌더 함수가 돌때마다 렌더 함수의 시작, 끝에 해제/등록을 진행헀지만, 핸들러 함수가 많아질 수록, 혼란스러움이 커지는 것 같습니다...\n\n=> 이렇게 열고 닫고 하는 식의 것들이 참 많죠. 이런한 경우에는 cleanup 함수로 반환하는 방식을 자주 사용하곤 합니다. useEffect를 한번 떠올려 보세요.\n\nfunction useEventListener(target, fn, options) {\n   target.addEventListener(fn, options)\n   return () => target.removeEventListenr(fn, options)\n}\n\n와 같이 만들어 둔다면 기존에 있던 내용이 뭐든지 상관없이 다음과 같이 사용할 수 있습니다.\n\nconst cleanup = useEventListener(window, \"click\", () => {})\n\ncleanup() // 을 호출하면 해제 가능.\n\n\n그렇다면 이게 \n\nconst cleanups = [\n  useEventListener(window, \"click\", ...) \n  useEventListener(window, \"click\", ...) \n  useEventListener(window, \"click\", ...) \n  useEventListener(window, \"click\", ...) \n]\n\ncleanups.forEach(fn => fn()) 이런 방식이거나 심지어 이것 또한 등록하고 해제하는 것을 cleanup 방식으로 만들 수 있겠죠.\n\n위와 같이 해야할 동작을 미리 기술하고 함수로 리턴하여 lazy하게 사용할 수 있도록 만드는 방법들은 js를 잘 쓰는 자주 쓰이는 기법중에 하나니 잘 응용할 수 있으면 좋겠네요. \n\n좋은 경험이 되었기를 바랍니다. 2주차도 화이팅입니다. 수고하셨습니다.",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/24"
    }
  },
  {
    "passed": true,
    "name": "최재환",
    "feedback": "안녕하세요 재환님!\n1주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다.\n\n> Router 클래스의 동적 라우팅\n\n동적 라우팅 구현이 쉽지 않았을텐데 잘 해주셨군요 ㅋㅋ 다만 for/if가에 대한 중첩이 많이 있어서 별도의 함수로 조금 더 추상화하면 좋았을 것 같아요!\n\n```js\ngetParams() {\n  const path = this.getCurrentPath();\n  const params = {};\n\n  for (const routePath in this.routes) {\n    if (routePath.includes(':')) {\n      const routeParts = routePath.split('/');\n      const pathParts = path.split('/');\n      \n      if (routeParts.length !== pathParts.length) {\n        continue;\n      }\n\n      const { isMatch, current } = getParam(...);\n\n      if (isMatch) {\n        return { path: current.routePath, params: current.params };\n      }\n    }\n  }\n  return { path, params };\n}\n```\n이런느낌!?\n\n> 이벤트 핸들러가 단일 함수에 모든 이벤트 처리 로직이 집중되어 가독성과 유지보수성이 떨어집니다.\n\n이에 대한 부분은 이벤트 핸들러를 직접적으로 사용하는게 아니라, 함수를 통해 간접적으로 호출할 수 있도록 해주면 좋답니다 ㅎㅎ\n\n```jsx\naddEvent('click', '.add-to-cart-btn', callback)\n```\n\n이렇게 사용하는 모습을 상상해보시면 좋아요!\n\n> E2E 및 단위 테스트의 명세와 요구사항 간의 간극이 아쉬웠습니다. 요구사항을 토대로 개발한 후 테스트의 명세를 맞추는 것이 쉽지 않았습니다.\n\n이런 어려움이 있었군요 ㅠㅠ 2주차 ~ 3주차 과제에서는 같은 어려움을 겪지 않도록 신경쓰도록 하겠습니다..!\n\n> main.js 파일 분리 계획 피드백\n\n개인적으로 A방안은 응집도가 떨어지는 방식이라고 생각해요 ㅎㅎ\n비슷한 관심사를 다루는 것들끼리 묶어놔야 응집도가 좋아지고 유지보수 할 때 편하다고 생각합니다.\n\n다만 AppController나 ProductController 를 사용하는 방식도 A에 비해선 좋지만 응집도가 높다고 생각하진 않아요.\n\n이벤트 연결을 해주는 구간과 이벤트에 필요한 함수를 정의 해주는 구간을 분리하고\n\n이벤트에 필요한 함수와 컴포넌트 코드와의 거리를 가깝게 유지하면 어느정도 해소되지 않을까 싶네요!\n\n> 문자열 기반 컴포넌트 렌더링의 개선 방안\n\nA와 B 모두 각각의 장단점이 있다고 생각합니다 ㅎㅎ\n개인적으로 B 방식을 더 선호하는데요,\n저는 \"선언형 프로그래밍\"을 해야 코드의 가독성이 좋아지고 유지보수 할 때 더 효과적이라고 생각합니다.\n\n이에 더 가까운게 B 방식인데, 만약에 A 방식처럼 하면서도 선언형 프로그래밍을 유지할 수 있는게 있다면... 그 방식을 택할 것 같아요. 다만 아직까진 못찾았어요 ㅋㅋ\n",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/42"
    }
  },
  {
    "passed": false,
    "name": "한아름",
    "feedback": "한아름님 수고하셨습니다.\n\n* 이번 과제를 통해 전역 상태에 대해 많은 고민을 했는데, 그중 제일 고민한 부분은 장바구니 상태입니다. 장바구니의 초기 상태는 화면의 맨 처음부터 받아오고, 모든 페이지가 인자로 받아야 하는 값이라 생각되어 funciton main() 부분의 맨 상단에 작성했는데, 장바구니 상품 수가 바뀐 후 url이 바뀌면 장바구니의 상품 수가 다시 초기 상태로 돌아가는 오류가 발생했습니다. 장바구니처럼 모든 페이지에서 관리할 수 있는 상태는 어떤 방식으로 구현해야 하는지 알고 싶습니다!\n\n제가 질문을 제대로 이해하지 못하는 것 같은데요!\n과제를 보면 장바구니의 상태는 전역적으로 관리되면 좋은 것 같습니다.\n그래서 스토어를 별도로 두고 렌더링과 상관없이 장바구니 상태가 데이터로 유지될 수 있게 구현하고\n장바구니에 관심있는 UI들은 스토어의 상태를 참조하는 형태로 구현하면 될 것 같습니다!(장바구니 목록과 장바구니 아이콘 갯수등)\n\n* 전체적인 관리 구조를 어떻게 짜야 하는지 의문점이 많이 생기는 과제였다고 생각합니다. 이번 과제처럼 여러 기능이 있는 페이지를 순수 자바스크립트만으로 구현할 때 이상적인 폴더 구조, 파일 구조가 어떻게 되는지 대략적으로라도 알고 싶습니다!\n\n파일구조는 크게 중요하지 않을 것 같은데요!\n\n저는 간단한 웹사이트를  구성할때 초기 디렉토리는\ncomponents, pages, utils, store 이정도만 구성해두고 필요하면  분기해나가는 편입니다. \n\n이상적인 폴더구조는 사실 없는 것 같아요 ㅎㅎ 그때그때마다 달라서요.\n\n요즘은 FSD라는 방법론이 많이 논의되고 있어요.\nFSD자체가 뭐 끝판왕은 아니지만 FSD가 어떤 고민이 있었고 그 고민과 문제를 어떻게해결했는지를 이해하는 것은 큰 도움이 될 것 같습니다~",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/67"
    }
  },
  {
    "passed": true,
    "name": "허정석",
    "feedback": "안녕하세요 정석님!\n\nhttps://velog.io/@jungseokheo/hanghaeplus1stweek\n회고도 너무 잘 봤어요 ㅎㅎ\nPR에도 정석님의 문제해결 과정이 잘 드러나서 재밌게 잘 읽었어요!\n\n> 과제가 상세하게 테스트 코드가 있어서 좋았으나, 해당 페이지가 랜더링 됐을 때의 스냅샷을 비교 하는거여서 숨은 그림 찾기 같은 느낌이 강했다. 그리고 테스트 코드를 처음 접해봐서 감을 잡는데 시간이 오래 걸렸다. 발제 시간에 테스트 설명을 좀 더 진행했으면 좋겠다.\n\n참고해서 잘 개선해보겠습니다!!! 좋은 의견 감사드려요!\n\n> 이벤트 핸들링에 대해서 고민을 하지 않았었는데, 이번 과제를 통해 핸들링에 대해 관심이 생겼습니다. 개발하면서 거의 처음으로 핸들링을 구현 했어서 보완할 부분을 듣고싶습니다. 또 코치님이라면 어떤 기준과 방식으로 이벤트 핸들링을 했을지 궁금합니다.\n\n지금 보니까 document 이벤트를 등록하고 이벤트 핸들러 내부에 내용이 다 들어있네요!\n\n여기서 \"정의하는 부분\"과 \"실행하는 부분\"으로 코드를 나누어서 관리해주면 좋답니다 ㅎㅎ\n\n가령,\n\naddEvent('change', '.selector', callback)\n\naddEvent라는 함수가 정의하는 과정이 추상화되어있고, 실행 코드를 callback 을 주입하는거죠.\n\n이건 솔루션 코드를 참고해주시면 될 것 같아요!\n\n고생하셨습니다 정석님~!\n\n---\n\n구현한 내용과는 별개로, 현재 테스트가 통과하고 있지 못해서... 아쉽지만 불통으로 남겨놓겠습니다 ㅠㅠ",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/19"
    }
  },
  {
    "passed": true,
    "name": "현지수",
    "feedback": "지수님 고생하셨어요~\n상태관리 설계에 있어서 특히 잘 고민해주신 것 같은데요.\n과제에서 기대했던 여러가지 학습 부분을 잘 고민해주셨던 것 같아서 좋네요.\n\n질문 주신거 답변을 드려볼게요.\n\n> 현재 Redux 패턴을 모방해서 Store-Reducer-Action 구조로 상태관리를 구현했습니다. 이런 방식으로 구현한 것이 바닐라 JavaScript 환경에서 적절한 선택이었는지 궁금합니다. 특히 매번 전체 렌더링이 발생하는 부분이 성능상 문제가 될 것 같아 고민입니다.\n\n맞아요! 지금의 단계에서는 사실 브라우저 성능으로 충분할 것 같지만,, 결국 상태를 바라보는 해당 지점에 대해서만 명확하게 DOM이 업데이트 되는 로직이 필요하게 될 것 같아요. 이런 로직들을 실수 없이 빠르게 제어하기 위해 리액트에서는 명확한 구조가 있는데요! 어떤 구조가 있는지 찾아보고 한번 적용해보는 것도 큰 공부가 될 것 같아요. \n\n> 현재 렌더링 시마다 이벤트 리스너를 재등록하는 구조로 되어 있습니다. 이 방식이 메모리 누수를 유발할 수 있다고 생각되는데, 바닐라 JavaScript 환경에서는 어떤 식으로 이벤트 생명주기를 관리하는 것이 좋을까요?\n\n넵 좋은 고민이네요! 위임패턴을 통해 구현을 하고 있지만, 아직 좀 처리가 필요한게 필요한것 같아요 ㅎㅎ 클로저로 참조를 물고 있으면 해제가 되지 않는 문제가 발생할 수 있고, 중복 이벤트가 등록되거나 할 수 있는 구조인것 같아요. 별도의 이벤트 생명주기를 관리하는 것들 보다는 WeakRef 같은것들을 활용해서 더 이상 쓸모가 없어지면 명시적이게 참조를 정리한다! 라고 생각하고 바라봐도 충분할 것 같아요.\n\n> JavaScript로 SPA를 구현할 때 실무에서 자주 사용하는 패턴이나 베스트 프랙티스가 있는지 궁금합니다!\n\n지금의 방식과 대부분 유사한 것 같아요! 관통하는 공통 컴포넌트로 로직을 모으고 렌더링 로직과 라이프사이클 등을 관리하는 거죠. 어떻게 보면 베스트 프랙티스가 리액트와 뷰가 될 수 있지 않을까요? ㅎㅎ \n\n내가 알고 있는 지식의 범위를 넘어서는 추상화나 최적화가 필요할 때는 AI한테 물어보는 것도 방법일 수 있겠지만, 제 개인적으로는 결국 비슷한 문제를 풀고있는 다른 라이브러리를 벤치마킹 하는게 가장 쉬운 방법인것 같아요. \n라이브러리 구현체들을 보면 내가 해야 하는 고민들이 미리 다 이뤄져 있다보니 (그것도 훨씬 더 복잡한 수준으로) 이런 추상화, 구현이 필요하겠구나 쉽게 알아차릴수 있는거죠. 실제 구현도 확인할 수 있고요.\n지금 과제에 있어서는 상태 관리에 있어서는 가벼운 반응형 상태 라이브러리를 참고하거나 (jotai나 zustand가 될 수 있고, 구현을 가볍게 한 바닐라 자바스크립트도 있죠!) 라우터에 대해서는 말해주신 react-router-dom나 tanstack router를 참고해 구현하기도 하구요. \n\n각각의 주제들이 명확하게 나눠지면 Pubsub 패턴이라던지, 이벤트 버스 패턴이라던지 모듈 패턴이라던지 구현에 대한 패턴을 고민하게 될 수 있지 않을까 싶어요~~\n\n> 현재 코드가 많이 꼬여있고 리팩토링을 진행하고 싶은데, 어떤 순서로 진행하는게 좋을까요?\n\n이 과제 뿐만 아니라 앞으로 개발을 진행해가는 방향에도 동일한 것 같은데요!\n우선은 리팩토링이라는 것의 핵심 전제로써는 작은 범위의 수정 -> 명확한 검증이 반복되어야 하죠! 전면적인 재설계 보다는 지금 현재의 구조에서 맘에 들지 않는 부분에 대해서 개선 방향을 명확하게 잡고 점진적으로 개선해나가는게 실무 관점이든 내 개발 연습 관점이든 좋지 않을까 싶어요! \n\n고생하셨고 다음 주도 화이팅입니다!",
    "assignment": {
      "name": "STEP02 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/51"
    }
  },
  {
    "passed": true,
    "name": "강병준",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/46"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "권지호",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/21"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/16"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/14"
    }
  },
  {
    "passed": true,
    "name": "김소희",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/42"
    }
  },
  {
    "passed": true,
    "name": "김수민",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/56"
    }
  },
  {
    "passed": true,
    "name": "김수현",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/22"
    }
  },
  {
    "passed": true,
    "name": "김연수",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/48"
    }
  },
  {
    "passed": true,
    "name": "김유현",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/26"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/61"
    }
  },
  {
    "passed": true,
    "name": "김효진",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/23"
    }
  },
  {
    "passed": true,
    "name": "김휘린",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/4"
    }
  },
  {
    "passed": true,
    "name": "박상수",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/50"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/36"
    }
  },
  {
    "passed": true,
    "name": "박의근",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/57"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박준형",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/9"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박창준",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/20"
    }
  },
  {
    "passed": true,
    "name": "신홍준",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/2"
    }
  },
  {
    "passed": true,
    "name": "신희원",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/37"
    }
  },
  {
    "passed": true,
    "name": "양성진",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/28"
    }
  },
  {
    "passed": true,
    "name": "양창훈",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/5"
    }
  },
  {
    "passed": true,
    "name": "여진석",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/17"
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/44"
    }
  },
  {
    "passed": true,
    "name": "오하늘",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/60"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/40"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "윤영서",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/7"
    }
  },
  {
    "passed": true,
    "name": "이가은",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/25"
    }
  },
  {
    "passed": true,
    "name": "이민재",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/3"
    }
  },
  {
    "passed": true,
    "name": "이유진",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/35"
    }
  },
  {
    "passed": true,
    "name": "이은지",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/19"
    }
  },
  {
    "passed": true,
    "name": "이의찬",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/27"
    }
  },
  {
    "passed": true,
    "name": "이정우",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/58"
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/55"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/18"
    }
  },
  {
    "passed": true,
    "name": "이진희",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/64"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/11"
    }
  },
  {
    "passed": true,
    "name": "임규원",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/41"
    }
  },
  {
    "passed": true,
    "name": "임두현",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/30"
    }
  },
  {
    "passed": true,
    "name": "장루빈",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/59"
    }
  },
  {
    "passed": true,
    "name": "장희진",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/24"
    }
  },
  {
    "passed": true,
    "name": "정건휘",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/52"
    }
  },
  {
    "passed": true,
    "name": "정도은",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/43"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "정민기",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/13"
    }
  },
  {
    "passed": true,
    "name": "정유열",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/6"
    }
  },
  {
    "passed": true,
    "name": "조영민",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/53"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "주산들",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/38"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "최용훈",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/29"
    }
  },
  {
    "passed": true,
    "name": "최재환",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/54"
    }
  },
  {
    "passed": true,
    "name": "한아름",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/49"
    }
  },
  {
    "passed": true,
    "name": "허정석",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/31"
    }
  },
  {
    "passed": true,
    "name": "현지수",
    "feedback": "",
    "assignment": {
      "name": "STEP03 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/47"
    }
  },
  {
    "passed": true,
    "name": "강병준",
    "feedback": "Q. 처음부터 AI의 도움을 받아 코드를 작성하고, 이후 스스로 이해할 수 있도록 수정해나가는 방식으로 진행 중입니다. 이 방법이 바람직한 학습 방식일까요, 아니면 먼저 스스로 코드를 모두 작성한 뒤, 이후에 AI의 도움을 받아 개선하는 것이 더 좋을까요?\n\nA. 저는 인공지능을 사수가아닌 부사수의 개념으로 사용해달라고 가이드 하는  편입니다. 그말은 어떻게 만드는지 이미 알고 있지만 귀찮아서 코드 생성을 AI에게 맡기고 원하는 결과물이 나올때까지 요청하는 것이죠. 지금과 같은 과제는 저라면 AI 도움없이 만들 것 같습니다~\n\n\nQ. 현재 과제에서 createElement.js의 updateAttributes와 updateElement.js의 updateAttributes가 유사한 작업을 수행합니다. 이럴 때, 공통 로직을 하나의 모듈로 분리해서 사용하는 것과 각각 파일 내에 따로 정의하는 것에는 어떤 차이가 있을까요? 멘토님은 이처럼 중복된 메서드가 있을 때, 보통 어떤 기준으로 모듈화를 결정하시나요?\n\nA. 넵 말씀하신대로 updateAttributes의 일부로직이 재사용된다면, 이것은 코드를 분리해달라는 신호일 수 있어요 그래서 해당 로직의 동작을 설명하는 함수로 분리해서 그 함수를 updateElement와 createElement에서 사용해야할 것 같습니다 :) 저는 맥락보다 중복된 코드 생겼을때를 코드가 보내는 신호라고 판단하고 분리해 재사용합니다!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/46"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "권지호",
    "feedback": "지호님 고생하셨어요!\n꼼꼼하게 정리해주신 회고를 보니까 저도 많은 것을 배울 수 있었던 것 같네요. 말씀해주신것처럼 AI를 통해 단순히 코드만 짜기보다는 학습을 위한 도구로 활용할 때 항해에서는 가치가 극도로 올라가는 것 같아요 ㅎㅎ \n\n전체적인 로직도 크게 잘못 구현된 부분도 없고, 필요한 부분에 대해서도 명확하게 깔끔하게 잘 구현이 된 것 같습니다 :+1\n\n질문 주셨던 부분 답변드려볼게요.\n\n> 앞서 언급했던 리팩토링의 과정과 방향이 적절했다고 생각되는지, 개선할 방향이 있는지 코치님의 의견이 궁금합니다.\n\n넵! 적절하게 잘 분리된 명확한 함수처럼 보이네요 ㅎㅎ 피드백 드릴게 크게 없습니다.\n\n> 현재 updateChildren 함수는 아래와 같이 배열의 인덱스(index)를 기반으로 새로운 vNode와 기존 vNode를 비교합니다.\n\n네 이부분도 명확하게 목적을 이해하고 계신 것으로 보이는데요. \n결국 키 기반의 diff비교가 이뤄져야 말씀하진 문제가 해결될 것 같아요.\n실제로 구현을 살펴봐야겠지만, 각 노드에 있어 키를 기반으로 저장하는 구조체가 있고 순회 시 키를 기준으로 위치를 이동시키거나 사용되지 않으면 제거, 새로운 값이면 추가하는 형태로 구현이 되어야 할 것 같아요.\n입력하지 않은 값들에 대한 폴백처리도 필요할 것 같구요! 이미 아시는 내용일 것 같지만, 실제 구현이 엄청 복잡하진 않을 것 같아서 다른 구현체들을 참고해보고 구현하신다음 공유해주셔도 좋을 것 같네요 ㅎㅎ\n\n> 저는 어떤 개념에 대해 분석하고 이해하는 것까지는 어느정도 스스로 접근할 수 있다고 생각하는데, 그 내용을 응용하거나 확장하는 사고가 부족한 것 같습니다. 그러한 사고의 확장을 하기 위해서는 평소에 어떤 것들을 하면 도움이 될까요?\n\n제 개인적인 생각으로는, 응용하거나 확장하는 것도 결국 연습인 것 같아요. 딱 처음부터 잘하는 역량이 아니라요. 결국 중요한건 지금 작성해주신것처럼 기본에 대해 명확하게 공부를 해두되, 이것이 단순히 어떻게 구현이 어떻게 되어있구나 하고 마무리 하는게 아니라 좀 더 개발적 관점에서 언제 쓸수 있지라고 상황을 상상해보고 머리속에서 적용해보는 연습을 하는게 필요한 것 같아요. 추후에 쓸 수 있는 무기를 창고에 넣어두는 것처럼요.\n만약 이게 잘 안된다면, 좀 더 깊게 이 기술에 대한 필요성을 이해 하는게 필요할 것 같고 듣기 싫은 말일 수 있지만, 중요하다고 느껴진다면 어느정도는 암기에 대한 필요성도 있지 않을까 싶네요!\n\n\n고생하셨고 다음 주도 화이팅입니다~~",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/21"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "안녕하세요 민지님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> EventManager와 updateElement의 핵심 로직을 AI가 대부분 생성해 주었는데, AI를 어쩔 수 없이 쓰게 될 수 밖에 없는데 AI를 쓰면서 성장할 수 있는 방법이 있을까요?\n\nAI가 작성한 코드를 내가 처음부터 다시 작성해보는거죠!\n혹은 AI에게는 질문만 하고, 코드는 내가 직접 쳐보는 방법이 있어요.\n일단 코드를 직접 작성한다는 행위가 무척 중요한데요, 코드를 작성하고 천천히 읽으면서 머릿속에 차곡차곡 쌓아가다보면 의문이 생기거나 모르는 구간이 있어요.  이에 대해 다시 파고들어가는거죠!\n\n> EventManager와 updateElement( 이 함수들이 아니더라도 재귀함수같은 익숙하지 않은 걸로 함수를 짜야할 때)를 처음 구현할 때 어디서부터 시작해야 할지 감이 잘 잡히지 않고 막막해 AI로 코드를 구현했습니다. 이런 상황에서 우선적으로 무엇을 살펴보고 어떻게 감을 잡아서 나아가야할지 알고 싶습니다.\n\n처음부터 모든 기능을 다 구현하려고 하면 막막한게 당연해요!\n그래서 작은 기능부터 하나씩 만들어가면 좋답니다 ㅎㅎ\n가령, EventManager의 경우 일단 이벤트를 등록해보는 과정이 중요해요.\n그러다가 어떻게 하면 등록하는 과정을 효과적으로 할 수 있을까? 에 대한 고민을 하면서 코드를 개선하는거죠.\n\n작은 문제를 여러개 해결하면 결국 큰 문제를 해결하는 상황에 도달할 수 있다고 생각합니다.\n\n한 번에 모든걸 잘 해야지 라고 생각하기보단, 작은 단위로 문제를 쪼개서 하나씩 해결하는 방식을 고민해보세요!\n\n우리가 회사에 입사할 때에도\n\n입사한다 = 하나의 큰 목표\n\n입사를 하기위해선?\n-> 이력서를 작성한다.\n-> 이력서를 작성하기 위해선? 일단 키보드에 손을 얹어서 ~~~\n\n이렇게. 무언가를 하기 위해선 선행되어야 하는 작은 과정이 있으니까요.\n그런 작은 문제들은 무엇이 있을지 고민해보는거죠!\n\nAI에게 명령할 때에도 작은 단위의 문제를 쪼개서 질의하면 더 잘 수행한답니다 ㅎㅎ",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/16"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "안녕하세요 상수님~\n2주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다.\n다음에는 셀프체크에도 진행사항 표기 부탁드려요!\n\n> 만족스러운 부분은 그냥 브라우저 이벤트를 사용한 것이 아닌 React의 이벤트 작동 방식을 이해하기 위해 SyntheticEvent를 구현해 봤던 것이 만족스러웠다. 이런 과정에서 element._vNode 라던지 이런식으로 임시 메모리를 사용해서 관리하는걸 처음 깨달았던것 같다. React 에서는 사용할 일이 없겠지만 이런 방식으로도 할 수 있구나 라는 걸 꺠달았다.\n\n좋은 시도를 해주셨군요!! 멋있어요!!\n\n> WeakMap 활용 방법이 궁금합니다. 저는 현재 일부분들을 el._vNode 이런식으로 임시로 연결하여 사용하고 있거나 Map으로 연결해서 사용하고 있지만 다른 분들의 코드를 보니 WeakMap을 많이 활용한 예시들이 있는데 정말 필요한건지 판단이 잘 안 섭니다.\n\n일단 \"이런게 있어\" 라는것만 인지해도 좋아요 ㅎㅎ 필요한 상황은 너무 가지 각색이라... 이런 API가 있다는걸 인지하고 있다면 문제가 발생했을 때 갑자기 생각나서 사용하는 경우들이 종종 있답니다.\n\n이런 경험적인 측면이 강해서.... 저도 실무에서 쓰는 경우는 이번 과제랑 유사한데, native 이벤트를 별도의 메모리에 저장해서 관리하고 해제할 때 사용하고 있답니다! react와 연관되지 않은 코드다보니.. 직접 메모리 관리를 해줘야 해서요 ㅋㅋ\n\n보통 라이브러리 같은거 만들 때 쓰일 수 있을 것 같네요!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/14"
    }
  },
  {
    "passed": true,
    "name": "김소희",
    "feedback": "안녕하세요 소희~ 수고 많았어요~ 이번 과제는 React의 핵심 원리인 가상 DOM과 diff 알고리즘을 직접 구현해보면서, 프레임워크가 어떻게 효율적인 렌더링을 수행하는지 이해하는 것이 목표였습니다. 무엇보다 \"필요가 진정한 공부를 만든다\"는 경험을 했기를 바래요. 단순히 이론으로 아는 것과 실제로 구현하기 위해 필요한 지식을 찾아가며 학습하는 것은 완전히 다른 깊이의 이해를 가져다준다는 것을 느꼈기를 바래요. 이러한 코드들이 당장 실무에서는 쓰이지 않겠지만 개발을 더 선명하게 이해해주는 사고방식을 만드는데 도움을 준답니다.\n\n코드를 살펴보니 특히 이벤트 위임 시스템을 3-depth Map 구조(`Map<Element, Map<EventType, Set<Handler>>>`)로 체계적으로 구현하신 점이 인상적입니다. 중복 리스너 등록 방지를 위해 `attachedListeners`를 별도로 관리하고, 활성 이벤트 타입만 동적으로 등록하는 최적화도 잘 적용하셨어요. \n\n회고에서 언급하신 DOM의 property와 attribute 차이점을 파악하는 데 어려움을 겪으셨다는 부분도 공감됩니다. 실제로 `checked`, `disabled` 같은 boolean 속성들은 attribute와 property가 완벽히 동기화되지 않아 많은 개발자들이 혼란을 겪는 부분입니다. 이를 정확히 구분해서 처리하신 것은 깊이 있는 학습의 결과라고 생각합니다.\n\n코드 상에서 몇 가지 개선할 수 있는 부분을 짚어보자면\n\n1. WeakMap을 사용해보세요. DOM 요소들은 화면에서 사용되지 않으면 메모리에서 해제되도록 되어 있는데 Map의 key에 보관이 되면 메모리 누수가 발생하게 됩니다. 이를 방지하지 위한 도구가 WeakMap인데요 DOM과 같이 브라우저 API의 값을 key로 써야 하는 상황이라면 WeakMap을 사용하는게 좋습니다.\n\n2. updateAttributes 중복 제거: 회고에서도 언급하셨듯이 createElement와 updateElement에서 속성 처리 로직이 중복되어 있습니다. 공통 유틸리티 함수로 추출하면 유지보수가 더 쉬워지겠죠. 뭔가 해야겠다 생각하면 한번 시도해보는 것도 좋아요!\n\n3. 이벤트 버블링 최적화: 현재 while문으로 부모를 순회하며 핸들러를 찾는데, 최근에는 event.composedPath() 라는 API도 나와서 최신 Native API들도 한번 찾아보는 것도 좋습니다.\n\n---\n\nQ) 코드 작성 스타일에 대한 습관\n=> 전반적으로 깔끔하고 읽기 쉬운 코드를 작성하셨습니다. 특히 주석으로 자료구조를 명시한 점(`// el -> event type -> handlers`)이 좋았습니다. 다만 복잡한 조건문에서는 early return 패턴을 더 활용하면 가독성이 향상될 것 같습니다.\n\nQ) 다음 스텝은 무엇인가요?\n=> 반복적인 컨텐츠를 key를 통한 최적화 기법, 컴포넌트의 핵심인 useState와 useEffect 상태관리 등을 만들어 보면 좋겠네요. 여기까지는 알고 있어야 React의 핵심을 다 이해하는 것이니까요.\n\n=> 특히 상태 관리 시스템을 먼저 구현해보시면, 지금까지 만든 렌더링 시스템과 자연스럽게 연결될 것입니다.\n\n=> 그리고 useMemo나 Memo등의 최적화 방식과 Context를 이용한 전역상태관리 Suspense등의 비동기 처리등 실제 React가 새롭게 추가한 역사를 따라가면서 core부터 최신 기능까지 원리를 이해해보면 좋겠네요.\n\n수고하셨습니다. 다음 주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/42"
    }
  },
  {
    "passed": true,
    "name": "김수민",
    "feedback": "안녕하세요 수민공주(?) ㅋ 수고했습니다. 이번 과제는 React의 핵심 원리인 가상 DOM과 diff 알고리즘을 직접 구현해보면서, 프레임워크가 어떻게 효율적인 렌더링을 수행하는지 이해하는 것이 목표였습니다. 특히 \"가상 DOM이란 무엇인가\"를 읽고 아는 것과, \"가상 DOM을 구현하기 위해 무엇이 필요한가\"를 고민하며 공부하는 것은 완전히 다른 깊이의 학습방법이 될 수 있다는 것을 느끼는 시간이 되어주었기를 바랍니다.\n\n회고에서 createVNode의 children 평탄화나 normalizeVNode의 역할 등 구현 과정에서 생긴 의문들을 하나하나 해결해가며 학습하신 과정이 인상적입니다. 특히 WeakMap을 활용한 이벤트 관리와 선언적 스타일의 코드 작성은 메모리 효율성과 가독성을 모두 고려한 좋은 선택이었습니다. 잘하셨습니다.\n\n이렇게 직접 저수준 라이브러리를 구현해보면 단순한 이론이 아닌 실제 동작 원리를 체득하게 됩니다. 앞으로도 필요에 의한 목적 지향적 학습을 계속 이어가시길 바랍니다.\n\n숙제로 아쉬워했던 \"...Reconciliation 구현하는 게 어려울 거다, 제약 조건(예를 들면 react의 key) 같은 것을 두는 게 편할 거다...\" 를 못해본거 꼭 하기입니다!! ㅋ\n\n그리고 여기에서 최소 useState, useEffect 정도까지만, 조금 더 욕심내면 memo와 context, suspense 정도들만 맛보기로 구현을 해보면 그전에 면접에서 말로 외우던 내용이 아니라 정말로 자신의 언어와 경험을 표현할 수 있을거에요.\n\n수고하셨습니다. 다음 주차 과제도 화이팅입니다!\n\n---\n**Q) eventManager에서 각 eventType에 대해 handler를 여러 개 걸 수 있어야 할까요?**\n=> 프레임워크 수준에서는 여러 핸들러를 지원하는 것이 확장성 측면에서 좋습니다. 라이브러리 내부적으로 성능 측정, 로깅, 이벤트 합성 등 사용자가 모르는 여러 핸들러를 붙일 수 있어야 하거든요. React도 내부적으로는 여러 처리를 하면서 사용자에게는 하나의 핸들러만 노출합니다. 당장 필요 없더라도 확장 가능한 구조로 만드는 것이 좋은 선택입니다.\n\n**Q) eventTypes를 Set으로 관리 vs constant 배열**\n=> 동적으로 이벤트 타입이 추가될 가능성이 있다면 Set이 유리하고, 고정된 이벤트만 다룬다면 constant가 나을 수 있습니다. 유지보수와 확장성을 고려해 Set을 사용하는 것이 좋겠죠? 나중에 새로운 이벤트 타입이 추가되어도 코드 수정 없이 자동으로 처리되니까요.\n\n어떻게 보면 현재 React가 어떻게 하고 있나가 사실상 정답지에 가까워서 이러한 의문에 대한 대답의 힌트는 다른데서는 어떻게 하고 있나? 이런거 찾아보시면 좋아요.\n\n수고하셨습니다. 다음 주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/56"
    }
  },
  {
    "passed": true,
    "name": "김수현",
    "feedback": "안녕하세요 수현~, 수고하셨습니다! 이번 과제는 React의 핵심 원리인 가상 DOM과 diff 알고리즘을 직접 구현해보면서, 프레임워크가 어떻게 효율적인 렌더링을 수행하는지 이해하는 것이 목표였습니다. '필요가 공부를 만든다'는 경험을 하셨기를 바랍니다. 단순히 \"가상 DOM이란 무엇인가\"를 읽고 아는 것과, \"가상 DOM을 구현하기 위해 무엇이 필요한가\"를 고민하며 공부하는 것은 다른 깊이를 요구한다는 것을 깨닫으면서 실무에 필요하지 않더라도 앞으로 깊이단계에 있는 것들을 스스로 만들어보면서 공부를 해보시기를 바래요.\n\n회고에서 1주차의 시행착오를 바탕으로 2주차에는 체계적으로 접근하셨다는 점 아주 좋습니다. 가상 DOM의 전체 흐름(createVNode → normalizeVNode → createElement → updateElement)을 명확히 이해하고 구현하신 점, 그리고 이벤트 위임의 장점을 잘 파악하고 WeakMap으로 메모리 관리까지 고려하신 점 좋습니다 ^^ 지금과 같이 기록하면서 어떻게 성장했는지 스스로 느끼는 것이 실제 성취에도 큰 도움을 줍니다.\n\nupdateAttributes 함수의 else if가 많이 반복되는데 else if 대신 return이 가능하면 early return 패턴으로 작성하면 보다 가독성 높고 관리하기 좋은 코드가 된답니다.\n\n이렇게 직접 프레임워크의 핵심을 구현해보니, 기존에 막연히 알고 있던 Virtual DOM의 개념이 훨씬 선명해졌을 거라 생각합니다. 이제 React를 사용할 때도 내부에서 어떤 일이 일어나는지 더 잘 이해하실 수 있을 거예요.\n\n---\n\nQ) 모든 DOM 이벤트를 자동으로 처리하게 할 수는 없을까요?\n\n=> 좋은 질문입니다! 기술적으로는 가능하겠지만 염려한대로 모든 이벤트를 처음부터 다 등록해두는 것은 성능상 좋지 않겠죠. DOM에서 사용하는 이벤트의 종류는 매무 많으니까요. 사용하지 않을 메모리를 미리 사용하는 건 낭비입니다.\n\n보통 이럴때는 대부분 필요할 때 필요한만큼 생성하는 동적 방식으로 구현을 하곤합니다. 지현도 생각했던 것처럼 addEvent가 호출될 때 해당 이벤트 타입을 Set에 저장하고, 처음 등록되는 이벤트 타입이라면 그때 root에 리스너를 추가하는 방식이죠. 이 방식도 꼭 한번 구현해보길 바래요.\n\n수고하셨습니다. 3주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/22"
    }
  },
  {
    "passed": false,
    "name": "김연수",
    "feedback": "안녕하세요 연수님~ 현재 테스트 코드는 통과하는데, e2e 테스트는 실패하고 있군요 ㅠㅠ\n\n대체로 잘 만들어주셨는데 이 부분 딱 하나가 문제가 되고 있어요.\n\nupdateAttribute를 실행할 때\n```tsx\n else if (key.startsWith(\"data-\")) {\n        // data 속성 처리\n        const dataKey = key.substring(5);\n        $el.dataset[dataKey] = value;\n      }\n```\n\n사실 dataKey도 어차피 attribute라서 저 조건만 제거하면 정상적으로 동작한답니다..\n\n자세한 내용은\nhttps://discord.com/channels/1288769861589270590/1395603615820943400/1395604400919285842\n여기에 올려놨으니 참고해주세요!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/48"
    }
  },
  {
    "passed": true,
    "name": "김유현",
    "feedback": "유현님 고생하셨어요~\n작은 단위로 문제를 분할하고 점점 완성해나가는 접근 멋있는데요!\n현업에서도 문제가 너무 복잡하게 느껴진다면 많이 사용하는 방식이니 좋은 기회라고 생각하시고 계속해서 연습해보시면 좋겠어요 ㅎㅎ\n과제 내용을 보면 명확하게 필요한 부분에 대해서 잘 구현하신 것 같아요.\n각 함수에 대한 주석도 깔끔하게 작성해주셨구요 ㅎㅎ \n\n질문 주셨던 부분 답변을 드려보면요.\n\n> 함수 내 조건문이 길어지고 있는데 가독성을 위해 분리하거나 early return 방식이 더 나은 구간이 있을까요? \n\n이 부분은 사실 얼리 리턴이 적용되어 코드가 좀 더 깔끔해지기보다는 추상화 수준, 그리고 지금은 절차적으로 되어있는 여러 코드들에 대해서 함수형 코딩으로 해당 동작들에 대해 공통 로직들을 분리하고 가독성을 높이는 방식으로 진행해보면 어떨까 싶긴 했어요! 말씀해주신 함수들이 이에 해당했는데요. 관련해서 함수형 코딩의 핵심 원칙같은것들을 미리 공부해보셔도 좋을 것 같고, 함수를 내 기준에 맞춰 추상화 해보고 AI에게 피드백을 받아가면서 적절한 추상화란 무엇인지 개념을 정립해 봐도 좋을 것 같아요. (이 부분은 추후 발제에서도 다루는 내용이니 기대해보셔도 좋을 것 같네요 ㅎㅎ)\n\n> 현재 updateElement에서 타입이 다른 VNode는 교체하고 텍스트 노드는 바로 비교하는 방식이 React의 Reconciliation과 유사하다고 생각했는데 이 접근 방식에 논리적 허점이나 성능 문제가 있을까요?\n\n말씀해주신대로 지금의 과제 복잡도에서는 충분히 잘 구현해주셨다고 생각이드는데요. 지금의 구조에서는 트리를 대체하는 방식이 조금 비효율 적일 수 있어서 추후에 더 복잡도를 높인다고 한다면, 실제 리액트처럼 키를 기반으로 비교를 진행하고 트리를 기반으로 순회하면서 업데이트 하는 구조를 만드는게 좋지 않을까 싶긴합니다! 관련해서 이미 구현체들이나 설명이 되어있는 글들이 많으니 꼭 함께 학습해보시면 좋을 것 같아요.\n\n고생 많이 하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/26"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "안녕하세요 지혜, 고생많았습니다. 이번 과제는 React의 핵심 원리인 가상 DOM과 diff 알고리즘을 직접 구현해보면서, 프레임워크가 어떻게 효율적인 렌더링을 수행하는지 이해하는 것이 목표였습니다. 특히 이론을 배우는게 아니라 구현을 통해서 배우는 것의 중요함을 경험했기를 바래요.\n\n회고에서 \"평탄화\", \"재귀적 표준화\", \"DocumentFragment\" 같은 개념들을 처음에는 암호문처럼 느꼈다고 하셨는데, AI와 함께 구현하면서 이런 개념들이 왜 필요한지 체감하신 과정이 인상적이네요. `updateElement`에서 5가지 케이스를 모두 처리하는 로직을 구현하면서 DOM 조작의 복잡성을 이해하신 점이 좋았습니다.\n\n코드를 살펴보니 이벤트 위임 시스템을 Map을 활용해 구현하고, boolean 속성들을 property로 처리하는 등 DOM API의 세부사항을 잘 이해하고 작성하셨네요. 다만 몇 가지 개선점이 보입니다. 예를 들어 `updateChildren`에서 `Array.from($parent.childNodes)`로 NodeList를 배열로 변환한 것은 좋은 판단이었지만, 대량의 DOM 조작 시 성능을 위해 DocumentFragment를 더 적극적으로 활용하면 좋겠습니다.\n\nAI 의존도가 높았다고 고민하셨는데, 많은 친구들이 다들 고민하는 주제라고 생각해요. AI는 도구인데다가 내가 하는게 아니라 외주를 준다라고 생각하게 되면 AI가 어떻게 만들어 오던 관심이 없고 결과가 중요하니까요. 우리가 개발을 하는 거라면 결과중심어도 상관없겠지만 성장과 학습의 측면에서는 내가 직접해야 성장을 할 수 있으니까요. AI 의존적이라는게 나쁜 건 아니지만 본인게 아니라는 느낌이 더 크게 다가온다 생각합니다.\n\n스스로 검증을 해보는 시간을 가벼보세요. 제일 쉬운 검증은 내가 AI를 이용했건 아니건간에 내가 만든걸 얼마나 구체적으로 남에게 설명할 수 있느냐로 확인 할 수 있습니다. 특히 육성으로 말해보는게 필요합니다. 녹음기를 통해 내가 작업한 결과를 말로 설명해보면서 내가 충분히 이해를 했는지 그렇지 않았는데 AI가 해준걸 본인이 이해하고 한 것처럼 착각하는지 판단할 수 있을거에요.\n\nAI라는 멋진 도구를 잘 활용하고 학습하는 방법을 찾아내는 것도 현 시대를 살아가는 중요한 능력이라고 생각해요.\n\n팀원들과의 소통도 좋은 방법입니다. AI는 정답이라 생각하는 것을 주지만, 동료들은 \"왜 그게 정답인지\", \"다른 방법은 없는지\" 같은 더 깊은 통찰을 생각하게 만들어주니까요.\n\n수고하셨습니다. 2주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/61"
    }
  },
  {
    "passed": true,
    "name": "김효진",
    "feedback": "고생하셨습니다 효진님!\n깔끔하게 필요한 부분들에 필요한 코드를 잘 작성해주셨네요. :+1\n\n제가 실제 어땠는지는 잘 모르지만! 작성해주셨던것처럼 AI의 도움을 받는것이 늦은 행동이라고 느껴지셨을지는 몰라도, 그 고민의 시간들이 결국 AI에게 명확한것들을 물어보고 답을 얻는데 크게 도움이 되었다고 생각해요. 공부한 시간들을 너무 아깝게 생각하지는 마시고, 대신 다음 과제때는 명확해지면 빠르게 도움을 받아보는 형태로 가보시면 좋겠네요.\n\n질문 주신거 답변 드려볼게요!\n\n> Map , WeakMap, Set, WeakSet를 사용할 때 조금은 무분별하게 혹은 적절하지 않게 사용하지 않았나 생각이 듭니다. 특히 eventManager 코드에서 세개나 사용하고 있는데 어떻게 사용했어야 좀 더 효율적으로 구현할 수 있었을까요?\n\n잘 사용해주셨다고 생각합니다. 사실 갯수는 크게 중요한 기준이 되지 않는것 같아요! 비슷한 고민으로 한 폴더 내에 파일이 너무 많아진다고 느껴지거나, 함수의 길이가 길고 짧고 느껴지는 것들이 개개인마다 다른것들이 있을것 같은데요. 길이나 갯수를 고려하면서 어떤 것들을 쓰지 않으려고 하기 보다는 명확한 목적에 맞는 자료구조를 선택하고 활용하는게 중요하죠. 이벤트의 중복 관리나 타입들을 제어하기 위해 적절한 타입들을 선택했다고 생각합니다. \n\n> element._hasEventDelegation 이런 방식으로 DOM 요소에 직접 속성을 추가하는 방식에 대해서는 어떻게 생각하시는지 궁금합니다.\n\n권장하지 않습니다! 이미 찾아보셨겠지만, 돔  요소에 직접 속성을 추가하는것은 오염의 가능성이 있어 권장하지 않아요. 명확성도 떨어지고 _를 붙인다고 해서 해당 속성이 감춰지는 것도 아니구요. data 속성을 활용하는 경우도 있는데, 별도의 자료구조에 담아서 처리하는게 저는 더 명확해보여요 ㅎㅎ\n\n\n고생하셨고 다음주 과제도 화이팅입니다!!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/23"
    }
  },
  {
    "passed": true,
    "name": "김휘린",
    "feedback": "안녕하세요 휘린, 수고했어요~ 이번 과제는 React의 핵심 원리인 가상 DOM과 diff 알고리즘을 직접 구현해보면서 기존에 innerHTML을 사용해서 전체를 렌더링을 하는 비효율적인 방식과 하나씩 DOM을 수동으로 업데이트를 해가는 방식을 더 선언적이고 직관적인 세련된 방법으로 다루기 위해 프레임워크가 어떻게 효율적인 렌더링을 수행하는지 이해하는 것이 목표였습니다. 단순히 DOM을 조작하는 것을 넘어서 최적화된 업데이트 로직을 경험했기를 바랍니다.\n\n특히 DOM의 attribute와 property 차이점을 정확히 파악하고 처리한 부분이 인상적입니다. checked, disabled 같은 boolean 속성을 property로 처리하고, children이 읽기 전용임을 발견하여 적절히 예외 처리한 것은 깊이 있는 이해를 보여줍니다. 또한 이벤트 위임 시스템을 WeakMap으로 구현한 것도 메모리 관리 측면에서 좋은 선택이었습니다.\n\n이러한 프레임워크를 구현을 하다보면 필연적으로 알아야 하는 Low-level의 지식들이 있는데 알고만 있는게 아니라 목표를 가지고 만들어야 할때 우리는 그 내용을 훨씬 더 잘 이해할 수 있다는걸 경험해보는 소중한 시간이 되었기를 바래요. \n\n이런건 실무에서 다루지는 않지만 내가 다루는 도구의 원리를 이해하고 다루는것과 그렇지 않은 것에는 큰 차이가 있으니, 꼭 완벽하지 않더라도 이미 시중에서 내가 잘 쓰고 있는 유용한 도구들을 직접 나만의 프레임워크, 나만의 도구로 직접 구현해보는 경험을 통해 저수준의 영역들도 이해해보기 바래요.\n\n이제 가상 DOM의 기본 원리를 이해하셨으니, 다음 단계에서는 상태 관리와 컴포넌트 시스템도 한번 도전해보는 건 어떨까요? ㅎ 남은 주차도 화이팅입니다. 수고하셨습니다!\n\n---\n\nQ) createElement에서 숫자를 문자열로 변환하는 이유\n=> 좋은 질문 입니다. 저수준의 코딩을 하다보면 하나의 함수가 여러가지 경우의 수를 다 다룰 수 있도록 만들면 에러를 발견하기가 매우 어렵게 됩니다. 특히나 string과 number의 내부 메소드가 다른데 num.slice(1,-1) 이런식으로 호출했다나 에러가 나는 경우는 상당히 빈번하죠.\n\n그래서 애초에 함수의 제약조건을 높여서 저수준의 함수를 먼저 설계해두고 중간에 정규화과정을 거쳐서 미연에 그렇게 되지 않도록 만드는 일정의 방어적 프로그래밍의 일종입니다.\n\n일부 중복검사를 하는 것처럼 보일 수 있고 실제로 이런 코드로 인해 성능이 희생될수 있지만 유지보수를 위해 간결한 코드를 만드는 우선전략이라고 생각해주세요.\n\n도움이 되었기를 바랍니다 :)",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/4"
    }
  },
  {
    "passed": true,
    "name": "박상수",
    "feedback": "고생하셨습니다 상수님.\n과제는 잘 작성해주셨던 것 같아요! 명확하게 목적에 맞춰서 필요한 부분은 잘 구현해주신 것 같습니다.\n\n다만 공부를 하셨던 많은 내용들이 있으셨던 것 같은데, 그 부분들을 글로 옮겨보고 공유해보고 하는 경험이 추후에 공부 한 기억을 오래 갖고가시는데 큰 도움이 될 것 같아요. 지금은 셀프 회고에 가볍게 적어주셨지만 다음 주차부터는 다른 분들 과제를 리뷰해보기도 하고 참고해서 작성해보신다면 더 도움이 많이 될 것 같습니다.\n\n다음 주도 화이팅입니다~",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/50"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "안녕하세요 소연님!\n과제 무척 잘 진행해주셨네요 ㅎㅎ\n1주차보다 개인적으로 어려웠다는 말씀이 인상깊습니다 ㅋㅋ\n\n질문해주신 내용을 토대로 커밋에서 변경된 내역을 확인해봤는데요,\n\n이전 코드가 이렇게 되어있어요.\n\n```tsx\nexport function renderElement(vNode, container) {\n  const normalizedVNode = normalizeVNode(vNode);\n\n  // 최초 렌더링인지 확인 (이전 vNode가 없으면 최초)\n  if (!container._prevVNode) {\n    // 최초 렌더링: createElement로 DOM 생성\n    console.log(\"최초 렌더링\");\n    const $el = createElement(normalizedVNode);\n    container.innerHTML = \"\"; // 기존 내용 제거\n    container.appendChild($el);\n\n    // 이전 vNode 저장\n    container._prevVNode = vNode; \n    // 렌더링 완료 후 이벤트 등록\n    setupEventListeners(container);\n  } else {\n    // 업데이트: updateElement로 기존 DOM 업데이트\n    console.log(\"업데이트 렌더링\");\n    const prevNormalizedVNode = normalizeVNode(container._prevVNode);\n    // container.replaceChild(createElement(normalizedVNode), container.firstChild);\n    updateElement(container, normalizedVNode, prevNormalizedVNode);\n\n    // 새로운 vNode로 업데이트\n    container._prevVNode = vNode;\n  }\n}\n```\n\n여기서 제가 주목한 부분은,\n\n// 이전 vNode 저장\ncontainer._prevVNode = vNode; \n\n여기인데요, 여기에 vNode가 아니라 normalizedVNode 를 저장해야 하는게 아닐까요!?\n그래서 결과가 계속 달라지는게 아닌가.. 싶은 그런 생각이 들어요 ㅎㅎ\n\n변경된 코드에서도 보면 normalizedVNode를 계속 저장하고 있답니다..!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/36"
    }
  },
  {
    "passed": false,
    "name": "박의근",
    "feedback": "Q. 시간이 촉박한 과제를 진행하실 때 관련 개념 학습과 구현 사이의 균형을 어떻게 잡으시는지도 듣고 싶습니다.\n\nA. 의근님 저는 의근님의 방법이 틀리다고는 생각하지 않아요.사실 지금과 같은 학습을 위한 과제의 경우 학습을 먼저 충분히 하는 것은 당연히 권장하는 방법인것 같습니다.\n하지만 회사 과제의 경우는 다를 수 있을 것 같아요. 회사는 정해진 일정이 있고 그안에서 학습과 과제를 완수해야하는 것이 필수 이니까요.\n이것은 어떻게 보면 일정관리라고 생각해요. 저도 당연히 주니어 초빈에는 학습비용이 많이 들었어요. 어떤때는 과제를 제때 해내지 못했던 적도 있고요.\n도전적인 과제를 정해진 시간에 못하는 경우는 많았습니다. 시니어때도 있었죠.\n다만 이것을 어떻게 풀어가느냐가 중요한 것 같습니다. 예를들어 프로젝트를 진행하다보면 학습비용이 커서 \"아 이건 일정내에 해내기 힘들겠는데?\" 싶은 상황이 오면 미리 공유하고 일정을 확보할 수 있는지 확인해볼 수 있을 것 같아요. 반면 마감일 막판에 일정조정 요청을 하는 것은 피해야하죠. \n\n과제 구현에 있어서는 일단 세가지 원칙을 지키면 어떨까 싶어요.\n첫번째 일단 구현해봅니다. 구현하면서 코드는 엉망 진창일 수 있지만 일단 구현하려는 대상을 학습하면서 돌아가게는 만듭니다.\n두번째는 코드 리팩토링단계에요. 그냥 굴러가는게 아니라 잘 굴러가게 만드는 것이죠. 코드도 깔끔하게 정리하면서요.\n세번째는 빠르게 만듭니다. 성능적인 면까지 고려해서 좀 더 빠르거나 UX가 좋게 만들 수 있는 지를 살펴 보는 것이죠.\n\n이렇게 단계별로 진행하면 구현된 코드를 계속 만들어가기 때문에 불안함이 줄어들 수 있습니다!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/57"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박준형",
    "feedback": "준형님 한 주 알차게 보내신 것 같네요 ㅎㅎ\n(링크가 동작을 안하는 것도 있는것 같지만) 과제나 회고가 매우 훌륭하고 완성도있게 작성되어 있네요 :+1\n전체적으로 작성한 글들을 보니 따로 피드백을 드릴만한게 크게 없는 것 같네요.\n\n> 1. Suspense 컨텍스트 스택의 메모리 안전성\n\n넵. 구현도 적절하게 잘 해주신것 같은데요! 저도 조금 더 찾아봐야겠지만, 실제 키 기반으로 해당 캐시를 관리하다 보면 문제가 발생할 여지가 있어서 프로미스 객체 자체를 키로 활용해보는것도 좋지 않을까 라는 소소한 의견도 생각해봅니다. 호출부는 제가 못찾았을 수도 있는데, 각 테스트의 setup단계에서 작성해주셨던 것 같은데요. (제가 잘못이해한거면 추후에 메신저로 알려주세요!) 명시적으로 해당 부분을 언마운트 시점에 호출하는 부분이 있다면 적절할 것 같아요!\n\n> 2. 중첩 Suspense에서의 Promise 버블링 정확성\n\n이 부분도 크게 현재 시점에서는 문제가 없을 것 같지만, suspense가 중첩되거나 재귀적으로 호출이 되다보면 충분히 문제가 발생할 여지는 있을 것 같아요. 콜 스택이 변한다거나..\n리액트에서는 이런 문제를 해결하기 위해서 fiber를 만들고 트리를 순회하는 형태로 개선했던 것 같은데 구현을 참조해보면 좋을것 같아요!\n\n> 3. Promise 캐시 키 생성 전략의 한계\n\n요거는 위에서 슬쩍 제안 드려봤습니다 ㅎㅎ 좋은 방법있음 저도 공부할겸 아고라에 공유해주세요!\n\n> 4. 비동기 컴포넌트 에러 처리의 사용자 경험\n\n요것도 실제 리액트 구현을 참고하면 좋을 것 같은데요. 저희들이 비동기, 동기적 여러 에러를 제어할 때 ErrorBoundary로 감싸서 각 객체 타입별로 에러를 제어하는 레이어를 명확하게 둬 합성해 관심사를 분리하는 형태로 구현하는게 일반적일 것 같은데요! 이런 구조를 그대로 따와서 각 에러에 따른 명확한 바운더리를 나누고 구역별 에러 메세지를 명확하게 나눠보면 어떨까요?\n\n이 부분에 대해서 공부할만한 글이 있는데, 직접적이게 ErrorBoundary에 대해 막 다루는 글들은 아니지만 읽어보면 도움이 되실것 같아요.\n\nhttps://tech.kakaoent.com/front-end/2022/221110-error-boundary/\nhttps://www.youtube.com/watch?v=012IPbMX_y4\n\n다음 주도 화이팅입니다!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/9"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박창준",
    "feedback": "안녕하세요 창준님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> “innerHTML로 DOM을 전부 다시 그리는 방식이 정말 SPA라고 할 수 있을까?” 라는 의문이 생겼었는데 제가 너무 성급하게 고민을 했엇네요 ㅎㅎ.. 2주차에 Virtual DOM을 직접 구현하는 과제가 나오면서 코치님들이 과제를 어떻게 단계적으로 설계했고 수강생들에게 어떤 학습 포인트를 던지려 했는지 이해할 수 있었습니다.\n\n맞아요 ㅎㅎ 일부로 \"불편함\"을 경험해보고, 이걸 해결하는 방식으로 과제를 설계했답니다! 알아주셔서 감사드려요!!\n\n> Q1. 이번 과제를 수행하면서 좀더 React에 대한 Deep Dive를 해보고 싶어졌습니다. 추가적으로 학습하면 좋은 내용이 있으면 추천해주실 수 있을까요?\n\nreact 자체에 대해 파고들어 가는 방법도 있고, preact 같은 경량화된 버전의 react 구현체의 코드를 살펴보면서 내가 작성한 코드와 무엇이 다른지 비교해보는 방법도 있답니다 ㅎㅎ\n\n개인적으로 훅을 처음부터 아예 구현하는 방식으로 시도해보면 좋다고 생각하는데.... 이게 생각보다 난이도가 높아서... 중간과정이 필요한데 그게 preact 살펴보기일 것 같아요!\n\n> Q2. 현재 구현된 diffing은 index기반 비교 알고리즘입니다. 이를 key 기반으로 확장하려면 어떤식으로 리팩토링을 진행하면 좋을까요?\n\nprops에 key를 받아온 다음에, index 이전에 key에 대해 먼저 검사해서 위치를 변경해주거나 그대로 두거나 하는 방법이 있을 것 같네요 ㅎㅎ\n\n> Q3. updateAttributes 함수에서 놓치고 잇는 edge case가 있을까요?\n\n제가 솔루션 만들 때 미처 신경쓰지 못한 부분인데요, data attribute 에 boolean을 넣으면 사라지는 현상이 있었어요 ㅎㅎ\n\n그래서 사실 제일 좋은 방법은 어플리케이션을 만들어가면서 엣지케이스를 채워가는거라고 생각합니다.. 허허\n\n그리고 또 defaultValue 같은것도 리액트에서 지원하는데 현재에는 이런 개념이 없어요.\n\nselect / option 을 react로 변환해보시면 알 수 있답니다!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/20"
    }
  },
  {
    "passed": true,
    "name": "신홍준",
    "feedback": "홍준님 고생하셨습니다. \n회고를 읽어보니 아주 많은 것을 스스로 학습하신 것 같아서 좋네요!\n명확하게 각 함수들에 대해 정리해보고, 목적을 작성해보신것도 너무 좋았습니다. 큰 것은 아니기도 하고 갠취이긴 하지만 이런 주석을 남기는게 AI에게 명확한 구현 지침이 될 수 있어서 좋다고 생각하는데요! 다만 전통적인 관점에서 이런 주석들이 코드 자체로 명확하게 드러날 수 있다고 생각해 구현이 마무리되면 명확한 부분들만 남겨보는건 어떨까 싶기도하네요!\n\n리뷰 받고 싶어하셨던 내용으로 넘어가보면요!\n\n> eventManager.js의 addEvent, removeEvent를 지금처럼 createElement나 updateElement에서 사용하는 것이 아니라 직접 사용할 일이 있을까요? \n\n지금 딱 떠오르는 시나리오는 없는 것 같은데요.\n이미 시스템을 만들었다는 점에서 캡슐화 관점에서 결국에는 이 엘리먼트 내에서 추상화를 해서 제어를 하는 편이 이상적이고, 관리가 명확해지면서 편하다고 생각이 드는 것 같아요!\n\n>  기술적인 내용이 아니라 적절치 못한 질문일 수도 있을 것 같습니다. 1, 2주차를 거치며 AI 사용이 점점 익숙해지고 있습니다. 특히 이번 주차는 질문의 단위도 작게 나누어 코드 이해도를 높였고, 개념 정리도 틈틈히 진행했습니다. 하지만 결국 구현능력은 조금 떨어지는 느낌이 듭니다. 내가 이미 알고 있는 것이지만 귀찮은 작업이기에 맡기는 그림이 맞는지, AI의 도움을 적극적으로 받아 큰 맥락, 주요 개념 위주로 익히며 진행해도 되는지 궁금합니다. (+ \"AI 없이 코딩하기 수련\"이 필요할까요?)\n\n음...! 저도 이 부분에 대해 고민이 굉장히 많은데요. \n이전에 저희가 공부를 하는데 있어서는 각 API를 빠르고 적절하게 사용하는 것이 매우 중요했었기 때문에 코드를 작성하는 연습을 하는게 굉장히 중요했었던 것 같아요. \n지금의 시점에서는 그때만큼 그런 역량이 중요해지지 않은 것은 사실이지만 그럼에도 AI를 활용해 모든 코드를 완벽하게 작성할 수 없고, 복잡하고 비즈니스에 가까운 복잡한 함수들을 작성하게 되면 결국 제가 다시 작성하게 되더라구요. 그런 부분에서 과거만큼은 아니지만 여전히 중요하지 않을까라고 생각하는 것 같습니다.\n미래에는 어떻게 될지 모르죠! 저희가 코드를 작성하지 않게 될 수 있겠지만, 지금의 시점에서 저희는 관점을 갖고 연습하고 준비해야 하기 때문에 이 부분도 같이 공부해보면 어떨까 싶네요!\n\n고생하셨고 다음주도 화이팅입니다~~",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/2"
    }
  },
  {
    "passed": true,
    "name": "신희원",
    "feedback": "안녕하세요 희원~, 1-2 과제 수고했습니다. 이번 과제는 React와 같은 프레임워크가 내부적으로 어떻게 동작하는지 직접 구현해보면서 Virtual DOM의 핵심 개념을 체득하는 것이 목표였습니다. 특히 Virtual DOM을 통한 효율적인 렌더링과 이벤트 위임을 직접 구현해보면서 프레임워크의 원리와 꼭 필요한 브라우저 API들의 개념들이 무엇인지 알게되었기를 바래요\n\n코드를 살펴보니 특히 WeakMap을 활용한 메모리 관리와 이벤트 위임 구현을 잘 이해하고 작성해주셨네요. 정규화 과정에서 함수형 컴포넌트를 재귀적으로 처리하는 부분도 올바르게 구현하셨습니다. 잘하셨습니다.\n\ncreateElement 함수에서 updateAttributes가 내부 함수로 정의되어 있는데, 이는 함수가 호출될 때마다 새로 생성되므로 별도의 유틸리티 함수로 분리하면 좋겠네요. 또한 updateElement에서 타입 체크 시 문자열/숫자 비교 로직이 약간 불명확한데, 두 노드가 모두 primitive type일 때만 처리하도록 수정하면 더 안정적일 것 같습니다.\n\n이렇게 직접 내가 사용하고 있는 저수준 라이브러리들을 구현해보게 되면 단순한 이론의 형태가 아니라 구조와 흐름을 이해한채로 개념을 이해하게 됩니다. 아마 기존에 내가 알고 있던 VDOM과 지금의 VDOM의 개념이 많이 달라졌을거라 생각해요. 앞으로 zustnad나 tanstack query와 같은 상태관리 라이브러리도 핵심만 직접 구현을 해본다면 큰 도움이 될거에요.\n\n---\n\nQ) 평탄화를 해줄 때 \"\" 으로 return 해주는 이유와 falsy한 값을 왜 필터링 해주는 지 궁금합니다.\n\n=> 나름의 전략적 결정입니다. 화면상 해당 값들이 실제로 노출이 되어야 하는 경우는 거의 없기 때문이죠. 은행 어플등에서 null, 혹은 undefined라는 글자가 보이면 다들 개발적 버그라는게 너무 티가나는 상황일테니까요. 게다가 React에 하는 조건부 렌더링({isVisible && <Component />})에서 그대로 출력하게 했다면 false가 뜰텐데 매번 {isVisible ? <Component/> : \"\"} 라고 적는 것도 불편했을테지요. 그래서 꼭 표기가 되어야 하는 0을 제외하고는 falsy값을 출력하지 않기로 한 전략적 결정을 반영한 코드입니다.\n\nQ) handleEvent 함수에서 elementEvents를 디버그 찍어보면 나오는 [Function: spy]는 무엇인가요?\n\n=> 이는 Vitest의 테스트 환경에서 생성된 mock 함수입니다. spy는 함수 호출을 추적하고 검증하기 위한 테스트 도구로, 실제 환경에서는 일반 함수가 저장됩니다. getMockName, mockClear 등은 테스트에서 함수 호출 횟수나 인자를 확인하는 메서드들입니다.\n\nQ) createElement.js에서 createDocumentFragment 사용 이유 알아보기\n\n=> DOM이 변경하는 코드에는 화면을 다시 그리도록 하는 코드가 포함되어 있습니다. 그래서 DOM Element들을 하나씩 변경하고 하나씩 appendChild를 하게 되면 그때마다 내부에서 렌더링을 하는 코드가 호출이 되는데 이는 비효율적이죠. 그렇지만 appendChild는 하나의 node만 가능하기에 여러개의 노드를 한번에 등록할 수 가 없습니다. 이때 사용하는것이 가상의 컨테이너인 DocumentFragment입니다. 이 노드는 여러가지 node를 한번에 보관하고 하나의 Node취급을 하지만 어딘가에 등록이 될때에는 동시에 전달을 해줄 수가 있죠. 그래서 한번에 많은 Node를 다뤄야 할때 성능을 위해서 사용합니다.\n\n도움이 되었기를 바랍니다.\n\n수고하셨습니다. 2주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/37"
    }
  },
  {
    "passed": true,
    "name": "양성진",
    "feedback": "성진님 한 주 고생하셨습니다.\n회고에 남겨주셨던것처럼 리액트 내부 구조에 대해서도 고민할 수 있는 기회였고, 사용하는 여러 자료구조나 구현 방식에 대해서도 많은 것을 고민할 수 있는 시간이였던 것 같네요!\n적어주신 것 처럼 시간이 촉박하다보니 전반적인 흐름이나 사용하는데 중점을 뒀다면 여유 시간에 좀 더 명확하게 하는 과정을 겪으면 더 좋을 것 같네요!\n\n이어서 질문 남겨주신 부분 답변 남겨보면요!\n\n> flat(Inifinity) 관련\n\n넵 저도 아마 구현을 했다면 성진님처럼 필요한 기능에 대해서만 우선 구현을 했을 것 같아요! 그리고 가능한 브라우저 네이티브 구현을 사용하려고 해야 속도 측면이나 가독성, 안정성 측면에서도 훨씬 얻는 점이 단기적, 장기적으로 많다고 생각합니다.\n\n> if문 관련\n\n걱정하시는 것처럼 지금은 절차적으로 따라가는게 쉬울 지는 몰라도 조금 더 복잡해진다면 해당 역할들을 코드를 읽으면서 명확하게 이해하는게 어려워질 것 같아 보이기는 하네요 ㅎㅎ\n나름 코드를 작성하는데 있어서 3뎁스 또는 2뎁스 이상의 분기를 만들지 않겠다 라는 규칙을 만들고 더 깊은 뎁스가 발생하는 경우 함수를 분리해야 하는 시점, 더러운 코드를 작성하는 시점이라고 판단해보는 것도 좋을 것 같습니다. \n\nif를 사용하든 switch를 사용하든은 사실 큰 문제가 아닌것 같아요. 분기를 타는 조건을 혹시 컴포넌트 별로 분리할 수 있는지, 명확한 타입화를 통해 추상화를 할 수 있는지 구분해보고 해당 동작들을 별도 함수로 분리해서 가독성을 높여보는게 좋지 않을까 싶네요!\n\n고생하셨고 다음 주 과제도 화이팅입니다!!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/28"
    }
  },
  {
    "passed": false,
    "name": "양창훈",
    "feedback": "Q.  handler안에 매개로 e를 또 주는 이유는 버블링방지하라고 주는 e인가요\n\nA. 버블링 방지 뿐아니라 이벤트 객체를 이벤트핸들러에서 활용하라고 전달하는 e입니다. \n이벤트 핸들러는 이벤트 객체를 활용할 수 있어야하니까요~\n\nQ. 요런 테스트 크드를 보고 \"아 컴포넌트는 function이니까 얘를 다시 vNode.type({ ...vNode.props, children: vNode.children }) 이렇게 해서 재귀를 돌려야 겠다\"와 같은 생각을 하려면 어떤 경험이 필요할까요\n\nA. 테스트 코드를 보고는 저도 모를 것 같아요 :) \n다만 테스트를 해결하는 코드를 작성하면서 코드의 흐름상 이것은 재귀호출로 만들어야겠다라고 생각이 들 것 같아요.\n저는 멘토링때 말씀드렸듯 알고리즘은 빠삭하게 알달 외울필요는 없다고 생각하는데요. 재귀호출을 이용해 문제를 해결하는 능력은 필요하다고 생각해요.\n분할 정복을 구현하는 재료로서의 재귀호출을 충분히 이해하려는 목적으로 알고리즘을 조금 학습해보시면 어떨가 싶습니다.\n평소 업무에서의 재귀호출은 그렇게 많이 사용되지 않으니까요!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/5"
    }
  },
  {
    "passed": false,
    "name": "여진석",
    "feedback": "진석님 이번주도 고생 많으셨습니다~\n아쉽게 E2E에 있어서 테스트가 실패하기도 했고, 회고를 읽어보니 여러 아쉬움이 느껴지는 부분이 있는 것 같은데요 ㅠㅠ\n\n첫 번째 질문을 주신 부분과 이어지는 내용인데요. 결국 저희가 해결해야 하는 문제의 형태는 동일하지만 그 문제를 해결할 수 있는 방법은 여러가지 인데 과제의 특성상 테스트를 통해 해당 모습을 어쩔수 없이 제한을 걸게 되는 것 같아요. 그럼에도 이미 아시겠지만, 꼭 그 문제를 그 방법으로 구현해야만 반드시 해결할 수 있는게 아니듯이 관통하는 가장 중요한 문제해결 핵심은 뭔지 고민을 하는게 제일 중요하지 않을까 싶습니다. (테스트를 통과하지 못했더라도 그 부분을 명확하게 챙길 수 있다면 충분히 의미있어다고 생각해요!)\n \n앞으로 과제를 진행하는데 있어서도 명확한 채점 기준 또는 테스트가 있는 경우가 많을텐데요. 이 테스트를 통과시켜야해 라는 관점으로 접근하는것도 좋지만, 좀 더 큰 그림을 바라보고 접근하면 좋을것 같아요. 대신! 바이브 코딩을 하다라도 너~무 큰 그림을 보기보다는 감당할 수 있는(한번에 검증할 수 있는) 범위의 큰그림에서요.\n\n너무 넓은 범위의 작업을 맡기다보면 퀄리티가 떨어지는 부분도 있고 저희가 검증하기도 어려워지니 계속해서 다시 고치다보면 시간이 더 들어가는 경우들도 많이 있어서요. 내가 구현하고자 하는 부분의 계획을 명확하게 하고 AI에게 그 계획을 통해 구현하게 하는 접근방식도 함께 사용해보시면 좋을것 같습니다!\n\n아! 그리고 테스트에 있어서도 CI에 깨지는 부분이 명확하게 드러나는 것 같은데요.\n\n* https://github.com/hanghae-plus/front_6th_chapter1-2/actions/runs/16354685466/job/46209983367?pr=17\n\n직접 실행을 해보고 내용을 디버깅해보면 좋을것 같은데, 제가 채점을 해야하는 인원이 너무 많다보니..일일히 확인하기 어렵다는 점 양해해주시면 감사하겠습니다. 추후에 더 고민해보시고 찾기 어려우시다면 개인적으로 연락주셔서 함께 고민해보는것도 방법일 것 같아요.\n\n그리고 '자바스크립트에서 class 자체를 abstract 메소드나 나 상속개념이 없다면 사용할 이유가 없다고 생각해도 될까요?'라고 질문을 주셨는데요.\n이 부분은 비슷한 기능을 각각 구현해서 사용할 수 있는 관점에서 적절하게 선택해서 사용하면 되는 관점이지만, 가독성 관점이나 추상화, 캡슐화등의 관점에서 오는 장점도 명확해서요! 사용 목적에 대해서는 명확하게 하고 장점과 단점을 공부해보는건 큰 도움이 될 것 같습니다.\n\n고생하셨고 다음주도 화이팅이에요 진석님!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/17"
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "고생하셨습니다 찬규님!\n5팀만의 규칙으로 이슈에 정리해주셨던 것 같은데 너무 잘 정리해주셨네요. :+1\n어떤 과정으로 과제를 진행해주셨는지 명확하게 이해할 수 있었습니다.\n말그대로 왜 이 구조를 사용하는지, 어떻게 동작하는지 이해할 수 있는 좋은 기회였다고 생각하고 실제 리액트 구조에서는(리스트업 해주신 것 처럼) 이거보다 더 복잡한 여러 과정들이 있으니 이참에 공부 해보고 공유해주시는 것도 좋을 것 같아요 ㅎㅎ\n\n이어서 질문 남겨주신 부분 답변 드려보면,\n\n> update element의 클린코드 관점\n\n음..지금 함수의 문제점이라면 한 함수에서 너무 많은 종류의 속성을 처리하는거지 않나 싶긴 한데요. 속성 타입별로 함수를 만드는 것도 좋겠지만, 공통적으로 처리할 수 있는 함수를 뽑아내는 방식으로 리팩터링을 하는게 좋지 않을까 싶습니다! 분기에 대한 것들도 함수로 명확하게 의도를 드러내고 동작에 대한것도 함수로 분리해서 명확하게 의도를 드러내구요. 예를 들어서 hasDifferentType해서 oldNode의 타입과 newNode의 타입을 비교하는 함수를 분리하면서 작게작게 함수들을 대체하면서 분리하는거죠. \n이런 형태로 분리하다보면 함수 이름 자체로 의도가 드러나기 때문에 좀 더 가독성이 좋아지는 부분이 생기는 것 같습니다. \n추가로 분기에 대한 중첩도 깊어질 수 있으니 일반적으로 말하는 early return, guard clause 패턴을 사용해서 걷어내는 것도 가독성에 좋을 것 같아요.\n\n고생하셨고 다음 주 과제도 화이팅입니다!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/44"
    }
  },
  {
    "passed": true,
    "name": "오하늘",
    "feedback": "안녕하세요 하늘~, 챕터 1-2 과제 정말 수고 많았습니다.\n\n이번 과제를 통해 Virtual DOM의 작동 원리를 직접 구현하면서 React와 같은 프레임워크가 내부적으로 어떻게 효율적인 렌더링을 수행하는지 체득하는 경험을 하셨고, 특히 Map vs WeakMap 같은 자료구조등을 선택하고 고민하는 과정들이 잘 느껴졌어요.\n\n이번 과제는 \"알고 있는 것\"과 \"만들기 위해 필요한 것을 학습하는 것\"의 차이를 몸소 체험하는 것이 핵심이었는데, 회고에서 작성하신 것처럼 처음 접한 WeakMap을 공부하고 eventManager 구현에 적용하려 고민하신 과정이 바로 그런 목적형 학습의 좋은 예시라고 생각합니다. 면접에서도 늘 왜 이 기술을 선택했나요? 혹은 왜 이렇게 만들었나요? 라는 질문의 맥락도 여기에서 기인하는 거죠. 만들기 위해서 하는 공부에서 정말로 많은 것들을 배울 수 있으니까요.\n\n특히 이벤트 위임 시스템을 Map/Set을 활용해 계층적으로 설계하신 점이 인상적이었습니다. eventType을 키로, 그 안에 다시 element와 handler를 매핑하는 구조는 깔끔하고 직관적입니다. \n\nMath.max를 사용해 자식 요소 비교 시 추가/삭제를 모두 감지하도록 구현하신 것도 훌륭한 접근이었습니다. 이런 세심한 고민들이 Virtual DOM의 원리를 제대로 이해하는 과정입니다.\n\n구체적인 코드상의 부분들은 리뷰에서 거의 다 짚어줬네요. style 조건문에서 continue 누락이나 cleanChildren 2번 호출등이요. 좋은 팀이네요! AI도 좋은 친구이지만 실제로 이렇게 코드 리뷰를 함께 하면서 같이 성장할 수 있을 거라 생각합니다. 멋지네요.\n\n수고 많았습니다. 다음 주차도 화이팅입니다!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/60"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "안녕하세요 윤우님!\n2주차 과제 잘 진행해주셨네요 ㅎㅎ 너무 고생하셨습니다.\n바벨 플러그인 문서도 직접 확인해보셨군요!!\n\n> 현재 updateElement, createElement 모두 재귀를 이용해 구현했습니다! 선택해볼법한 더 좋은 알고리즘이 있을까요?\n\n저도 재귀 말고는 떠오르는 방법이.. 딱히 없네요 ㅋㅋ;\n다만 생각해볼 수 있는건, 변경에 대한 커맨드? 라고 해야하나, 그런걸 수집하는 방법이 있을 것 같아요.\n\ninsert, update, delete가 있고\n이 명령어가 정확히 어떤 구간의 dom을 변화시키는지 정보를 수집할 수 있따면 재귀 방식이 아니라 특정 노드의 일부분만 수정하는 방식으로 코드를 작성할 수도 있을 것 같네요!\n\n그럴라면 component의 정보와 component를 변경하는 코드를 연결시켜야 하는데 그게 사실 굉장히 어렵답니다... ㅎㅎ\n\n> 조건문이 많아져서 가독성이 많이 떨어지게 되었는데 if, else if 를 줄이거나 혹은 다른 선택지가 있을까요? \n\n새로운 함수로 만들어서 분리하는 방법이 있어요!\n\n> eventManager 쪽에서 \"이벤트 위임\" 은 작성했지만 while 루프를 돌며 부모 엘리먼트를 재할당하며 이벤트가 있는 요소까지 찾아가는 이벤트 버블링 형태로 처리를 했습니다. 정상적으로 동작은 하지만 이게 맞는건지 잘 모르겠습니다.. 매번 이벤트마다 while 루프가 실행된다고 생각하면 성능이 좋지 않은 것 같다는 생각이 듭니다!\n\n다른 방법을 생각해보자면... 이벤트를 등록할 때, 이벤트 타겟의 부모들을 미리 만들어서 관리할 수 있지 않을까 싶어요 ㅎㅎ\n\nconst createParentList = e => {\n  let parent = e.parentNode;\n  const parentList = new Set()\n  while(!parent){\n    parentList.add(parent);\n    parent = parent.parentNode;\n  }\n  return parentList\n}\n\nconst parentMap = new WeakMap();\nconst addEvent = (el, type, callback) => {\n  if (parentMap.has(el)) {\n    parentMap.set(el, createParentList(el))\n  }\n\n  /// 다른 로직 실행\n}\n\n이렇게 렌더링 시점에 미리 만드는 방법도 있고\n아니면 최초에 한 번 이벤트가 트리거될 때 부모 목록을 만들어서 재활용하는 방법도 있을 것 같아요 ㅎㅎ\n\n> updateElement에서 children을 처리할 때 조건별로 돌아가는 for문이 3개 있습니다. 아무래도 3개의 for문이 거부감이 좀 드는데 적절한 코드가 맞을까요?\n\n일단 문제를 해결하기 위해선 어쩔 수 없겠죠..? 논리적으로 생각해보면, 이걸 for 하나로 만든다고 해도 그 내부에서 분기를 3번 해야 할 수 있어요. 결국 실행해야 하는 코드의 총량은 비슷하죠 ㅎㅎ\n\n진짜로 변경된 attribute에 대한 정보를 렌더링시점에 전달하는 방법이 있다면 좋을텐데... 그런 시스템을 만드는게 더 복잡하고 어렵답니다 ㅎㅎ 맨 위의 답변과 겹쳐요\n\n> 이벤트가 제거됐는지 확인하는 방법이 궁금합니다! 테스트는 통과했는데 현재 코드레벨에서 확인해볼 방법이 있을까요? (메모리가 누수되는지 체크)\n\n글쎄요.. 코드레벨에서 확인할 수 있는 방법이 있을지..\n코드레벨에서 확인한다는건 결국 값을 조회한다는건데, 값을 조회하려고 시도한다는건 다시 메모리상에 무언가가 있는지 확인하는 과정이라서요.\n\n덤프 떠서 확인해야 하지 않을까 싶어요..!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/40"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "윤영서",
    "feedback": "영서님 한 주 고생하셨습니다. \n정리한 내용을 공유해주신 부분도 그렇고, 함께 성장하려고 하시는 부분에 있어서 매우 인상깊었습니다. 남겨주신 회고도 아주 고봉밥인데요. 다른 분들도 함께 보면서 이야기 나눌 수 있으면 좋았겠네요.\n과제에 있어서는 필요한 부분을 명확하게 잘 구현해주신 것 같습니다. \n질문 주셨던 부분 답변 드려보고 마무리 해볼게요.\n\n> 이벤트 위임 시스템을 구현하면서 WeakMap + Map + Set의 3단계 중첩 구조를 선택했는데, 이 설계가 적절한지 궁금합니다. \n\n저는 명확한 것 같습니다. 실제 fiber구조에서도 비슷한 목적에 맞춰 구현이 되어 있는 걸로 알고 있고 굳이굳이 나누면 더 최적화를 할 수 있을 것 같지만 지금의 수준에서는 충분한 것 같아요. 사실 이걸 구현하는데 있어서 영서님이 명확한 목적을 갖고 있고, 그걸 구현하는데 선택하는 자료구조이기 때문에 해당 자료구조를 사용하는 메서드가 약간 복잡해지고 하는 부분은 그 자료구조에서 오는 장점이 더 도움이 되기 때문에 크게 고민할 필요는 없다고 생각해요.\n\n> 모듈 레벨의 전역 변수\n\n넵 말씀해주신것처럼 지금 과제의 수준에서는 크게 문제가 없을 것 같은데요.\n정답을 이미 알고 있는것처럼 팩토리 함수같은 것을 사용해서 함수 내에 컨텍스트를 묶어 사용하는게 오염 측면이나 캡슐화 측면에서 유리한 것 같아요.\n회사에서도 이런 비슷한 코드를 작성하는 경험이 많이 있는데, 저같은 경우에는 처음부터 분리를 하는 편인데요.\n하지만, 이미 알고 있는 것처럼 그리고 우리가 자주 말하는 여러 원칙처럼 필요한 만큼만 최대한 단순하게 작성하는게 좋지 않을까 싶습니다.\n(근데 우리는 지금 공부를 하는 과정이니까 여유가 된다면 분리해보는 연습을 하는게 좋아보여요)\n\n> 지금 현재 React는 key를 기반으로 하지 않고 인덱스를 기반으로 하고 있는데, 만약 key로 구현하고 싶다면 어떻게 구현해야할지에 대해 고민이 되었습니다. 그런데 구현에 어려움이 있어 제가 로직상에 놓친 부분이 있을지 여쭤보고싶습니다.\n\n이 부분도 뭔가 이미 답을 알고 있는 것 같은 것 같은 느낌인데요 ㅎㅎ\n구현을 실제로 해봐야 알겠지만, 전반적인 흐름은 리액트 구현과 유사하다고 생각이 듭니다.  다만, 키가 없는 여러 노드들에 대한 처리나 key가 중복되서 입력될 때의 처리, 그리고 결국 모든게 시점이 중요한 것 같아서 DOM을 조작하는 여러 순서들을 최적화 하는게 핵심이지 않을까 싶긴하네요.\n좀 찾아보니 리액트에서는 이펙트나 트리 순회에 맞춰서 많이 복잡하게 되어 있는 것 같은데,  단순화 해서 삭제 / 이동 / 생성 및 삽입 / 업데이트 요런 흐름으로 진행하는 것 같아서요. 이런 부분도 이미 찾아보셨겠지만 참고해보면서 구현하면 좋을 것 같아요.\n\n+ 지금 충분히 잘해주고 계셔서 이대로도 사실 상관 없을 것 같긴한데요. 그냥 첨언을 해보면,  지금의 과제는 변경된 지점이 있어서 새로운 부분도 있었을 것 같은데요! 추후에 과제를 진행하는데 있어서 여러번 경험한 과제가 있다면 이전에 아쉬웠던 부분이나 기술적으로 시도해보고 싶었던 부분을 더 확장해서 해보는것도 좋을 것 같아요. 고생하셨고 지금처럼 다음 주 과제도 화이팅입니다~",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/7"
    }
  },
  {
    "passed": true,
    "name": "이가은",
    "feedback": "가은님 고생하셨어요!\n회고 남겨주신거 읽어보니, 새로운 개념 뿐만 아니라 잘못 알고 계셨던 개념까지 꽤나 명확하게 될 수 있는 좋은 시간이였네요.\nPreact 구현을 참고하는 것도 매우 좋은 접근이였네요 :+1 :+1\n\n질문 주셨던 부분으로 넘어가 보면요!\n결국 첫번째 질문은 말 그대로 각 객체, Map, WeakMap의 자료 구조의 차이와 이어질 것 같은데요.\n각 자료구조는 프로토타입을 다루는 거나 순회하는 부분, 특히 GC부분에서 동작이 차이가 많이 날 것 같아요. (키에 들어갈 수 있는 부분도요!)\n과제에 있어서 결국 구현을 어떻게 하냐에 따라서 '동작상'으로는 큰 차이는 없을 수 있는데요. 위 차이에 있어서 내가 관리하기 쉬운 방식은 무엇인지 명확하게 비교하고 선택할 수 있다면 큰 차이는 없을 것 같아요~\n\n두번째 질문은 예외처리 관련한 질문이였는데요.\n지금 제가 살펴봤을때는 더~챙겨야 되는 예외처리는 크게 없어보여요! \n충분히 잘 구현해주셨던것 같아요 ㅎㅎ\n걱정이 되신다면 각 작업들이 실패하는 케이스에 있어서 폴백동작들만 잘 정의해주심되지 않을까 싶긴한데 굳이 싶긴하네요!\n\n아무튼 잘 구현해주셨고 다음주 과제도 화이팅 하시길 바랍니다!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/25"
    }
  },
  {
    "passed": true,
    "name": "이민재",
    "feedback": "안녕하세요 민재, 수고하셨습니다 :) 이번 과제는 React의 핵심 원리인 가상 DOM과 diff 알고리즘을 직접 구현해보면서, 프레임워크가 어떻게 효율적인 렌더링을 수행하는지 이해하는 것이 목표였습니다. 특히 단순히 \"가상 DOM이란 무엇인가\"를 이론으로 공부하고 아는 것과 \"가상 DOM을 구현하기 위해 무엇이 필요한가\"를 고민하며 학습하는 것은 완전히 다른 깊이의 경험이라는 것을 체험하는 시간이 되었기를 바랍니다.\n\nJSX → createVNode → normalizeVNode → createElement → updateElement의 전체 흐름을 체계적으로 구현하셨네요. 특히 DocumentFragment를 활용한 배열 처리와 이벤트 버블링/캡처링을 구분하여 처리한 점이 인상적입니다. 회고에서 \"기능 완성 → 테스트 코드 수정\"의 반복 과정을 겪으셨다고 하셨는데, 시행착오를 겪는 동안 오히려 각 API의 세밀한 동작들이 머리속에 잘 새겨졌을 거에요!\n\n이벤트 핸들러 저장에 Map을 사용하고 있는데 이 부분은 WeakMap으로 변경하면 더 좋겠습니다. DOM 요소를 key로 사용하는 경우에는 DOM에 제거될 때 자동으로 이벤트 핸들러도 가비지 컬렉션되어 메모리 누수를 방지할 수 있거든요. 또한 updateAttributes에서 boolean 속성들을 하드코딩한 배열로 관리하는 것보다는 속성의 타입을 동적으로 체크하는 방식을 고려해보시면 확장성이 더 좋아질 것 같습니다.\n\n이렇게 프레임워크의 내부 동작을 직접 구현해보면 단순한 이론이 아닌 실제 구조와 흐름을 체득하게 됩니다. 이제 React를 사용할 때 \"왜 key가 필요한지\", \"왜 이벤트 위임을 사용하는지\" 같은 설계 결정들이 더 명확하게 이해되실 거예요. 앞으로도 이런 저수준 구현 경험을 통해 더 깊이 있는 개발자로 성장하시길 바랍니다. 수고많았습니다.\n\n---\n\nQ) updateElement에서 index 기반 비교의 비효율성 개선 방법\n\n=> 정확한 지적입니다! 현재 방식은 순서만 바뀌어도 모든 노드를 재생성하는 문제가 있죠. React에서 반복된 요소를 그릴때 반드시 key를 요구하는 것도  이 때문입니다. key 기반 매칭을 구현하려면 oldChildren을 Map으로 변환하여 key로 빠르게 찾을 수 있게 하고, 같은 key를 가진 노드끼리만 비교하도록 하고 있죠. 이번 과제에는 제외했지만 중요한 React의 핵심 로직이니 한번 시도해보세요!\n\nQ) 이벤트 위임 구조의 안정성 개선 방안\n\n=> 현재 구조도 잘 구현되어 있어요. 몇가지 개선 방안들을 공유하자면 우선 MutationObserver를 활용하면 동적으로 추가된 요소도 자동으로 감지할 수 있습니다. 그리고 이벤트 타입을 하드코딩하지 말고 실제 사용된 이벤트만 동적하는 방법도 생각해보세요.\n\n수고하셨습니다. 다음 주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/3"
    }
  },
  {
    "passed": true,
    "name": "이유진",
    "feedback": "안녕하세요 유진~, 수고하셨습니다! 이번 과제는 React의 핵심 원리인 가상 DOM과 diff 알고리즘을 직접 구현해보면서, 프레임워크가 어떻게 효율적인 렌더링을 수행하는지 이해하는 것이 목표였습니다. 그전에 내가 만들어야 하니까 구현해가면서 필요한걸 공부하는 것과 그냥 공부를 하는것과의 차이를 확실히 느꼈기를 바랍니다. 단순히 \"가상 DOM이란 무엇인가\"를 읽고 아는 것과, \"가상 DOM을 구현하기 위해 무엇이 필요한가\"를 고민하며 공부하는 것은 완전히 다른 깊이의 학습이니까요. 잘 했습니다.\n\n회고에서 각 함수의 필요성과 역할을 납득하는 과정이 어려웠다고 했는데요. 그래서 Vue 공식문서와 GitHub 레포를 찾아보며 Virtual DOM의 근본적인 문제를 이해하려 노력하신 점, 그리고 실무에서 Vue의 Virtual DOM이 왜 렌더링을 하지 않는지를 생각할 수 있도록 시야가 깊어진 부분이 아주 좋네요. Vue와 React의 렌더링 전략은 다르기에 Virtual DOM이 아닌 Vue의 Rendering방식도 한번 이해해보면 재밌을거에요.\n\n나아가 코드를 조금 더 개선해본다면 하드코딩된 이벤트 리스트 대신, 실제 사용된 이벤트만 동적으로 등록하는 방식도 한번 시도해보시길 바래요.\n\n---\n\nQ1. boolean 속성 처리 방식이 올바른지?\n=> 네, 올바른 접근입니다. HTML의 boolean 속성은 attribute와 property의 동작이 다른데, 이를 정확히 구분하여 처리하신 것이 좋습니다. 특히 `checked`와 `selected`는 property로만 제어해야 하는 것을 잘 파악하셨습니다.\n\nQ2. updateAttributes의 처리 순서가 적절한지?\n=> 네 지금 순서는 큰 문제 없어보입니다. 각 속성 처리가 독립적이기만 하면 되요. 순서보다는 각 처리 로직이 서로 영향을 주지 않도록 설계하는 것이 중요합니다.\n\n이렇게 직접 저수준 라이브러리를 구현해보면서 얻은 깊은 이해는 앞으로 프레임워크를 사용할 때 큰 자산이 될 거에요! 다음 주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/35"
    }
  },
  {
    "passed": true,
    "name": "이은지",
    "feedback": "안녕하세요 은지, 수고하셨습니다. 이번 과제는 React의 핵심 원리인 가상 DOM과 diff 알고리즘을 직접 구현해보면서, 프레임워크가 어떻게 효율적인 렌더링을 수행하는지 이해하는 것이 목표였습니다. 특히 이번 과제를 통해 '필요가 공부를 만든다'는 경험을 하셨기를 바랍니다. 단순히 \"가상 DOM이란 무엇인가\"를 읽고 아는 것과, \"가상 DOM을 구현하기 위해 무엇이 필요한가\"를 고민하며 공부하는 것은 완전히 다른 깊이의 학습이니까요.\n\n그런 점에서 회고에서 JSX pragma의 역할을 몰라 한참 헤맸다고 하신 부분이 참 인상적이었어요. createVNode이 어디서 호출되는지 찾아가며 / @jsx createVNode */ 주석의 의미를 학습하신 과정에서 내가 기존의 학습방식과 필요하니까 찾아가면서 하는 목적형 체험 학습의 경험을 꼭 기억해주기를 바랍니다. 그밖에 이벤트 위임이니 WeakMap등에 대한 검토들도 너무 좋았습니다. \n\n회고에서 \"몸으로 부딪히고 문제가 발생하면 그때 처음으로 돌아가는 습관\"을 발견하셨다고 하셨는데, 사실 이것도 나쁘지만은 않습니다. 그 몸으로 부딫히는 시행착오로 인해서 그 길이 아니었구나라는 경험이 있기에 다음번에서는 그길로 가지 않게 되니까요. 헤메는 만큼 다 습득을 하는 것이니까요. \n\n그렇지만 깨달음을 얻었던 것처럼 하나씩 해야할 Task들을 적절히 단계별로 만들어두고 가는것은 개발자의 구조적 사고 능력중 중요한 능력이므로 같이 연습해보면 좋겠네요.\n\n수고많았습니다. 다음 주차도 화이팅입니다!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/19"
    }
  },
  {
    "passed": false,
    "name": "이의찬",
    "feedback": "안녕하세요 의찬, 수고하셨습니다. 이번 과제는 React 같은 프레임워크가 내부적으로 어떻게 동작하는지 직접 구현해보며 이해하는 과제였습니다. 특히 \"Virtual DOM이 무엇인가?\"를 단순히 알거나 말로 표현하는게 아니라 실제로 구현을 통해서 그 원리가 선명해지길 바랬습니다.\n\n과제를 보면서 JSX → createVNode → normalizeVNode → createElement → renderElement의 전체 흐름까지 이해하는 과정에서 이론과는 다른 원리를 이해하게 되었기를 바래요.\n\n코드 레벨까지 깊게 학습하지 못했다고 아쉬워하셨는데, 꼭 이번이 아니더라도 항해가 끝나는 동안 혹은 그 이후에라도 어떻게 깊이를 학습해야 하는가를 알게되는 주차가 되었기를 바랍니다.\n\n수고하셨습니다. 다음주차도 화이팅입니다~",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/27"
    }
  },
  {
    "passed": true,
    "name": "이정우",
    "feedback": "정우님 고생 많으셨어요 ㅎㅎ\n필요한 부분들에 대해서 명확하게 잘 구현해주셨네요.\n따로 회고가 작성되지 않아서 아쉽다고 느껴졌었는데, 내부 docs를 보니 각 구현에 대해서 잘 정리해주셨네요 :+1\n\n말씀해주신것처럼 추후에 기회가 되신다면 다음 단계로 적어주셨던 부분 직접 구현해보시고 공유해주시면 더 좋을것 같네요\n\n따로 피드백을 요청주셨던 부분은 없어서 여기서 마무리 하겠습니다.\n다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/58"
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "안녕하세요 이지현님, 수고하셨습니다. 이번 과제는 React의 핵심 원리인 가상 DOM과 diff 알고리즘을 직접 구현해보면서, 프레임워크가 어떻게 효율적인 렌더링을 수행하는지 이해하는 것이 목표였습니다. 특히 \"필요가 공부를 만든다\"는 것을 체험하며, 단순히 이론을 아는 것과 실제 구현을 위해 필요한 것을 찾아가며 학습하는 것의 차이를 경험하셨기를 바랍니다.\n\n회고에서 작성해준 \"vNode 객체에 실제 DOM 요소를 저장했던 실수\"는 정말 좋은 경험이네요. 구현파트에서는 일단 돌아가는 코드가 중요하지만 깊이가 필요한 코드에서는 성능이가 원칙, 설계등이 중요한데 앞으로의 소중한 인사이트가 되어 줄거라 기대합니다. 가상 DOM의 핵심이 실제 DOM과의 분리인데, 이를 직접 겪으며 이해하게 된 것 같아요. 또한 WeakMap을 활용한 메모리 관리와 이벤트 위임 구현을 잘 이해하고 작성해주셨네요. 잘했습니다 :)\n\n이렇게 프레임워크를 직접 구현해보면 단순한 이론이 아닌 구조와 흐름을 이해한 채로 개념을 체득하게 됩니다. 앞으로도 이런 방식으로 사용하는 도구의 원리를 파헤쳐보는 경험을 계속해보시기 바랍니다.\n\n---\n\nQ) 이벤트를 저장하는 저장소 계층\n=> 잘했습니다. element > eventType > handler 계층 구조로 선택하신 것은 매우 적절합니다. element가 제거되면 모든 이벤트가 사라지므로 element가 최상회 요소가 맞죠. 그리고 eventType에서 handler의 유무에 따라서 위임이 결정되므로 2번째에 위치하는게 자연스럽습니다. React 등 대부분의 프레임워크도 이 방식을 채택하고 있답니다.\n\nQ) 런타임 에러 처리\n=> 우리가 잘 알고 있는 React의 ErrorBoundary라는 기능이 바로 에러를 처리해주는 기능입니다. 렌더링 에러를 try ~ catch로 감지해서 상위에서 catch하여 fallback UI 표시하는 기능이죠.\n\n=> 지금 그리고 VDOM을 생성하는 로직에 try-catch를 만들고 에러감지시 상위에서 지정된 UI를 표기하도록 만들면 됩니다.\n\n차근 차근 React를 다 만들지는 않더라도 React가 역사적으로 추가한 개념들을 하나씩 만들어가면 왜 이런게 필요했는지 어떻게 구현되어 있을지 선명하게 이해되는 경험을 하시게 될거에요!. \n\n수고많았습니다. 3주차도 화이팅입니다 :)",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/55"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이지훈",
    "feedback": "지훈님 회고가 엄청 알차네요!\n한 주를 어떻게 보내셨는지 가늠할 수 있는 좋은 자료 인 것 같습니다. 고생하셨어요 ㅎㅎ \n과제에 대해서는 명확하게 필요한 부분 잘 작성해주셨고 문서에 남겨주신 것들 살펴보면 알 수 있듯이 할 수 있는 여러 고민들에 대해 답변도 구체적으로 남겨져 있고 함께 성장하려고 하시는 모습도 너무 좋네요. (특히 정석님에 대한 그..)\n\n코드 품질 부분에서 이야기를 주시기도 했고 질문 주신 함수 성능 최적화 시점에 대한 최적화 부분을 먼저 답변드려보면요.\n\n먼저 중요할 수 있는 로직 부분이니 이미 알고 있는 여러 지식들도 활용하는 것 좋았습니다. 다만, 개인적인 관점으로 약간 얘기를 다르게 해보면 최적화 관점에서 필요한 부분은 맞지만, 이슈가 발생한 지점이 있었는지 궁금하긴해요! \n실제 브라우저에서 제공하는 API를 사용하지 않고 직접 구현해서 사용한다면 해당 부분에 대해 명확한 이슈가 발생하고 나서 수정을 하는 것도 늦지 않거든요 ㅎㅎ 말씀해주신 것처럼 브라우저에서 해당 이슈를 인지하고 속도를 빠르게 하는 최적화를 하고 있다면 관리적 이슈가 늘어나는 부분이니까요. 절대 지금의 코드가 잘못되었다는 것은 아니지만, 우리가 최적화를 하는 시점에 대해서는 고민을 해보는것도 추후에 좋지 않을까! 싶긴 합니다. \n\n우리가 원칙으로 알고 있는 것처럼 섣부른 최적화는 실제 앱에 성능이 되지 않고 가독성이 안좋아지는 결과를 낳으니까요.  그대로 사용한다면 가독성 측면에서도 유리해지는 지점도 있으니까 그런 부분을 함께 챙겨주시면 좋을 것 같습니다. (아무튼 접근은 좋았습니다!)\n\n> 위임 환경 구현\n\n이 부분도 사실은 최적화 시점에 관련된 이야기 인 것 같은데요.\n이미 정답을 추측해보실 수 있는것처럼, 지훈님이 작성해주신 이 프레임워크가 만약 '쇼핑몰이 아닌 여러 곳에서 사용할 수 있는 가능성이 있다' 라는 관점의 개발일지 '쇼핑몰에 적합한 프레임워크다'라는 관점으로 접근할 지가 필요할 것 같아요. 만약 전자라면 범용적인 시나리오에 모두 적합한 최적화 방식을 선택해야 하고, 쇼핑몰에서만 사용해야 한다면 지금은 등록은 적고, 발생은 빈번하기 때문에 발생 했을 때 어떻게 유리하게 처리할 수 있는지 시간복잡도를 계산하고 사용한다면 좋지 않을까 싶네요!\n리액트에서는 fiber tree를 사용해 이벤트 등록 시점에 최적화를 수행하는 것으로 알고 있는데, 이런 관점에서도 한 번 고민해보면 좋을 것 같네요.\n\n> focus 이벤트와 같이 버블링을 지원하지 않는 이벤트의 경우 개별 요소에 이벤트리스너를 설정하는 것과, focusin 처럼 버블링을 지원하는 이벤트로 변경해 위임을 하는 것 어떤 것을 더 선호하시나요?\n\n저희가 별도로 이벤트 시스템을 구축해 관리를 하는 장점이 여기에도 속할 수 있을 것 같은데요. 제가 알고 있기로는 리액트도 내부적으로 해당 이벤트를 위임 가능하도록 매핑해 처리를 하는 것으로 알고 있어요. 동일한 동작을 만들고 이벤트에 대한 구현 일관성을 유지하고 사용자가 사용하기 편하도록 처리할 수 있어서 그런 것 같은데요. 저희의 과제 목표가 리액트와 유사한 구조를 만드는것이니 변경해 위임을 하는 형태로 구현해본다면 더 공부가 될 것 같습니다 ㅎㅎ\n\n고생하셨고 다음 주도 화이팅입니다!!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/18"
    }
  },
  {
    "passed": false,
    "name": "이진희",
    "feedback": "안녕하세요 진희님!\n2주차 과제 진행하느라 고생하셨습니다!!\n다만 심화과제가 아직 진행중이군요.. ㅋㅋ\n시간 되실 때 꼭 한 번 시도해보시면 좋겠어요!\n화이팅입니다!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/64"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "안녕하세요 태님, 수고하셨습니다. 이번 과제는 React의 핵심 원리인 가상 DOM과 diff 알고리즘을 직접 구현해보면서, 프레임워크가 어떻게 효율적인 렌더링을 수행하는지 이해하는 것이 목표였습니다. 특히 이번 과제를 통해 '필요가 공부를 만든다'는 경험을 하셨기를 바랍니다. 단순히 \"가상 DOM이란 무엇인가\"를 읽고 아는 것과, \"가상 DOM을 구현하기 위해 무엇이 필요한가\"를 고민하며 공부하는 것은 완전히 다른 깊이의 학습이니까요.\n\n회고에서 언급하신 대로 용어만 검색하고 구현하려니 막막했다고 하셨는데, AI를 활용해서 코드 한 줄 한 줄의 의미를 파악하며 주석을 달고 학습하신 방법도 참신하고 효과적인 접근이었다 생각합니다. docs/ 폴더에 각 모듈별 가이드를 별도로 정리하고, learning-notes/에 학습 과정을 기록한 점이 인상적이네요.\n\n\"...2주차 과제를 진행하면서 이러한 내용들을 왜? 하는 지에 대한 궁금증이 생겼습니다. 어떠한 부분을 얻어가면 실무적으로 혹은 앞으로의 개발자 인생에서 도움이 되는지? 에 대한 생각이 궁금합니다.\" 에 대한 대답을 드리자면,\n\n인간은 조금 막연하거나 모호해도 대충 그렇다하고 넘어갈 수 있는 능력이 있습니다. 돌 한 무더기라고 했을 때 사실 몇 개부터 무더기인지는 정해져있지도 않는 실제하지 않는 개념이지만 뭔가 떠오르는 그 개념은 있죠. 이러한 능력은 추상화나 우리가 소통을 하기에 요긴하게 쓰이는 능력입니다.\n\n반면 컴퓨터는 다릅니다. 정확히 떨어지는 값과 로직 그리고 숫자를 입력하지 않으면 기대했던 정확한 동작을 하지 않습니다. 개발이 어려운 이유는 인간이 잘 사용하지 않는 사고 방식을 통해서 컴퓨터에게 정확한 동작을 수행하도록 요구하는 것이죠. 그래서 퉁치지 말고 막연하게 말고 \"정확하게\" 지시할 수 있는 능력이 필요합니다.\n\n우리가 추상화가 되어 있는 것을 이해할 때에는 특히 프레임워크같은 것들은 \"정확한\" 내부의 동작이 아니라 이렇게 되어 있겠지 정도만 알아도 쓰는데 아무런 문제가 없습니다. 그래서 알고 있다고 착각하죠. 그러면 딱 그정도의 시각으로 나중에 최적화를 하거나 복잡한 버그가 났을 경우에도 대처를 하게 됩니다.\n\n그래서 내가 어디까지 정확하게 구현을 해낼 수 있는지 그리고 그렇게 정확한 동작을 찾으러 가는 과정에서 기존의 막연한 생각들이 굉장히 선명해지게 됩니다. 내가 알고 있다 느끼는 범위는 전과 같을지라도 머리속에 새겨져 있는 해상도에서 차이가 나는 것이죠.\n\n무엇보다 React를 만드는 능력이 아니라 이러한 구조들을 만들어내는 여러가지 패턴들이 다른 문제를 해결하는 응용력을 길러주게 됩니다. 마치 수학에서 공식을 외우고 있어서 문제를 푸는 것과 공식을 증명할 줄 알고 도출해내는 원리를 알고 있는 것과의 차이 같은거죠.\n\n그래서 직접 해보는 것을 권합니다. 정답이 있는 코드의 경우 AI가 금세 정답을 주면 그걸 보고 공부하는건 역시 그냥 막연하게 이해하고 넘어가게 됩니다. 뇌는 필요하다 느끼지 않으면 그 이상의 에너지를 투자하지 않아요. 꼼꼼하게 주석을 달고 공부를 했다고 생각했지만 만약 머리속에 남아있는게 선명하지 않다라고 하면 조금 더 필요를 만들어 보는 식의 학습을 해보기를 바랍니다.\n\n너무 너무 수고많았습니다. 10주간의 과제안에서 태영 나름의 해답을 찾기를 바래요. 수고하셨습니다 :)",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/11"
    }
  },
  {
    "passed": false,
    "name": "임규원",
    "feedback": "고생하셨어요 규원님!\n관련해서 회고를 읽어봤는데요.\n\nconstants에서 사용중인 상수같은것들은 여유가 되신다면 명확하게 타입을 가져와 쓰거나 선언해서 쓰신다면 문제를 찾고 방지하는데 더 좋지 않을까 싶네요 ㅎㅎ\n\n추가로 AI에 의존을 바로 쉽게 하기보다는 나만의 흐름을 만들고 명확하게 코드 작성에 들어가면 좋을 것 같아요! (사실 나만의 흐름을 만드는 것도 AI의 도움을 받아 명확하게 머리에서 정리할 수 있겠죠? 다이어그램을 만든다거나 작업의 절차를 주석 또는 체크리스트로 만든다거나 하면서요)\n\n아쉽게 심화과제를 마무리 하지 못하셨는데 꼭 마무리 잘하시고 담주도 잘 해내시길 바랍니다. 화이팅입니다!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/41"
    }
  },
  {
    "passed": true,
    "name": "임두현",
    "feedback": "두현님 한 주 고생 많으셨어요~\n작성해주신 회고 잘 읽었고 덕분에 저도 고민의 흔적들을 따라가볼수 있어서 좋았네요! 직접적으로 지침을 넣어서 명확한 학습방향을 만드시고 공부하셨던 것도 좋았던 것 같습니다. \n\nPR에 남겨주셨던 궁금하셨던 내용 이야기를 이어서 해보면요.\n\n> 단순히 가독성 복잡도뿐이 아니라, 테스트 가능성, 유지보수성, 팀 개발 관점에서 함수 분리의 기준과 시점을 어떻게 판단하시는지, 그리고 과도한 분리로 인한 코드 파편화를 방지하는 방법에 대해 의견을 듣고 싶습니다.\n\n여러 원칙들과 선배들이 이야기 한 규칙들이 있겠지만, 사실 정답은 없는 것 같아요. 우리들은 깔끔한 코드를 명확한 규칙 내에 정리되게 작성하고 싶어하지만 현실에서는 그런 코드를 작성하는게 사실상 불가능하거든요. \n그럼에도 개인적으로 이런 분리, 추상화 고민이 들때는 재사용이 실제로 발생하는 시점이 임박하거나 실제로 상상속에서 벌어지고만 있다면 구현하지 않는 편인것 같아요. 그리고 실제로 사용하게 되더라도 중복으로 구현되도록(복사를 아마 하겠죠?) 사용한 다음 주석으로 명확하게 개선이 필요하다고 남기고 추후에 별도 작업으로 분리해서 테스트와 함께 검증하면서 해결하는 편입니다. 내가 아무리 확실한 미래일지라도 상상하는 그 미래 상황에 맞춰 구현을 하고 코드를 나누다보면 늘 문제가 생기고 확장성이 사라졌던 것 같아요. 필요한 만큼 현재 시점에 맞게 딱 그정도만 구현을 한다음 필요해지면 더 구현해나가면 되지 않을 까 싶습니다 ㅎㅎ 모든 규칙에 있어서요. \n\n고생하셨고 다음 주 과제도 화이팅입니다!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/30"
    }
  },
  {
    "passed": false,
    "name": "장루빈",
    "feedback": "루빈님 고생하셨어요~\n커밋로그를 보니 그간 꽤나 힘든 시간을 보낸걸 함께 느낄수 있었는데요..\n아쉽게 전체적으로 추가 구현이 필요한 부분들이 아직은 많이 남아있는 것 같아요. 다른 분들 잘 구현하신 분들 코드도 살펴보시고 질문해보면서 구현 꼭 끝까지 마무리해보셨으면 좋겠네요.\n\n고생하셨고 다음 주에는 꼭 통과하는걸 목표로 하시죠! 화이팅입니다~",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/59"
    }
  },
  {
    "passed": true,
    "name": "장희진",
    "feedback": "안녕하세요 희진, 수고하셨습니다. 이번 과제는 React의 핵심 원리인 Virtual DOM과 diff 알고리즘을 직접 구현해보면서, 프레임워크가 어떻게 효율적인 렌더링을 수행하는지 체득하는 것이 목표였습니다. 특히 \"Virtual DOM이 무엇인가\"를 단순히 아는 것과 \"Virtual DOM을 구현하기 위해 무엇이 필요한가\"를 직접 경험하며 깊이 있는 학습을 하기 위한 방법을 익히는 것에 의의를 느꼈기를 바래요.\n\n코드를 살펴보니 특히 이벤트 위임 시스템을 WeakMap + Set 조합으로 구현하신 점이 인상적입니다. 메모리 관리를 위해 WeakMap을 선택하고, 중복 이벤트 리스너 문제를 allEvents Set으로 해결한 것은 깊이 있는 이해를 보여줍니다. 또한 boolean 속성(checked, disabled 등)을 property로 처리하면서도 필요한 경우 attribute도 함께 관리하는 세심한 구현도 잘했습니다!\n\n이렇게 직접 프레임워크의 핵심을 구현해보면 이론적 지식이 아닌 구조적 이해를 얻게 됩니다. 앞으로도 이런 방식으로 사용하는 도구의 원리를 파헤쳐보는 경험을 이어가시길 바랍니다. 너무 너무 잘했습니다!!\n\n---\n\nQ) 이벤트 위임 구조의 성능 및 개선점\n\n=> 현재 구현하신 WeakMap + Set + 이벤트 위임 조합은 메모리 관리와 성능 면에서 매우 좋은 패턴입니다. React도 유사한 방식을 사용하고 있죠. \n\nbubbling 경로의 성능 우려에 대해서는, 실제로 DOM 트리가 매우 깊거나(100+ depth) 이벤트가 매우 빈번한 경우(mousemove 등)가 아니라면 사실 큰 문제는 되지 않습니다. 이미 React도 그렇게 쓰고 있잖아요ㅎ\n\n그리고 현재는 모든 이벤트 타입을 root에 등록하는데, 실제 사용되는 이벤트만 동적으로 등록방법도 한번 고민해보면 좋겠네요.\n\n핵심 원리를 직접 구현하면서 원리를 이해하는 것이 더 선명해지는 경험을 했기를 바랍니다. \n\n수고하셨습니다. 다음 주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/24"
    }
  },
  {
    "passed": true,
    "name": "정건휘",
    "feedback": "Q. 이 과제에 이어 조금 더 공부해보면 좋을 것이 있을까요?\n\nA. 우선 건휘님 대단하십니다. 이런 질문은 받아본적이 없는데요 ㅎㅎ\n그러면 한가지 화두를 던져보겠습니다.\n\n\"리액트 Fiber 가 무엇이고 이 이개념을 내 과제에 최소한으로 적용하려면 어떻게 해야할까?\"\n\n입니다. 좋은 학습이 될 것 같습니다 :) ",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/52"
    }
  },
  {
    "passed": true,
    "name": "정도은",
    "feedback": "안녕하세요 도은님! 2주차 과제 잘 진행해주셨네요!! 너무 고생하셨습니다 ㅎㅎ\n무엇보다 학습 과정과 전체적인 흐름에 대해 정리를 꼼꼼하게 해주셔서 좋았어요! 저도 다시 복습하는 느낌!?\n\n---\n\n> 처음에는 flat(Infinity)를 사용했지만, 배열의 깊이가 2차원으로 고정되어 있는 것 같아 재귀 함수로 다시 구현했습니다. 이처럼 배열의 뎁스를 명확히 알고 있을 경우, flat() 대신 직접 구현하는 방식이 성능면에서 더 좋을까요... 차이가 미미하다면 가독성을 우선하는 게 더 나을 것 같은데 일반적으로 어느 정도를 \"미미하다\"고 보는지도 궁금합니다.\n\n2차원으로 고정되어있진 않답니다 ㅎㅎ 배열안에 배열이 있을수도 있어서요.\n구현해주신 내용이 flat 내부에 그대로 표현되어 있지 않을까요!?\n그래서 가독성과 성능 모두 flat(Infinity) 를 사용하는게 더 좋다고 생각해요.\n무엇보다 native api를 사용해야 브라우저가 업데이트 될 때 자연스럽게 내부 로직도 개선이 되고 성능도 자연스럽게 좋아질 수 있답니다!\n\n다만, 이와는 별개로 직접 구현하는 과정도 중요하다고 생각해요. 저희는 \"학습\"을 하고 있기 때문이죠!\n\n> normalizeVNode: 앞단에서도 filter(Boolean) 처리를 해주는 부분이 많았고 이 시점에서 추가로 필터링하지 않아도 된다고 생각했는데 이 코드를 추가하자 테스트가 통과했습니다. 왜 이 필터링이 필요한 건지, 어떤 값이 false 처리되어 걸러지는지 정확히 이해하지 못하겠습니다… 혹시 어떤 케이스 때문에 이런 처리가 꼭 필요한 걸까요?\n\n흠... 그러게요 ㅋㅋ 제가 작성한 솔루션에서도 똑같은데요,\ne2e:ui로 확인해보면 없어져야할 콘텐츠가 아직 남아있는 등의 문제가 있어요.\n궁금해서 조금 디버깅을 해보니까\n\n대략 이런 상황인데요,\n\nfilter를 하지 않을 때는 비어있는 text node를 하나 만들게 됩니다.\n> children: [\"\", vnode, \"\", vnode, \"\", vnode, ...] \n\nfilter를 하면 빈 노드를 제거합니다.\n> children: [vnode, vnode, vnode, ...] \n\n빈 노드가 만들어지고, 빈 노드로 인한 diff 연산 과정에서 꼬임이 발생하는 것 같아요...! 제가 시간 되면 조금 더 찾아보겠습니다.",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/43"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "정민기",
    "feedback": "안녕하세요 민기님~\n2주차 과제 잘 진행해주셨네요!! 고생하셨습니다.\n다만, 과제 PR을 제출해주셔야 되는데 repo 링크를 제출해주셨네요 ㅋㅋ 다음에는 PR 링크로 제출 부탁드려요!\n\n> 클린코드 관점에서 질문드립니다. createElement 를 구현하면서 뎁스가 길어진다고 생각하여, 함수로 쪼걨는데, 너무많이 쪼갰나 생각이 들었습니다. 이런식으로 하는게 괜찮은 방법일까요? 아니면 추가적으로 보완해야한다면 어떤식으로해야할지 질문드립니다..\n\n오 ㅋㅋㅋ 저는 이런 방식을 더 선호하는 편입니다.\n이걸 저는 \"코드의 추상화 수준을 맞춘다\" 라고 표현하곤 해요. 코드를 읽을 때 가독성이 훨씬 좋아지고, 함수의 이름을 통해 어떤 동작을 하는지 예측이 쉬워지는 효과가 있어요!\n\n조금 더 나아가자면, 이렇게 표현할 수 있도록 함수를 하나 더 만들면 좋지않을까 싶네요!\n\n```tsx\nexport function createElement = pipe(\n  [isNullOrBoolean, createEmptyTextNode],\n  [isPrimitive, createTextNode],\n  [Array.isArray, createFragmentFromArray],\n  createElementFromVNode, // 혹은 [()=> true, createElementFromVNode]\n)\n```\n\n저는 이런걸 \"선언형 프로그래밍으로 만들었다\"고 표현해요. if, for 같은 코드 대신 함수로 최대한 랩핑하여 코드가 어떤 형태를 갖춰야 하는지 선언하는거죠 ㅎㅎ\n\n---\n\n고생하셨습니다~!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/13"
    }
  },
  {
    "passed": true,
    "name": "정유열",
    "feedback": "안녕하세요 유열님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다.\n\n> 테스트의 존재와 미리 명확하게 모듈을 나누어주신 구조로 인해 AI 사용 시 과제를 꽤 쉽게 완료하는 경우가 많을 수도 있겠다는 생각이 들었습니다.\n\n반대로 생각하면, \"이런 구조가 있으면 AI가 문제를 해결하기 쉽겠는데?\" 라고 판단하고 앞으로 AI를 더 잘 활용하는 방법에 대한 인사이트가 되리라 생각해요. 이제는 AI를 활용해야 하는 시대라서... ㅋㅋ\n\n\n> 각각의 모듈 구현에 집중하면 되는 과제이다보니 의도적으로 프로젝트 전체를 파악하려는 노력을 하지 않는다면 학습하길 의도하신 전체 흐름을 이해하지 못하고 넘어가는 수강생도 존재할 것 같습니다.\n\n이 부분도 고민이 되는 지점 중에 하나인데요, 원래 이전 기수에는 새로운 기능을 추가하는 요구사항이 있었으나... 지난주 과제에 대한 피로도가 쌓여있으리라 생각하여 일부로 제외했답니다 ㅎㅎ\n\n다음에는 꼭 넣어봐야겠어요!\n\n>1. 이벤트 매니저에서 이벤트를 저장하고 사용하기 위해 채택한 자료구조의 활용이 적절한가\n\nWeakMap, Map, Set 등 다양하게 사용해주셨네요! \n다만 Map의 key가 string이여서, 굳이 Map을 사용할필요가 있을까? 라는 생각이 들어요. 단순 객체로 표현할 수도 있고..!?\n\n> 2. 불필요한 재귀나 리소스를 낭비할만한 플로우가 보였는가\n\n쓱 살펴봤을 땐 크게 문제되는 부분은 없어보이네요!\n\n> 3. 최대한 과제에 충실한 기능만 구현, 오버엔지니어링 되는 요소들을 분별해가며 제한적으로 구현했는데 실제로도 그러한가\n\n실무와 학습은 다를 수 있다고 생각해요.\n실무에서는 효과적인 방식을 채택해야 하고,\n학습에서는 효과적인 방식이 중요한게 아니라 많은 지식과 판단 근거를 습득하는게 중요해서요. 그래서 오버엔지니어링도 시도해보시면 좋답니다 ㅎㅎ\n\n> 변수명, 타입명, 주석 대신 가독성 좋은 코드 작성(학습용 주석 제외)을 지향하면서 과제를 수행하고 있습니다. 아쉬운 부분이 있다면 알려주시면 감사하겠습니다.\n\n질문해주신 것들이 다 포괄적인거라... 유열님이 작성한 코드나 생각의 흐름을 코드에 직접 코멘트를 남겨주시거나 하면 더 좋았을 것 같아요 ㅠㅠ\n\n특히, 가독성 좋은 코드를 지향한다고 하셨는데 \"이렇게 작성하면 가독성이 좋아! 이유는 ~~~ 라서 그래!\" 라는 형태의 의견이 있으면 좋을 것 같아요.\n지금은 \"무슨 의도로 이렇게 한걸까?\" 라고 제가 추측하면서 봐야 한답니다.. 시간이 몇배는 소모되는거죠 ㅎㅎ;\n\n",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/6"
    }
  },
  {
    "passed": true,
    "name": "조영민",
    "feedback": "안녕하세요 영민, 수고했습니다! 이번 과제는 React의 핵심 원리인 가상 DOM과 diff 알고리즘을 직접 구현해보면서 프레임워크가 어떻게 효율적인 렌더링을 수행하는지 이해하는 것이 목표였습니다. 특히 이론으로만 알던 Virtual DOM을 실제로 구현하면서 '필요가 공부를 만든다'는 경험을 하셨기를 바랍니다.\n\nVirtual DOM의 전체 흐름(createVNode → normalizeVNode → createElement → renderElement)을 잘 이해하고 구현하셨네요. 잘했습니다.\n\n회고에서 실력 부족을 느끼신다고 하셨는데, 쉬운 과제 아닙니다. 저희 쉬운 과제 준다고 한적 없었잖아요. ㅎㅎ 오히려 이렇게 어려운 개념을 직접 구현해내신 것만으로도 충분한 성장을 하고 있는거에요. 실력 부족을 느낀게 아니라 나 이제 여기까지 왔구나라고 생각해보세요. 처음이라 어렵지 두번하면 금방입니다. \n\n이제 Virtual DOM의 원리를 체득하셨으니, React를 사용할 때도 내부에서 어떤 일이 일어나는지 더 잘 이해하실 수 있을 거예요. 다음 주차도 화이팅입니다! :)",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/53"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "주산들",
    "feedback": "안녕하세요 산들! 수고많았습니다. 이번 과제는 Virtual DOM의 작동 원리를 머리가 아닌 손으로 직접 구현하며 체득하는 것이 목표였습니다. 회고에서 \"개념과 흐름은 알겠는데 코드로 녹여내는 것이 까다로웠다\"고 했던 부분이 이번 과제의 진짜 의도였죠. 사람은 적당히 이런거겠네 하면서 모호한것도 안다고 착각하고 넘어가는데 컴퓨터는 아니죠. 그렇기에 깊이를 탐구하기 위해서는 지금처럼 직접 구현하고 직접 완성을 해봐야 하는거죠. 아주 잘했습니다.\n\n디버깅하며 고생하셨다고 하셨는데, 특히 `updateElement`에서 oldChildren.length > newChildren.length일 때 추가 for문이 필요한지 고민하신 과정도 참 좋아보입니다. 특히 이번 회고들이 정말로 경험에서 고민해본게 느껴져서 너무 좋았어요. 이런 세세한 고민들이 Virtual DOM의 원리를 체득하는 과정입니다.\n\n몇 가지 추가로 개선을 시도해보면 좋겠다 하는 부분들은,\n\n1) 텍스트 노드 비교시 createElement로 변환 후 nodeType을 체크하는 현재 방식보다 그냥 `typeof newNode === 'string'`으로 직접 체크하는 것이 효율적인거 맞습니다.\n\n2) 지금 이벤트 관리를 배열로 관리하고 있는데 key를 string이 아닌 것으로 매칭을 할때에는 Map을 사용하면 findIndex의 O(n) 탐색을 O(1)로 개선할 수 있습니다. 그리고 이때 key가 DOM이 되는 경우에는 WeakMap을 써야합니다. 그래야 key가 더 이상 쓰이지 않을때 자동으로 key를 같이 해제를 해주니까요.\n\n3) setupEventListeners의 경우 당연히 모든 이벤트를 하드코딩을 하는 것보다는 나은 방법이 있겠죠. 이런 경우에는 필요할 때 필요한 만큼 동적으로 만들어 보는 방향으로 고민을 해보면 좋겠죠. addEvent에서 사용된 이벤트만 Set에 모아 동적으로 등록하는 방식을 통해서 확장성있게 만들어 낼 수 있습니다.\n\n수고하셨습니다. 다음 주차도 화이팅입니다! :)\n\n\nBP 선정이유: 사실 정답이 이미 있는 문제인데 과제의 취지에 맞게 필요한 것들을 몸으로 부딫혀가면서 이해도를 선명하게 만들어가는 경험을 잘 한것 같아서 그 경험을 높게 삽니다.",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/38"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "최용훈",
    "feedback": "Q. eventManager를 어떤식으로 접근하는게 효율적인 방식인지에 대한 의문이 있습니다. WeakMap의 경우 Map과 다르게 유용한 프로토타입 메서드가 없는데, 차라리 Map으로 순회 메서드 등을 사용하는게 오히려 효과적일지 생각했습니다.\n\nA. 불필요한 이벤트를 제대로 제거할 수만 있다면 말씀하셨던대로 Map이나 그어떤 자료구조도 문제 없을 것 같습니다.\n이런 고민은 참 좋은 것 같습니다 :) 효율적인 자료구조에 대한 고민은 어떤 모듈이던 우선적으로 고려해야할 것중 하나인 것 같습니다.\n수고하셨습니다 용훈님!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/29"
    }
  },
  {
    "passed": true,
    "name": "최재환",
    "feedback": "재환님 고생하셨습니다~\n회고를 보니 한 주 잘보내셨던것 같네요.\n작성해주신것처럼 AI를 통해 도움을 받으셨지만, 실제 구조에 대한 다이어그램도 그려보시고 더 명확하게 구조를 그려보시면 추후에 더 도움이 많이 되실 것 같네요!\n\n> updateElement의 diff 알고리즘 구조\n\n실제 지금의 구조도 재조정과 유사한 로직일텐데요! \n이제부터는 최적화의 영역일 것 같은데, 리액트 내부에서 key를 기반으로 비교를 진행하는 부분을 구현해본다거나, 참조를 기반으로 diff비교를 스킵하는 부분이 리액트 내부에 구현이 되어 있어 비교를 최적화 한다고 알고 있는데 이 부분도 공부해보시면 좋을것 같아요!\n\n그리고 아마 업데이트에 있어서도 실제 구현 방법이 배치 형태로 되어 있을텐데 그런 부분도 한번 공부해보시면 도움이 될 것 같습니다.\n\n> createElement의 재귀 구조와 함수 분리\n\n이 부분도 지금의 과제에 맞춰서는 명확하게 잘 정리해주신것 같아요!\n여러가지 패턴을 적용해서 여러 타입의 노드를 구분한다거나 등의 처리는 해볼 수 있겠지만, 지금 단계에서는 크게 불필요 해보이네요 ㅎㅎ\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/54"
    }
  },
  {
    "passed": true,
    "name": "한아름",
    "feedback": "안녕하세요 아름! 수고하셨습니다. :) 이번 과제는 가상돔의 원리를 이론이 아닌 직접 직접 구현해보며 렌더링 최적화와 이벤트 처리의 핵심을 깊이 있게 탐구하는 것이 이번 과제의 의도였어요. 이 과제를 통해 프레임워크의 동작 방식을 몸으로 체득하는 경험을 그리고 깊이를 공부하는 방법을 알게 되는 계기가 되었기를 바랍니다.\n\n회고에서 적어준 이벤트 버블링 문제등에서 event.target만 확인하는 단순한 방식으로 구현하셨다가, 페이지 라우트 테스트 실패를 통해 문제를 발견하고 while문으로 부모 요소를 순회하며 핸들러를 찾는 로직으로 개선하는 등 이러한 접근 과정을 통해서 순회나 실제 이벤트의 동작원리등이 더 선명해졌으리라 생각합니다. 잘했어요.\n\nupdateElement에서 boolean 속성 처리 시 setAttribute(attr, \"\")가 아닌 target[attr] = value 방식으로 직접 업데이트해야 한다는 것을 발견하신 것도 DOM API의 세밀한 차이를 잘 파악하신 결과라 생각합니다.\n\n코드 리뷰등을 통해서 알게된 느슨한 비교등으로 더 적은 횟수의 비교를 쓰게 하는 것들도 저수준 라이브러리에서 중요한 내용이죠. createVNode의 children 필터링도 filter(x => x || x === 0)로 단순화할 수도 있겠습니다.\n\n\"필요가 공부를 만든다\"는 말처럼, 직접 구현해야 하는 상황에서 학습한 내용이 가장 오래 남는 법입니다. 이제 가상 DOM을 직접 만들어본 경험이 있으니, 앞으로 리액트나 뷰를 사용할 때도 내부에서 무슨 일이 일어나는지 더 잘 이해하실 수 있을 거예요. 다음 주차도 화이팅입니다! :)\n\n질문하신 내용에 대해서는 아름이 생각했던 그 방식들 다 맞는 방식입니다. 잘했습니다.",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/49"
    }
  },
  {
    "passed": true,
    "name": "허정석",
    "feedback": "정석님 기대하고 있었습니다.\n역시 기대한 만큼 필요한 부분들에 대해서 명확하게 코드로 잘 옮겨주신 것 같네요. 멋지십니다. 작성해주신 회고도 매우 인상깊었는데요. 볼드체로 작성해주신것처럼 과제를 하는데 있어서 뿐만 아니라 개발 업무 전반에 있어서 명확한 목적과 해결 과정을 러프하게나마 미리 정리하고 진행하는게 매우 생산성, 정확성에 있어서 중요하다고 생각해요. \n항해에서 공부를 계속 해나가심에 따라 여러 도구를 획득하게 되실텐데요. 결국 가장 중요한건 이 도구를 잘 습득했다가 전부가 아니라 정석님이 회사에 가셔서 이 도구들을 잘 활용하는거지 않을까 싶습니다.\n요런것들도 사실 연습이 필요한 부분이니까 매 과제과제마다 잘 챙겨주시면 좋을것 같아요.\n\n질문 주신거 이어서 답변 드려보면요.\n\n> AI의 답변을 단순히 수용하지 않고, 나만의 것으로 만들려면 어떤 질문을 던져야 할까?\n\n가장 먼저 해야할건 이 문제에 대해서 내 머리속에서 어느정도 구현을 해야 하는지 직접 계획을 세우고 검토해보는것 같아요. AI로 문제를 풀때도 동일하게요. 이 과정이 어느정도 내 기준에 납득이 되고 난 뒤에 작업이 진행이 되어야 코드의 일관성이나 문제를 푸는 방식이 일치가 되고 추후에 고치는 작업도 줄게 되는 것 같아요.  작업의 퀄리티와도 연결되는 부분이겠지만, 각 해당되는 작업들의 명확한 계획을 이야기를 들어보고 그 작업을 선별한 다음에 진행을 하는 것도 방법일 것 같구요! 다른 분들이 하시는 것처럼 코드의 구현을 어느정도 개입해서 주석 형태로 작성을 한 다음 코드 작성을 맡겨보는 것도 방법일 것 같구요.\n\n개인적으로는 맥락은 프로젝트 전체를 이 부분에 있어서 너무 작업범위를 제안 받기보다는 작은 범위범위에 대해 작업을 진행하는 것이 좋은 것 같아요. 명확한 검증 후에 실제 코드로 반영하는 사이클을 만드는게 좋다고 생각하는 편인 것 같습니다. \n\n두번째 질문으로 FE 구현을 막혔을 때 라고 해주셨는데요. FE 구현은 명확한 화면이 있다보니 멀티 모달 즉, 이미지같은것들을 최대한 활용해보는게 저는 좋더라구요. 글로 문제 상황을 전달하다보면 내 언어적인 문제도 명확하게 있다보니.. 여러번 반복해서 설명을 하는 것보다는 이미지로 딱 전달을 하는게 퀄리티 있는 답변을 얻는데 도움이 많이 되었던 것 같아요 ㅎㅎ 사용을 해보시면 좋을것 같습니다.\n\n고생하셨고 다음주도 화이팅입니다 정석님 지켜볼게요",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/31"
    }
  },
  {
    "passed": true,
    "name": "현지수",
    "feedback": "안녕하세요 지수님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ\n현재 PR에 특별한 질문이 없는 상태, 궁금한게 있으면 언제든 문의채널에 남겨주세요!! 고생하셨습니다!\n\n---\n\n세상에 ㅋㅋㅋ 정리를 너무 잘 해주셨네요. 이대로 미리 제줄해주셨으면 BP 예약이었을텐데 ㅠㅠ 아쉬워요\n\n> 현재 과제 수준에서 키 기반 diff 알고리즘 구현이 필요한지, 아니면 인덱스 기반으로도 충분한지 궁금합니다.\n\n현재 과제의 목표는 리액트의 렌더링 시스템을 맛보는 것이었어요 ㅎㅎ\n그래서 지금 수준으로도 충분하다고 생각합니다.\n\n> 만약 키 기반 구현이 필요하다면, 어떤 우선순위로 접근하는 것이 좋을까요?\n\nchildren에 대해 updateElement를 수행할 때, children의 key를 토대로 위치를 탐색해서 리렌더링에 대한 결정을 해야하지 않을까 싶네요!\n\n다만 구현해봐야 알 것 같아요 ㅋㅋ 제 스스로가 구현하기 전에는 잘 모르는 게 많아서.. ㅠㅠ.. 확신은 없네요.\n\n> 성능 개선을 위해 updateAttributes 함수를 헬퍼 함수로 분리했습니다. 이런 함수 분리 방식이 적절한지 궁금해요!\n\n충분히 잘 해주셨다고 생각해요! 다만 실제로 얼마나 성능 개선이 되었는지는 측정을 해봐야 알 것 같네요!\n\n> 대규모 애플리케이션에서 eventMap이 메모리 누수의 원인이 될 가능성은 없을까요? WeakMap 사용을 고려해야 하는 상황이 있을까요?\n\nmap으로만 관리하는 경우, map에 등록된 key가 의도하지 않게 사라졌을 때 어떻게 해야 좋을지 고민해보시면 좋답니다 ㅎㅎ 이를 위해서 weakmap이 있는거라서요.\n\n정상적인 로직만 수행하면 문제될게 없겠으나... 우리가 설계한 것과 다르게 돔을 조작하는 경우, 가령 setState 같은 함수가 아니라 직접적으로 돔을 없애는 경우에는 돔에 대한 이벤트 트리거가 제거되지 않을수도 있답니다!\n\n> Boolean 속성 처리의 브라우저 호환성\n\n제일 좋은건 다룰 수 있는 모든 property에 대해 정의해서 사용하는거라고 생각해요. 창준님께서 남겨주신 리뷰가 제 생각과 맞닿아있네요!\n\n모든 브라우저에서 안전한지는 돌려봐야 알 것 같아요 ㅋㅋ 처음부터 모든 이슈를 찾아내면 좋겠지만, 현실적으로 불가능에 가까워서 문제가 있을 때 빠르게 찾아낼 수 있는 장치를 만드는게 좋다고 생각해요.\n\n\"이게 모든 브라우저에 호환이 될까?\"가 아니라 \"호환이 안 되면 어떻게 찾아내야 좋을까?\" 로 접근하는게 좋다고 생각합니다.\n\n",
    "assignment": {
      "name": "STEP04 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-2/pull/47"
    }
  },
  {
    "passed": true,
    "name": "강병준",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/12"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "권지호",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/3"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/18"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/34"
    }
  },
  {
    "passed": true,
    "name": "김소희",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/41"
    }
  },
  {
    "passed": true,
    "name": "김수민",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/50"
    }
  },
  {
    "passed": true,
    "name": "김수현",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/35"
    }
  },
  {
    "passed": false,
    "name": "김연수",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/58"
    }
  },
  {
    "passed": true,
    "name": "김유현",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/22"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/48"
    }
  },
  {
    "passed": true,
    "name": "김효진",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/30"
    }
  },
  {
    "passed": true,
    "name": "김휘린",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/38"
    }
  },
  {
    "passed": true,
    "name": "박상수",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/59"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/6"
    }
  },
  {
    "passed": false,
    "name": "박의근",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박준형",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/26"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박창준",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/20"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "신홍준",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/2"
    }
  },
  {
    "passed": true,
    "name": "신희원",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/28"
    }
  },
  {
    "passed": true,
    "name": "양성진",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/46"
    }
  },
  {
    "passed": true,
    "name": "양창훈",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/57"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "여진석",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/29"
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/37"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "오하늘",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/24"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/10"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "윤영서",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/13"
    }
  },
  {
    "passed": true,
    "name": "이가은",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/31"
    }
  },
  {
    "passed": true,
    "name": "이민재",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/25"
    }
  },
  {
    "passed": true,
    "name": "이유진",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/32"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이은지",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/49"
    }
  },
  {
    "passed": true,
    "name": "이의찬",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/36"
    }
  },
  {
    "passed": true,
    "name": "이정우",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/52"
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/17"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/14"
    }
  },
  {
    "passed": true,
    "name": "이진희",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/7"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/16"
    }
  },
  {
    "passed": true,
    "name": "임규원",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/39"
    }
  },
  {
    "passed": true,
    "name": "임두현",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/45"
    }
  },
  {
    "passed": true,
    "name": "장루빈",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/54"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "장희진",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/27"
    }
  },
  {
    "passed": true,
    "name": "정건휘",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/44"
    }
  },
  {
    "passed": true,
    "name": "정도은",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/9"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "정민기",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/8"
    }
  },
  {
    "passed": true,
    "name": "정유열",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/15"
    }
  },
  {
    "passed": true,
    "name": "조영민",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/43"
    }
  },
  {
    "passed": true,
    "name": "주산들",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/33"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "최용훈",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/11"
    }
  },
  {
    "passed": true,
    "name": "최재환",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/56"
    }
  },
  {
    "passed": true,
    "name": "한아름",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/55"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "허정석",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/19"
    }
  },
  {
    "passed": true,
    "name": "현지수",
    "feedback": "",
    "assignment": {
      "name": "STEP05 JS & React 딥다이브 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/42"
    }
  },
  {
    "passed": true,
    "name": "강병준",
    "feedback": "Q. shallowEquals와 deepEquals의 요구사항에서 주어진 (1) 두 값이 정확히 동일한지, (2) 객체가 아닌 경우 처리, … 등의 케이스에 대해서는 굳이 다루지 않더라도 a, b 매개변수가 객체가 아니라면 결국 return 문에서 값과 타입을 함께 비교하지 않아도 된다고 생각하여 추가하지 않았는데 적절한 판단일까요?\n\nA. 내용을 보면 커버가 가능할 수 있지만 몇몇 케이스를 놓치는 부분도 있는 것 같아요 물론 다른 코드에 의해서 해결될 수 있지만 두값이 NaN인 경우 false가 나올 수도 있을 것 같아요.\n일부 코드가 간결할 수 있지만 정확히 모든 상황을 커버하는지는 좀 살펴봐야할 것 같아욥\n\nQ. AI를 잘 활용하는 방법은 AI에게 모든 것을 맡기는 것이 아닌, 내가 생각하지 못한 것을 함께 고민하고 지식을 확장하는 도구로서 생각하고 이번 과제를 진행하였습니다. 다만, 이번 과제에서 AI를 조금은 소극적으로 사용한 것이라는 생각이 드는 것 같습니다. 제가 제대로 과제를 수행한 게 맞을까요?\n\nA. 저는 병준님의 사용법이 맞다고 생각합니다. 움 코치분들 마다 생각은 다를 수 있겠지만 저는 이번 항해의 목표가 바이브 코딩 보다는 FE 딥다이브라고 생각합니다. 궁금한 것을 물어보되 되도록이면 수강생이 충분히 이해하면서 직접 코딩하는 게 많을수록 배워가는 것이 많을거라 생각합니다.\nFE 딥다이브를 이번항해로 배우고 바이브 코딩과 인공지능의 활용은 별도로 학습해야하지 않을까 싶어요..",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/12"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "권지호",
    "feedback": "안녕하세요 지호, 수고하셨습니다! 이번 과제는 React의 내장 훅들을 직접 구현해보면서 프레임워크가 어떻게 상태를 관리하고 최적화하는지 이론을 넘어 몸으로 깊이 이해하는 것이 목표였습니다.\n\n취업 준비와 과제를 병행하는거 쉽지 않을텐데 적절한 몰입을 위한 스위칭을 고민하다니 대단해요. 선택과 집중은 중요하지만 그렇다고 하나에만 몰빵(?)하는건 올바른 집중이 아니니까요. 몰입에는 정해진 시간이 있으니 적절히 스위칭을 하는건 도움이 되죠. \n\n또한 \"AI 없이 직접 고민하고 실험해보는\" 접근 방식을 택하신 점이 정말 인상적입니다. 회고에서 적어둔 useAutoCallback과 useEffect등을 직접 고민해본 부분은 다른 항해친구들에게도 많은 인사이트가 될거에요!\n\ncompareObjectProperties를 따로 만들어서 equals 함수들의 중복을 제거하는 부분이나 memo 구조를 ref로 깔끔하게 구현한 부분도 좋았습니다.\n\n\"모든 값에 useMemo를 쓸까?\"라는 질문은 React를 하면서 내내 고민을 하게 될 부분인테 이번 기회에 충분히 고민을 해보게 된 것 같아 기쁘네요. 수고 많았습니다!\n\n---\n\nQ) useMemo를 사용하다보니 관련된 다른 함수들의 참조도 함께 메모이제이션하게 되어 결국 모든 함수들을 메모이제이션하게 되었는데, 이게 맞나? 라는 생각이 들었습니다.\nuseState의 초기화 함수를 사용하는 방식이 그런 면에서는 조금 더 직관적이고 간단한(?) 방법이 될수도 있을 것 같습니다. 이 부분에 대해서 코치님의 의견은 어떠신가요?!\n=> useMemo를 하나 쓰게 되면 다 써야 되는게 맞죠. 발제시간에도 말씀드렸지만 그래서 다쓰자파와 격리하고 컴포넌트 수준에서 메모하자로 나눠지곤 합니다. 아니면 상태관리 도구에서는 자체 memo기능을 제공하기고 하구요. 지금 과제의 경우에는 지금 지호가 한 걱처럼 useMemo을 다쓰는 방식을 해야겠네요.\n\nQ) 저는 리액트에서 적절한 추상화의 경계를 나누는 것(?)이 어렵게 느껴지는데, \"추상화 레벨\"이라는 것을 잘 나누는 기준이 있을까요?\n=> 추상화는 어렵지만 사람이 말할때에는 자연스럽게 추상화를 하고 있습니다. 기능이나 기획을 논할때 \"토스트 팝업을 띄워봐\", \"이럴때 토스트을 3초간 보여주세요.\" 라는 식으로 말하지.  \"토스트 팝업의 값을 true로 바꿔주세요.\" 라고 말하진 않죠. <토스트 팝업 기능> 이라고 말할 수 있기에 추상화가 단위가 되고 <일정 편집>, <일정 삭제> 단위의 추상화와 <일정 관리>의 추상화처럼 이미 반복적으로 표현을 하는 이름단위에서 추상화를 확인할 수 있습니다.\n\n위 코드의 useToastActions 훅의 추상화 레벨은 적절하게 나누어져 있다고 볼 수 있을까요?\n\n=> 그렇죠. 이렇게 생각해주세요. 기획에서 사용하는 용어대로 노출이 되어 있는가?  메시지를, 보이고 하고, 사라지게 하는 것은 반복적으로 표현하면서 그밖에는 별도로 표현하는게 없으니 추상화레벨은 적절합니다.\n\n=> 가령 조금 더 오랫동안 보여주세요. 라던가. 강조해서 빨간색으로 보여주세요라는 요구사항이 왔다면 이부분도 추상화의 영역에 포함을 시켜야겠죠?\n\nQ) 실제로 비즈니스로직과 함께 코드를 구현하다 보면 단일책임을 갖도록 하는것이 어렵다고 생각하는데, 책임을 나누는 눈을 기르고 싶다면 리팩토링이나 코드를 작성할 때 어떤 것을 중심적으로 생각하는게 좋을지 궁금합니다!\n\n=> 결국 정리하면 요구사항, 즉 기획의 언어 중심이라고 생각해주세요. 그게 어렵다면 내가 다른 사람에게 내가 구현한 것들을 비개발자들에게 어떻게 말하고 설명하고 있는지 한번 생각해보세요. 추상화는 인간의 기본적인 습성에서 비록된 개념이기에 (인간은 원래 복잡하고 구체적인 걸 싫어합니다.) 비개발자들이 말하는 곳에서 힌트를 찾을 수 있답니다.\n\n수고하셨습니다. 클린코드 챕터도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/3"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "안녕하세요 민지! 이번 1-3 과제 정말 수고하셨습니다. AI 의존도를 줄이고 \"AI를 튜터처럼 쓰기\"라는 방식으로 과제를 진행했군요! 아주 잘했습니다. 코드를 만들어가는 시행착오를 겪어가며 이해하기를 원했는데 이렇게 직접 구현해보신 과정에서 분명 많은 것을 체득하셨을 거예요.\n\n이번 과제는 React의 내장 훅들을 직접 구현해보면서 프레임워크가 어떻게 상태를 관리하고 최적화하는지 깊이 이해하는 것이 목표였습니다. useState와 useRef가 훅의 근간을 이룬다는 깨달음, 그리고 Context를 상태와 액션으로 분리하여 불필요한 리렌더링을 방지하는 패턴을 경험해보신 점이 특히 좋았습니다. 이런 구조적 사고는 실무에서도 정말 중요한 인사이트예요.\n\nshallowEquals에서 Object.keys를 sort는 비용이 비쌉니다. 직접 키를 순회하며 비교하는 것이 성능상 더 유리해요. deepEquals에서 JSON.stringify를 사용하신 아이디어도 좋지만 이것도 비싼 동작입니다. 운서가 알려준 재귀적 비교가 성능면에서 더 낫습니다. 이러한 시행착오 또한 경험으로 알고나야 정말 내것이 되므로 너무 좋은 시도였다라고 생각해요!\n\n---\n\nQ) 이번에 useCallback와 useAutoCallback에 대해서 구현하면서 생각이 든건데 useCallback은 의존성 배열에서 따라서 새로 참조한다고 이번에 알게 되었는데, 그냥 드는 생각은 의존성 배열 대신에 매개변수로 받아서 useAutoCallback으로 하먄 될 꺼 같은데 왜 useCallback가 생겨났는지에 대한 이해가 잘 되지 않더라구요. 이렇게 함으로써 장점이 있나요? 성능 최적화의 부분으로써는 최악? 이라는 생각이 드는데.. 의존성 배열에 값이 바뀌면 다시 계속 새로 참조해야 하잖아요.\n\n=> 우선 useCallback은 공식적으로 React에서 제공하는 것이고 useAutoCallback은 우리가 한번 만들어본 Custom Hook입니다. \n\nReact는 컴포넌트가 리렌더를 하면 컴포넌트 내부의 모든 useState와 계산 그리고 handler를 새로 만들게 되어 있는데, React에서 최적화라는 건 새로 만들지 않아도 되는 경우에는 기존에 있는 것을 활용하는 방식이죠.\n\n그래서 useCallback와 useMemo등에 의존성 배열을 명시해서 이 값들이 변하지 않으면 새로 만들지 않아도 되니 기존의 값을 재사용해서 최적화 해! 라는 식으로 최적화가 이뤄지게 됩니다.\n\n=> 함수를 새로 생성하는 건 useMemo와 달리 복잡한 계산이 필요없으므로 딱히 비싼 동작이 아닙니다. 사실 useCallback가 더 큰 의미가 생기는 건 이 함수를 자식컴포넌트로 넘길때이죠. 대개 컴포넌트는 props가 변하면 리렌더링이 발생하는데 매번 새로 생성을 하면 최적화가 되지 않겠죠. 그래서 useCallback을 사용하면 기존 값을 그대로 쓸수가 있고, 이를 통해 컴포넌트 최적화가 이뤄집니다.\n\n=> useCallback의 자체적인 최적화 비용은 비싸지 않고 의존성 배열을 입력하는건 귀찮은데다가 실수할 여지도 많으니 항상 새롭게 생성은 하되 기존의 참조값는 전달하도록 해서 자식 컴포넌트에 props로 전달해도 최적화를 할 수 있도록 만든데 useAutoCallback입니다. 이건 공식적인 방식이라기 보다는 개발자들이 생각해보면 일종의 편의함수에요. useCallback보다 덜 엄격한 최적화를 하는대신 편리를 택하는 거죠.\n\n나중에 스스로 다른 사람에게 이걸 강의한다 생각하고 설명하듯이 말해보는 연습을 해보세요. 그러면 왜 그런지 이해하는데 더 도움이 될거에요.\n\n\nQ) deepEquals에서 flat과 JSON.stringify 사용에 대해\n\n충분히 생각해볼 수 있는 접근이었다 생각합니다. 하지만 해당 방식에는 아쉽지만 몇 가지 치명적인 문제들이 있어요. \n\n우선 비용이 비쌉니다. 가령 {a:1,b:2} {a:3,b:1} 이라는 값을 비교할때 a가 다른게 확인이 되면 b는 안해봐도 되는데 둘다 JSON.stringufy를 안해도 될 비교를 하기 위해 모든 내용을 다 문자로 만들어야 합니다. 큰 객체라면 더욱 더 비효율이 되겠죠.\n\n그리고 JSON.stringify는 객체의 키 순서에 영향을 받을 수 있습니다. {a:1,b:2} {b:2,a:1} 은 사실 같은 객체인데 다르다라고 할 수 있거든요.\n\n그리고 const R = {a: b, self: R} 과 내부에서 재귀적인 참조를 가지고 있다면  JSON.stringify를 하지 못해요. \n\n그리고 flat를 하는 경우 [1, [2]] 와 [1,2] 를 구분하지 못하죠.\n\n간단한 경우에는 문제가 되지 않지만 이러한 core library에서는 엄밀함과 성능을 요구하는 만큼 더 정확하고 빠른 방법으로 찾아가게 되죠.\n\n좋은 경험이 되었기를 바랍니다. 다음 주차도 화이팅입니다!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/18"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "안녕하세요 상수님! 수고하셨습니다. 이번 과제는 React의 내장 훅들을 직접 구현해보면서 프레임워크의 동작 원리를 깊이 이해하는 것이 목표였습니다. AI 없이 최대한 고민해보시고 뇌를 괴롭혀가며 문제를 해결하신 과정 정말로 칭찬드립니다. 1챕터는 결과를 만드는 게 아니라 체험을 통해 학습을 하는 과정인 만큼 힘들었겠지만 좋은 경험이 되었을거라 생각합니다. 또한 \"모든 문제해결 과정을 문서화하려고 노력했다\"는 점에서 진정한 개발자의 자세가 느껴집니다.\n\n코드를 살펴보니 솔루션과 비교했을 때 핵심 개념들을 잘 이해하고 구현해주셨어요. 특히 equals 함수들을 별도 파일로 분리하고 typeUtils까지 만들어서 깔끔하게 정리하신 점이 좋았습니다. baseEquals 패턴을 사용해서 코드 중복을 줄이신 것도 훌륭한 접근입니다!\n\nQ) useShallowState의 타입 문제\nuseShallowState의 타입 문제는 실제로 타입스크립트의 복잡한 부분이에요. Parameters<typeof useState<T>>[0]를 사용할 때 T가 undefined일 가능성을 열어두기 때문에 발생하는 문제죠. 이미 useState의 type에서 가져오는 방식으로 추론이 복잡해졌기에 상수이 해결하고자 했던 타입을 단언하도록 재 설정하는 방식이 나은 방법입니다. 확정적으로 내가 원하는 타입이 가능할 수 있는게 있는데 그걸 의도적으로 추론을 하도록 하면 더 복잡하게 꼬이는 문제가 발생합니다.\n\nuseAutoCallback의 타입 단언도 어쩔 수 없는 부분입니다. 타입스크립트가 고차 함수의 복잡한 타입 추론을 완벽하게 처리하지 못하는 한계가 있어서, 안전한 범위 내에서의 타입 단언은 실무에서도 허용되는 패턴이에요.\n\n정리하자면, 가급적 타입추론을 활용할수 있도록 하는건 좋은 방법입니다. 그러나 내가 API를 제공하는 layer를 만들고 안전하게 타입을 처리할 수 있는 경우라면 이걸 쓰는 쪽에서 타입 추론을 더 잘할 수 있도록 단언등을 통해서 간결화 해주는것이 좋습니다.\n\nuseAutoCallback의 경우에도 마찬가리로 (더 나은 방식이 있을지는 고민을 해봐야겠지만) 함수를 제공하는 쪽의 타입들은 코드상 안전하다면 오히려 타입 단언을 해주는 편이 좋습니다.\n\nQ)\nuseShallowState 나 useAutoCallback은 아시다시피 공식적인 방식이 아니라 편의를 이용한 방법이죠. 사용여부는 전적으로 개발자의 취향이라고 생각합니다. 고민이 든다면 굳이 쓰지 않아도 괜찮다고 생각을 합니다. 내가 배운거나 필요한 모든 것들을 다 써야 하는건 아니니까요. 이러한 개발에 대한 철학적 사유를 해보는 것들 너무 좋습니다. 저도 둘다 실무에서 쓴 적은 없습니다. \n\nuseAutoCallback의 경우 그냥 핸들러를 바로 자식컴포넌트의 props로 넘기게 되면 React.memo가 될 수 없는데 이 방식을 쓰면 의존성 배열 없이 props도 참조를 유지할 수 있는 해법이겠네요.\n\n개인적으로는 컴포넌트의 props에 함수를 전달하는 것을 최대한 지양하는 방식으로 만들고 있어서 useCallback을 잘 안쓰고 있어요. props를 많이 사용해서 독립성있고 투명하게 만드는 것도 props drill을 최소화 하는것도 취향의 영역이니 본인만의 취향을 가져보세요. 단 말씀해주신대로 깊이를 통해서 취향에 대한 확신과 근거도 가져보면 좋겠습니다  \n\nQ) \n고차 컴포넌트에 대한 고민도 공감합니다. 처음엔 복잡해 보이지만 패턴에 익숙해지면 코드의 재사용성과 유연성 측면에서 큰 도움이 되요. 추상화의 가장 큰 문제는 구현부가 사라진다는 거죠. 그렇기에 널리 알려진 이름, 내부 동작이 예측가능하도록 만들어두는 것이 중요하죠. 추상화는 언제나 그런 트레이드 오프를 가져옵니다. 네이밍과 문서화가 그래서 중요한거겠죠. 처음에는 안 읽혀도 알고 나면 쉬워지니까요. \n\n클린코드 시간에 지금과 같은 고민들을 충분히 해보시길 바래요! 수고하셨습니다. 다음 주차도 화이팅입니다!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/34"
    }
  },
  {
    "passed": true,
    "name": "김소희",
    "feedback": "안녕하세요 소희님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 자랑은 아니고 .. 저 얘 때문에 너무 힘들었어요. 제가 너무너무 어렵고 복잡하게 생각해서 혼자 둘레길 한바퀴 돌고 돌아온 것 같ㅅ브니다..\n\nㅋㅋㅋㅋㅋ 제가 의도한 학습과정(?)을 제대로 경험해주셨네요. 뿌듯(?) 합니다 ㅎㅎ\n\n> 실 과제 작업 기간인 약 4일 간, 회사 업무에서 커스텀 훅을 6개 정도 생성해내었습니다. 관심사 분리가 안 된다거나 한 컴포넌트 내 스크립트가 너무 무겁다거나 다시 보니 한 눈에 안 들어오는 코드라거나 .. 다 냅다 빼고 있어요! 리팩토링 할 때도 기능 구현 관점에서만 생각하지 않고 렌더링 트리거에 대해서도 점검하는 습관이 생겼습니다 아이 조아\n\n오옹! 너무 잘 해주고 있네요!! 저희 팀은 custom hook이 거의... 1000개 정도 되는 것 같아요 ㅋㅋ\n저는 컴포넌트는 오직 \"값\"에 관심이 있고, 값을 만들어내는 과정은 훅으로 분리해야 한다고 생각해요! 이러면 테스트 하기도 수월해지고!?\n\n---\n\n과제 자체보다 소희님께서 실무적으로 계속 응용하고 있다는 점이 인상깊네요 ㅎㅎ 고생하셨습니다!!\n앞으로도 화이팅입니다!!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/41"
    }
  },
  {
    "passed": true,
    "name": "김수민",
    "feedback": "안녕하세요 수민님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 1. 값은 useMemo, 함수는 useCallback 아니었나?\n\n저는 둘 다 사용할 수 있다고 생각해요 ㅋㅋ\n\nuseMemo로 만드는 경우를 보자면\n```tsx\nuseMemo(() => debounce(hide, DEFAULT_DELAY), []);\n```\n\n요로코롬 만들 수 있겠죠!?\n\n그리고 다시 useCallback을 구현할 때 useMemo를 이렇게 사용하고 있어요.\n\n```tsx\nfunction useCallback(fn, deps) {\n\treturn useMemo(() => fn, deps)\n}\n```\n\n그래서 useMemo로 만든걸 useCallback으로 변환하다고 치면... 이런 모습이겠죠!?\n```tsx\nuseCallback(debounce(hide, DEFAULT_DELAY), []);\n```\n\n---\n\n> { current: initialValue } 이 객체가 렌더링마다 새로 생성되어서 그랬던 거였습니다!\n\n이게 무척 좋은 인사이트라고 생각합니다 ㅎㅎ state에 초기값에 큰 배열이나 연산비용이 필요한 그런 값이 들어간다면..\n예를들자면 이런 모습인거죠.\n\n```tsx\nconst randomValues = () => Array.from({ length: 10000000 }).map(v => Math.random())\n\nconst Component = () => {\n\tconst [values, setValue] = useState(randomValues())\n}\n```\n\n이렇게 작성할 경우, randomValues가 렌더링을 할 때 마다 실행이 되고, 불필요한 컴퓨팅 연산을 사용하게 된답니다!\n그래서 이럴 때 요로코롬 표현할 수 있어요.\n\n```tsx\nconst randomValues = () => Array.from({ length: 10000000 }).map(v => Math.random())\n\nconst Component = () => {\n\tconst [values, setValue] = useState(() => randomValues())\n}\n```\n\n이러면 최초에 한 번 렌더링 할 때만 randomValues를 실행하는거죠.\n\n>  코드 리뷰는 아니지만..! 저의 이력서에 HOC를 만들어서 문제를 해결했다 라는 내용이 있는데, 면접에 갈 때마다 HOC 왜 썼냐고 물어보고, 어떤 회사는 좀 지나간(?) 방식이고 다른 방법도 있었을텐데 왜 그걸 선택했냐고 물어보더라구요 솔직히 사수가 HOC로 해결해보는 게 어떻겠냐고 해서 그냥 쓴 거라서.. 할 말이 없었습니다ㅠㅠ 이후 학습을 통해 HOC의 장점에 대해 말을 할 수는 있는 상태에 이르렀으나, hook에 비해 어떤 부분이 좋다 이런 건 아직 잘 모르겠어요ㅎㅎ 코치님이 생각하는 HOC의 장점은 무엇인가요!\n\n제가 생각하는 장점은, 훅보다 높은 추상화 수준을 유지할 수 있다는 점!?\n생각보다 여기저기 많이 쓰이고 있어요.\n\nhttps://static.toss.im/slash24/QR/slash24-09.pdf\n\n이건 토스 슬래시 24 발표 자료 중에 하나인데요, 한 번 살펴보시면 좋겠어요!\n쉽게 말해서 로깅을 HoC를 자동화 하는 방법? 이라고 봐주시면 좋을 것 같습니다 ㅎㅎ\n\nHoC가 지나간 방식이라기보단, 어떤 문제는 더 잘 해결해줄 수 있는 방법이라고 생각합니다.",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/50"
    }
  },
  {
    "passed": true,
    "name": "김수현",
    "feedback": "수현님 고생하셨습니다!\n필요한 내용은 전부 잘 작성해주셨고, 부족하다고 생각이 드시는 부분은 꼭 말씀해주신것처럼 본인의 것으로 만들어보시면 좋겠네요 ㅎㅎ\n회고도 잘 작성해주셨고, 따라가면서 읽어보니 실제 어떤 고민들을 하셨는지 직접적으로 잘 이해할 수 있었습니다.\n\n이어서 남겨주신 질문 답변 답변해보면요!\n\n> show, hide 함수 useRef관련\n\n우선 팀원들이 알려주신 방식으로 변경하는게 좀 더 추적이 잘 되고 관리가 잘 되는 방식입니다 ㅎㅎ 절대! 안변하고 명시적으로 관리할 수 있다면 지금 useRef내에서 사용하는것도 방법이겠지만, 함께 사용되는 dispatch자체에 대한 참조가 변경되는 경우 문제가 충분히 발생할 여지가 있어보여요.\nuseRef에는 일반적으로 함수를 저장하는것은 권장되지 않는 패턴인 것 같아요!\n\n> 훅 사용 \n\n훅은 말\b이해하셨던것처럼 리액트 라이프사이클을 타는 컴포넌트가 아닌 다른 것을 반환하는 함수 자체로 바라봐보면 좋을 것 같아요. 이를 통해서 리액트 컴포넌트 내부에서만 할 수 있었던 여러 부수효과를 다룬다거나 리액트 라이프 사이클 안에서 동작하는 여러 기능들을 활용할 수 있게 되잖아요. 이를 통해서 반복되는 여러 상태들을 분리해서 하나로 모아 하나의 관심사를 분리해 재사용성을 높일수도 있고 코드의 가독성을 높일수도 있겠죠. 추가로 비즈니스 로직들이 여러곳에서 사용되고 있을 때 이런 부분들을 한 곳에서 추상화 해 가독성을 높이고 응집성을 높일수 있겠죠. \n그리고 성능 관점에서도 리렌더링이나 성능적으로 병목이 발생하는 지점들을 한 곳에 모아놓고 특별 관리를 할 수 있고 이런 부분들은 결국 테스트의 용이성으로 이어져서 관리하기 편한 프로젝트를 만들어 주게 되는 것 같아요.\n\n추가로 훅을 통해 DOM이나 BOM을 래핑해 유틸성 기능들을 제공하는 여러 저장소도 있는데 함께 찾아 살펴보는 것도 좋을 것 같구요!\n\n고생하셨고 다음 주도 화이팅이에요~~",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/35"
    }
  },
  {
    "passed": false,
    "name": "김연수",
    "feedback": "안녕하세요 연수님!\n이번에는 아예 진행이 되질 않았군요 ㅠㅠ\n챕터 2부터는 이제 완전히 다른 내용이 진행되기 때문에 다시 시작하는 마음으로 진행해주셔도 좋을 것 같아요! 화이팅입니다!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/58"
    }
  },
  {
    "passed": true,
    "name": "김유현",
    "feedback": "고생하셨습니다 유현님! 이번 주 과제도 잘 해주셨네요 ㅎㅎ\n특히 블로그에 작성해주신 내용도 깔끔하게 필요한 내용 정리해주셔서 저도 잘 정리 할 수 있었습니다 :+1\n실제 구현되어 있는 코드들을 참고하고 내 구현으로 만들어보려고 하셨던 부분도 너무 좋은 것 같아요.\n\n질문 주신 부분도 이어서 살펴보면요. 말씀해주신것을 보니 이미 정답을 알고 계신것 같은데요. 지금의 구현처럼(또는, 리덕스와 비슷한 구조처럼 액션과 상태를 명확하게 분리된 상황이라면) 미들웨어 시스템 개념을 차용해서 횡단 관심사를 처리할 수 있도록 구현하는 방식이나, 액션과 상태를 한 곳에서 관리하는 형태로 구현하는 방식 이렇게 있을 것 같아요. 근데 후자는 관심사 분리 측면에서 적절하지 않은 것 같고요! 비동기 로직을 다루는데 있어서 참고할만한 부분은 리덕스의 createAsyncThunk나 RTK Query내용을 살펴보는 것 같은데 이 부분에 대해서도 구현을 살펴보면 도움이 되지 않을까..! 싶습니다. (제가 질문을 잘 이해한거겠죠?)\n\n다음주도 지금처럼 꾸준히 학습 이어나가시길 바랍니다! 화이팅입니다~~",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/22"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "안녕하세요 지혜님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다.\n\n> \"참조는 고정하되 최신 값은 참조\"라는 까다로운 요구사항을 useRef + useCallback 조합으로 해결한 부분이 가장 만족스럽습니다. 처음에는 타입 때문에 고생했지만, 제네릭과 unknown[], as T 타입 단언을 사용해서 TypeScript의 복잡한 타입 시스템을 해결할 수 있었습니다.\n\nref와 callback 등을 같이 사용하는 과정이 지혜님께 큰 챌린지였군요..! 그럼에도 불구하고 잘 학습하고 계셔서 다행이네요 ㅎㅎ\n\n> E2E 테스트 통과 과정에서 하나씩 메모이제이션을 추가하다 보니 이렇게 됐는데, useMemo를 이렇게 많이 써도 되는 건지 잘 모르겠습니다. 특히 { message: state.message, type: state.type } 같은 경우도 useMemo로 감싸야 하는 건지, 그리고 이런 식으로 계속 메모이제이션을 추가하는 게 올바른 방법인지 판단이 서지 않습니다. 더 나은 구조가 있다면 개선하고 싶습니다.\n\n지금은 state를 메모이제이션 하지 않아도 무방해보여요. 잘 보면 state.message와 state.type 중 하나만 변화하는 경우가 없답니다. 둘의 변화가 똑같이 발생하는거죠.\n\n메모이제이션을 하지 않아도 어차피 똑같은 메모리를 가르키게 된달까..? 그렇습니다.\n그래서 다만 state를 2개 이상 사용하여 조합하는 값이 있을 때에는 useMemo를 사용하면 좋답니다!\n\n> ToastProvider에서 useMemo 과도한 사용 : 해당 페이지에서 useMemo를 5번 사용하고 있는데 과도하게 사용되고 있다고 생각하지만 다른 방법을 모르겠습니다. 어찌저찌 요구사항과 테스트 통과를 위해 구현해내긴 했으나 더 좋은 방법이 있을지 궁금합니다.\n\n솔루션 코드도 살펴보시면 5번 정도 사용하고 있답니다 ㅎㅎ 저는 지금이 최선의 모습이라고 생각해요!\n다만 state를 아예 contextValue로 사용하고 있기 때문에 메모이제이션을 해주지 않아도 무방해보이네요..!\n\n> useAutoCallback 패턴이 올바른지 : useRef와 useCallback을 조합해서 만든 건데, 이런 패턴이 실제로 쓰이는 방법인지 궁금합니다. 다른 더 좋은 방법이 있을까요?\n\n실제로 쓰일 수 있답니다 ㅎㅎ\n이를 대체할 수 잇는 더 좋은 방법? 에 대해 질문을 주신거라면... 아직은 잘 모르겠어요.\n\n어떤 상황에 사용할 수 있는지는 제가 이야기 드리기보단 지혜님께서 추후에 필요할 때 \"이런게 있구나!?\" 라고 떠올리고 사용할 수 있는 순간이 있으리라 생각해요.\n",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/48"
    }
  },
  {
    "passed": true,
    "name": "김효진",
    "feedback": "안녕하세요 효진님!! 다시 만나서 너무 반가워요 ㅋㅋㅋ\n\n> 과제를 진행하면서 다른 분들이 정리해준 글, pr들을 많이 참고했는데 많은 도움을 받을 수 있어서 좋았습니다. 다만 제가 스스로 코드를 뜯어보거나 분석해보는 등의 경험이 덜 한 채로 다른 분들이 정리해둔 글을 읽다보니 ‘나도 저렇게 직접 탐구를 해보고싶다..!’라는 자극을 받게 되더라고요. 다음 과제에서는 한 번 도전해보겠습니다.\n\n지금 과제에서도 충분히 잘 해주고 있어요! 처음부터 많은걸 하기보다 조금씩 조금씩 효진님의 바운더리를 넓혀가는 방식으로 시도해보시면 좋답니다 ㅎㅎ\n\n> 한 때 회사에서 팀원들과 나눴던 얘기 중 메모이제이션에 관한 내용이 있었는데요, ‘useMemo와 useCallback을 많이 사용하는 것이 오히려 성능에 좋지 않다고 하더라.’라는 이야기였습니다. 실제로 저희는 쓸 수 있는 거의 모든 곳에 useMemo와 useCallback을 사용하고 있습니다. 이 때 당시에는 스쳐지나가는 주제라 제대로 된 결론이 나지는 않았었네요.\n그런데 이번 주에 다른 팀의 멘토링 주제에서도 비슷한 내용이 언급되었고, 코치님의 답변은 ‘적절한 순간에 메모이제이션을 쓰기로 하면서부터 오히려 개발하는데 병목이 생길 수 있고 생산성이 떨어질 수 있으니 이럴거면 다 적용하는게 좋은 것 같다’ 였습니다. 오? 그럼 오히려 제대로 쓰고 있었을지도?^^ㅎㅎ\n명쾌한 답변 인 듯 하면서도 그렇다면 메모이제이션을 적절하게 써보기 위해 노력해본 적은 있는가? 모든 코드에 메모이제이션을 쓰고 있는 지금 상황이 선택적 메모이제이션에 대해 불편함을 느끼고 난 후의 결론인가? 라고 생각했을 땐 ‘아니!’ 라는 생각까지 도달했습니다. 프로젝트를 진행하면서 필요한 곳에서만 메모이제이션을 하는 방식을 적용해 본 경험이 있었다면 현재의 상황에 대해 가지고 있던 의문점을 좀 더 빨리 해소할 수 있었을 것 같습니다.\n\n아마 9주차 ~ 10주차 과제에서 메모이제이션에 대해 조금 더 다룰 것 같은데요, 이 때 효진님께서 잘 학습할 수 있도록 설계해보겠습니다 ㅋㅋㅋ\n\n3주차 과제 진행하느라 고생하셨어요! 특별한 질문은 없는 것 같아서, 일단 마무리하겠습니다 ㅎㅎ",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/30"
    }
  },
  {
    "passed": true,
    "name": "김휘린",
    "feedback": "안녕하세요 휘린! 수고했습니다. 이번 과제는 React의 내장 훅들을 직접 구현해보면서 프레임워크가 어떻게 상태를 관리하고 최적화하는지 이론이 넘어 몸으로 깊이 이해하는 것이 목표였습니다. \n\n이번 과제는 분명 정답이 있는 과제였지만 그 과정에서 체득하는 것이 목적인만큼, AI를 써보지 않고 고민 고민을 하면서 \"그냥 안되는 걸까?\"하는 의문으로 직접 실험해보신 과정이 정말 인상적이네요. 개발자라면 일단 해보고 탐구하는 정신이 필요하요. ㅎ\n\n그리고 또한 Context를 상태와 액션으로 분리하여 불필요한 리렌더링을 방지해봐야 하는 걸 느껴본 것도 좋은 인사이트라 생각합니다. 실무적인 측면에서는 Context보다는 상태관리 도구를 직접 쓰는 편인데 그러한 상태관리들이 이렇게 상태과 액션을 분리해서 다루고 있고 개념적으로도 상태과 액션을 분리해서 생각하면 조금 더 아키텍쳐를 선명히 바라 볼 수 있죠. \n\n더 좋은 코드가 없을지 생각해봐야겠다 생각하는 태도 좋네요. 이번 클린코드 챕터에서 그 인사이트들을 마음껏 실현해보기를 바래요.\n\n이번 과제를 통해 React가 제공하는 편리한 API들이 내부적으로 어떤 문제를 해결하고 있는지 몸소 체험하셨을 거예요. 특히 \"메모이제이션은 만능이 아니다\"라는 깨달음과 함께 구조적 개선의 중요성을 인식하신 점이 훌륭합니다.\n\n---\n\nQ) useRouter의 구독 해지와 메모리 누수 확인 방법\n\n네, 구독 해지를 하지 않으면 메모리 누수가 발생합니다. 한줄의 코드로 그걸 알기는 어렵고 for문을 많이 돌려본다음  Chrome DevTools 활용해서 컴포넌트를 여러 번 마운트/언마운트한 후 다시 Snapshot을 촬영하여 메모리가 어떻게 바뀌는지 확인해보세요. \n\n그게 아니라면 단순하게 subscribe에 로그를 찍어본다음 컴포넌트를 unmount를 해도 로그가 남아 있다면 누수 동작이 발생하는 걸 확인할 수 있을거에요.\n\n수고하셨습니다. 깊이를 탐구하는 지난 3주간의 Deep dive체험이 즐거운 시간과 깊이를 탐구하는 방법에 대한 시야와 계기가 되었기를 바래요. 앞으로 하게 될 클린코드 챕터도 화이팅입니다!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/38"
    }
  },
  {
    "passed": true,
    "name": "박상수",
    "feedback": "안녕하세요 상수님, 수고하셨습니다! 이번 과제는 React의 내장 훅들을 직접 구현해보면서 프레임워크가 어떻게 상태를 관리하고 최적화하는지 깊이 이해하는 것이 목표였습니다. 해당 구현을 통해서 말로는 설명하기는 어렵더라도 구체적인 원리등을 깨닫게 되는 시간이었기를 바래요.\n\n회고에서 재귀함수에 대한 새로운 인식을 얻으신 점이 재밌었습니다. \"알고리즘용 함수라는 인식이 깨져버린 거 같다\"고 했는데 그렇죠. 재귀는 상당히 자주 쓰이는 패턴입니다. 자기 스스로를 부르는 함수라는 개념이 어려운데 이번 기회에 잘 이해하게 된 것 같아서 좋네요.\n\n\"아직은 잘 모르겠다 좀 더 공부를 해야 할 거 같다\"고 하셨지만, 분명 알게 된 것은 많을 거라고 생각해요. 개발자는 내가 알고 있는 것을 언어의 형태로 또 잘 표현하는 것이 중요한 능력인 만큼 회고에서 잘 모르겠다면 최대한 어떻게 뭘 모르겠는지를 구체적으로 적어보길 바래요!\n\n수고하셨습니다. 기술적 깊이를 탐구하는 자세와 동료들의 피드백을 적극적으로 수용하는 태도가 정말 인상적입니다. 앞으로 진행될 클린코드 챕터에서도 이런 탐구 정신을 계속 발휘해 주시기 바랍니다. 화이팅입니다! :)",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/59"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "안녕하세요 소연님! 과제 너무 잘 진행해주셨네요!!! 고생하셨습니다 ㅎㅎ\n특히 문제해결과정을 잘 서술해주셔서 소은님의 사고를 따라가기가 수월했어요! 감사합니다!\n\n> basic.test.tsx의 '직접 만든 memo' 테스트코드에서 호출 횟수는 체크하나, null 관련 체크는 없어서 통과되었나봐요 하핫\n\n좋은 피드백 감사합니다 ㅎㅎ 다음에는 null에 대해 체크하는 부분도 추가해놔야겠네요!!\n\n> ToastProvider 를 구현할 때, useCallback과 useAutoCallback 중에 어떤걸 쓰는게 좋을까 라는 고민이 있었습니다. useCallback만으로 충분히 최적화가 가능할것 같은데, 이때 useAutoCallback을 쓰면 좋다 라는 케이스가 어떤경우가 있을지 궁금합니다.\n\n함수가 의존해야 하는 값이 없을 때는 useCallback이 좋고, 의존해야 하는 값이 있을 때는 useAutoCallback 을 사용하는게 좋다고 생각해요!\n특히 useEffect 에서 사용해야 하는 함수이면 더더욱..!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/6"
    }
  },
  {
    "passed": false,
    "name": "박의근",
    "feedback": "",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박준형",
    "feedback": "안녕하세요 준형님!\n역시 믿고보는 준형님의 과제입니다 ㅎㅎ\n\n> 이러한 학습 과정에서 Robert Cecil Martin의 \"패러다임은 개발자의 권한을 박탈한다\"는 말이 깊이 와닿았습니다. 좋은 코드란 개발자의 자유를 의도적으로 제한함으로써 예측 가능하고 함께 작성하기 좋은 구조를 강제하는 코드라는 철학을 갖게 되었습니다.\n\n자유를 박탈한다는 표현이 무척 와닿네요 ㅋㅋ 사실 프레임워크 기반의 코드가 그런 편이죠.\n\n> 개인적인 소견으로는 답이 없는 과제들이 가장 어렵고 힘들었지만 제일 인상적이었습니다. 정해진 정답을 찾아가는 과정이 아니라, 나의 생각들을 직접 정리해가면서 구체화시켜가는 과정이었기 때문입니다. 이러한 과정을 통해 단순히 기술적 구현 능력뿐만 아니라, 개발자로서의 사고 체계와 철학을 정립할 수 있는 귀중한 기회가 되었습니다.\n\n오호.. 그렇군요! 의도한 부분은 아니었어요 ㅎㅎ 사실 저는 답이 있는걸 별로 좋아하진 않는 편이긴 해요. 다만... 과정의 특성상 어느정도의 솔루션이 필요하다보니 밸런스를 맞추는 과정에서 이러한 모습이 되었네요.\n\n준형님이 좋은 인사이트를 주셔서, 다음 기수는 조금 더 어렵게(?) 만들어갈 수 있을 것 같아요 ㅋㅋ 감사합니다!\n\n> 결국 내 생각은 메모이제이션 자체가 나쁜 도구는 아니지만, 사용하기 전에 \"왜 이 컴포넌트에서 불필요한 리렌더링이 발생하는가?\"라는 질문을 먼저 던져봐야 한다는 것이다. Dan Abramov가 말한 것처럼 올바른 컴포넌트 구조는 단순히 성능 개선뿐만 아니라 데이터 플로우를 명확하게 만들고, props drilling을 줄이며, 전체적인 코드 품질을 향상시킨다. 이런 측면에서 구조적 개선이 우선되어야 한다고 본다.\n\n저도 동의합니다! 이런 훈련이 계속 되어야 잘 사용할 수 있는 것 같아요.\n\n---\n\n이 외에는 특별한 질문이 없는 것 같아서 피드백은 여기서 마무리하겠습니다 ㅎㅎ\n너무 고생 많으셨어요 준형님!!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/26"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박창준",
    "feedback": "안녕하세요 창준! 수고했어요~ 이번 과제는 React의 내장 훅들을 직접 구현하면서 프레임워크의 내부 동작 원리를 깊이 이해하는 것이 목표였습니다. 창준님의 PR을 보면서 정말 깊은 탐구와 열정이 느껴지는 학습을 했다는게 느껴졌네요!\n\n단순히 과제를 완료하는 것을 넘 성능 측정과 최적화까지 직접 경험해본 부분 칭찬합니다 특히 무한 스크롤에서 메모이제이션 적용 전후의 렌더링 시간을 React Profiler로 측정하여 96.2ms에서 27.4ms로 약 3.5배 개선한 실험은 정말 훌륭했습니다. 개발은 이렇게 항상 직접 해보면서 내가 체험적으로 느껴보는게 참 중요한 학습이라고 생각하는데 정말 잘했습니다!\n\nuseSyncExternalStore의 등장 배경에 대한 이해도 인상적이었습니다. React의 동시성 렌더링이 상태 찢어짐 문제를 만들고, 이를 해결하기 위해 새로운 훅이 등장했다는 진화 과정을 파악하신 것은 좋은 인사이트입니다. 컴퓨터 공학은 언제나 필요에 의해 진화를 해왔기에 그 배경과 서사를 이해한다는게 개발 공부에 큰 도움이 되죠!\n\n이렇게 서사와 배경을 정확히 알게 되면 메모이제이션에 대한 본인의 철학도 취향이 아닌 확신을 통해 만들어지게 되는 것 같아요. 창준의 경우 무분별한 적용보다는 성능 이슈가 실제로 발생했을 때 신중하게 적용하는 접근을 하는 것에 대한 확신과 근거가 생겼기를 바랍니다.\n\n이번 과제를 통해 React가 제공하는 편리한 API들 뒤에 숨어있는 복잡한 문제들을 직접 체험하셨을 거예요. 특히 \"메모이제이션은 만능이 아니다\"라는 깨달음과 함께 구조적 개선의 중요성을 인식하신 점이 훌륭합니다.\n\n---\n\nQ1. 업무를 진행하실 때 메모이제이션을 다 해놓은 편인가요? 아니면 성능 이슈가 발생했을 때 적용하시나요?\n\n=> 개인적인 취향 내지는 철학에 관련된 질문이라고 이해하고 개인적인 답변을 하자면 저는 useMemo식의 메모제이션을 가급적 잘 쓰지 않으려고 합니다. 리렌더링의 이유가 달라지는 컴포넌트를 쪼개고 컴포넌트에 props를 통한 memo를 거는 방법을 선호합니다.\n\nQ2. 만약 성능이슈가 발생해서 메모이제이션을 적용하신 경험이 있다면 한번 소개해주시면 감사합니다!\n\n=> 저는 어플리케이션류는 React를 주로 쓰지 않았고 제가 해봤던 React의 경우는 주로 대시보드 형 페이지라 성능이슈가 발생해본 경험이 없네요.\n\n\nQ3. 컨텍스트와 상태관리에 대한 코치님의 생각도 궁금합니다.\n\n=> Context는 값이 변경이 되면 전체를 리렌더링을 발생시키기에 상태관리로는 부적합합니다. 자주 변하지 않을 값 그렇지만 변하면 다시 전체를 그려내야하는 값을 보관하거나 값을 격리하는데 유리하죠. 테마라던가 언어, 혹은 각종설정값이나 전역객체들이요.\n\n=> 상태관리는 말 그대로 뷰와 상태를 분리하고자는 개념에서 나온것이기에 Context로 상태관리를 구현할 수 있는 있지만 별개의 개념으로 다루는 것이 맞다고 생각을 합니다. 그리고 상태관리의 store를 격리하기 위해서는 context의 도움이 필요하겠죠.\n\n수고하셨습니다. 깊이를 탐구하는 지난 몇 주간의 Deep dive 경험이 즐거운 시간과 함께 탐구하는 방법에 대한 시야를 넓혀주는 계기가 되었기를 바래요. 앞으로 하게 될 클린코드 챕터에서도 이런 탐구 정신을 마음껏 발휘해보시기 바랍니다. 화이팅입니다!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/20"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "신홍준",
    "feedback": "안녕하세요 홍준, 수고하셨습니다! 이번 과제는 React의 내장 훅들을 직접 구현해보면서 프레임워크가 어떻게 상태를 관리하고 최적화하는지 이론을 넘어 몸으로 깊이 이해하는 것이 목표였습니다.\n\n홍준님의 회고를 보니 React가 낯선 상황에서도 개념 학습부터 차근차근 시작하셔서 정말 체계적으로 접근하신 것 같아요. 특히 피그잼으로 정리하신 학습노트! 아주 멋져요. 특히나 React Fiber의 전반적인 구조와 흐름까지 파악하시고, useRef의 DOM 조작 원리를 깊이 탐구하신 부분에서 뭐랄까 개발자스러운 탐구정신(?) 그런것들이 느껴졌어요! 이렇게 한번 구조와 그림을 정리해두고나면 원리들이 선명하게 느껴질거에요!\n\nequals 함수 구현에서 getType, isShallowArrayEqual, isShallowObjectEqual 등으로 기능을 세분화해서 만들어본 접근도 좋았습니다. 코드를 작게 나누면 절대 틀릴 수 없는 코드들이 많이 만들어지죠.\n\n이전 항공 예약 사이트 프로젝트에 대해서 설명해주는 부분도 인상적이었습니다. 실습과제와 실무를 엮어서 고민한다는 건 쉽지 않은데 잘했습니다.\n\n---\n\nQ) typeof로 인한 타입 구분 문제와 `as` 키워드 사용에 대한 의견\n\n=> 지금 접근 방식은 이미 조건문으로 타입이 걸러졌기 때문에 as를 쓴다고 해도 사실 문제가 없고 as를 적절히 잘 사용한 예시라 생각합니다. 조금 더 나은 방식은 이렇게 조건에 따라 타입을 필터링을 할때 TypeScript에서는 타입 가드(Type Guard)를 사용하면 좋습니다. 그렇면 as 키워드 없이도 안전하게 타입을 좁힐 수 있습니다.\n\n```typescript\nconst isArray = (value: unknown): value is unknown[] => Array.isArray(value);\nconst isObject = (value: unknown): value is Record<string, unknown> => \n  value !== null && typeof value === 'object' && !Array.isArray(value);\n\nexport const shallowEquals = (a: unknown, b: unknown) => {\n  if (isArray(a) && isArray(b)) {\n    // 여기서 a, b는 자동으로 unknown[]로 추론됩니다\n    return isShallowArrayEqual(a, b);\n  }\n  \n  if (isObject(a) && isObject(b)) {\n    // 여기서 a, b는 자동으로 Record<string, unknown>로 추론됩니다\n    return isShallowObjectEqual(a, b);\n  }\n  \n  return a === b;\n};\n```\n\n이렇게 하면 타입 안전성을 보장하면서도 런타임 타입 체크와 컴파일 타임 타입 추론을 모두 만족시킬 수 있습니다. \n\n수고하셨습니다. 이제 시작하는 클린코드 챕터에서도 이런 탐구 정신으로 더욱 성장하시길 응원합니다! 화이팅입니다! :)",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/2"
    }
  },
  {
    "passed": true,
    "name": "신희원",
    "feedback": "안녕하세요 희원!, 수고하셨습니다. 이번 과제는 React의 핵심 훅들과 최적화 기법을 직접 구현해보면서 프레임워크가 어떻게 상태를 관리하고 렌더링을 최적화하는지 내부 원리를 체득하는 것이 목표였습니다. 특히 이론적으로 쓰는 법을 이해하는 공부와 구현을 하기 위해 필요한 것을 공부하는 것의 차이를 경험하는 시간이 되었기를 바래요.\n\n회고에서 AI를 단순 코드 생성이 아닌 개념 학습 도구로 활용하신 접근법의 변화가 정말 인상적입니다. \"~~짜줘\"에서 \"필요한 개념이 무엇인지 알려줘\"로 질문 방식을 바꾸는 것이 좋네요. AI를 다앙한 방법을 필요에 맞게 바꿔보는 것도 현대 시대에서 중요한 능력이라 생각해새요. 무엇보다 동료들에게도 도움을 요청하며 협업으로 문제를 해결하려고 한 부분은 너무 너무 칭찬하고 싶네요. 결국 사람이죠! \n\n코드를 살펴보니 useAutoCallback에서 args 파라미터가 필요한 이유를 e2e 테스트를 통해 직접 발견하신 점이 특히 좋았습니다. 장바구니 데이터가 전달되지 않는 문제를 디버깅하며 깨달으신 것처럼, 실제 동작을 확인하며 이해한 지식이 가장 오래 남죠. ToastProvider의 Context 분리도 잘 구현하셨고, 상태와 액션을 분리하여 불필요한 리렌더링을 방지해보는 것도 잘했습니다.\n\n지난 3주간의 과제들을 통해서 \"필요가 공부를 만든다\"는 것을 느껴보며 어떻게 깊이를 학습해야하는지 이해하는 시간이 되었기를 바랍니다. 수고하셨습니다.\n\n---\n\nQ1) useCallback vs useAutoCallback 사용 시점\n=> useCallback은 의존성이 명확하고 변경 시점을 제어해야 할 때 사용합니다. useAutoCallback은 이벤트 핸들러처럼 항상 최신 상태를 참조해야 하지만 함수 참조는 유지해야 할 때 유용합니다. \n\n\nQ2) 메모이제이션 적절한 사용법\n=> 원작자는 메모제이션은 대부분의 경우에는 필요가 없으니 필요할때만 하라고 말하고 있죠. 그래서 최적화가 필요하다 느껴지기 전까지는 안하는 게 일반적인 방법입니다. 그리고 마우스 드래그, keydown, timer 등 리렌더링이 빈번하게 발생하는 과정에 느리다는 것이 느껴지는 곳에 선택적으로 memo를 메모제이션을 하죠.\n\n=> 그러나 이렇게 메모제이션을 하라고 하면 판단의 근거가 너무 주관적이게 되므로 컨벤션등은 모든 더 극단적인 형태를 띄게 됩니다. 하나는 그냥 메모제이션이 필요한 곳에 모든 메모를 붙이자는 것입니다. \n\n=> 다른 하나는 컴포넌트를 완전히 격리해서 메모제이션을 최소화 하고 컴포넌트에서의 메모제이션을 하자는 방식이죠. 이 두가지 방식에 대해서는 한번 공부해보시면 좋겠네요.\n\n수고하셨습니다. 깊이를 탐구하는 방법을 터득하신 만큼 앞으로의 클린코드 챕터도 기대됩니다. 화이팅입니다! :)\n\n",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/28"
    }
  },
  {
    "passed": true,
    "name": "양성진",
    "feedback": "성진님 고생하셨습니다!\n작성해주신 파이버 재조정에 대해서도 좀 더 구체적으로 살펴보면 큰 도움이 될 것 같은데요! 이 부분에 대해서 저번에 공유드렸던 것처럼 잘 설명되어있는 \n* https://react.gg/visualized \n* https://jser.dev/series/react-source-code-walkthrough\n요런 사이트들도 한번 살펴보면 이해에 큰 도움이 될 것 같아요. \n\n추가로 이 과제를 진행하는데 있어 핵심적인 부분 중 하나는 상태 관리 였던 것 같은데, 좀 더 공부해보셔야겠다고 남겨주셨으니 꼭! 살펴보시고 팀원분들과 함께 이야기 나눠보시면 좋을것 같네요. \n\n추가로 질문 주셨던 것처럼 과거에는 모든 코드에 메모이제이션을 하는 파와 절대 하지않는다 파(?)로 나뉘어져서 막 논쟁이 있었던 것 같은데, 최근에는 그런 사람들이 많이 사라진 것 같아요. 일반적으로 저희가 따르는 최적화 논리대로 섣부른 최적화는 하지 않되, 성능적으로 이슈가 발생하는 지점이 생긴다면 그 지점에 대해서 파악한 뒤 그 부분만 국지적으로 처리하는게 적절한 사용 방법인 것 같아요. 내부적으로 이미 처리가 어느정도 되어있고 최근 들어서는 모든걸 해결해주는 관점에서 개발을 하는 것은 아니지만 컴파일러의 발전도 지속되고 있잖아요. 필요한 부분이 발견되면 그 때 적용하는 형태로 하면 좋을 것 같습니다.\n\n고생하셨고 다음 주도 이번 주처럼 화이팅입니다!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/46"
    }
  },
  {
    "passed": true,
    "name": "양창훈",
    "feedback": "Q. 고차함수란 무엇인가?\n\nA. 고차함수 어렵게 생각하지 마세요. 정말 아무것도 아닙니다. 너무 아무것도 아니에요 ㅎㅎㅎ\n\n고차함수른 함수를 인자로 전달받아서 새로운 함수를 리턴하는 함수에요. ㅎㅎ 별거 아니죵?\n\nfunction 고차함수란놈(인자로전달되는함수) {\n  return 새로리턴되는함수() {\n      return 인자로전달되는함수() + 1;\n  }\n}\n\n이런 함수가 고차함수입니다. 그래서 고차함수는 보통 클로저를 만들죵\n\nmemo라는 고차함수는 Component라는 함수를 인자로 받아서 memoComponent라는 새로운 함수를 리턴하죵?\n그래서 memo가 고차함수입니다 :)\n\nㅎㅎ 이해가 되셨으면 좋겠어요 정말 아무것도 아닙니다. 고차함수는~\n혹시 이해안되시면 디스코드로 다시 알려주세욥\n",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/57"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "여진석",
    "feedback": "안녕하세요 진석님! 굉장히 깊이있는 고찰을 해주셨네요 ㅎㅎ 재밌게 잘 읽었어요! 고생하셨습니다.\n\n---\n\n> \"효율적으로 앱을 관리하고 있다면 context hook도 좋은 상태관리 수단\"이라는 관점에 대해서 어떻게 생각하시나요?\n\n개인적으로 관리해야 하는 상태가 많아질수록 context를 통해 상태를 관리하는게 굉장히 어렵다고 생각해요. 무엇보다... 성능 최적화를 하는게 너무 어렵답니다 ㅋㅋ (해본사람의 이야기..)\n\n> 저번 Q&A 시간에는 전부다 memo를 사용한다고 하셨는데, tool쪽이라 렌더링에 민감한 부분이 영향이 크실까요? 그냥 단순한 웹, 앱 등에서도 전부다 memo하는게 효율적일까요?\n\n렌더링에 민감해서 했다기보단... 언제 쓰는게 좋을지에 대한 판단을 매번 하는게 귀찮고 한 번 memo를 시작하면 그 여파가 계속 커져서 (메모로 인한 메모로인한 메모로인한 메모로인한, .... 메모) 이럴꺼면 그냥 다써~~ 라고 팀 내에서 합의를 했답니다 ㅎㅎ\n커뮤니케이션 비용 때문인거죠\n\n> 코치님이 선호하시는 상태관리는 어떤 것인가요?\n\n저는 간단한 상태관리는 아마 zustand 사용할 것 같고 (사실 실무에서 제대로 사용해본적이 없어요), 복잡한 상태를 다룰 때에는 redux를 사용할 것 같습니다.\nredux의 경우 action을 thunk로 쪼개서 조합할 수 있다보니 다루는 상태가 복잡할 때 편의성을 많이 제공해줘요 ㅎㅎ\nzustand도 그런게 잇는지 모르겠네..\n\n> 저는 서버상태관리 라이브러리들이 생겨나면서 flux 패턴으로 관리하는 패턴자체의 필요성이 많이 줄었다고 생각하여습니다. 그러다보니 jotai를 선호하게 되었는데, 이런 관점에서 코치님이 바라보시는 생각이 궁금합니다.\n\n앞선 내용과 이어지는 부분인데요, flux가 중요한건 아니라고 생각해요. 대부분의 경우에는 아마 jotai만 사용해도 충분할 것 같네요 ㅎㅎ\n제가 zustand나 redux를 선호하는 이유는 react에 종속적이지 않은 방식으로 만들 수 있기 때문인데요, jotai는 react와 강결합(?) 되는 부분이 없지않아 있어서... 그게 조금 거슬렸어요. 이건 선호도 차이도 있고 팀의 인식 차이도 있기 때문에 중요한 부분은 아니라고 생각합니다!\n\n> 제가 분석한 zustand(useSyncExternalStore) vs jotai(useEffect) 방식의 트레이드오프가 정확한지 확인하고 싶습니다.\n\n흠.. 일단 동시성에 대한 부분이 사용성에 얼마나 큰 영향을 주는가를 따져봤을 때... 아마 미미하지 않나? 라고 생각해요. 아마 저는 \"사용성\"보단 \"편의성\"을 더 중요하게 생각할 것 같아요. 개발자가 사용하기에 얼마나 더 편리한가! 라고 해야하나 ㅋㅋ\n\n가령, 어플리케이션을 만들 때 사실 네이티브로 만드는게 제일 성능도 좋고 매끄러워요. 그런데 웹뷰를 많이 사용하는 이유는 생산성과 편의성 때문이 크다고 생각합니다.\n\n빠르게 서비스를 만들어가야 하는 부분도 고려 대상이라는거죠.\n그래서 저는 \"우리 팀이 익숙한 것\"도 고려해야 한다고 생각해요. 팀원 대부분이 zustand가 익숙하다면 저는 zustand가 좋은 대안이라고 생각하고, jotai가 익숙하다면 jotai가 좋은 대안이겠죠!?\n\n혹은 개발자의 편의성을 확보해주는 여러가지 도구가 있는지 살펴보는 과정도 필요할 것 같아요.",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/29"
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "찬규님 고생하셨어요!\n글에는 하나밖에 적지 않아 아쉽다고 적어주셨지만, 사실 과제보다 더 무언가를 하는 것 자체가 놀라운거니까요. 너무 잘하셨습니다.\n회고도 잘 작성해주셨고 과제도 잘 해주셨어요.\n자랑해주신 함수도 변화된 모습을 보니 함수도 훨씬 가독성이 좋아졌네요 ㅎㅎ :+1\n\n질문 주신 부분 빠르게 답변 들어가보면요!\n\n> 1. shallowEquals\n\n큰 차이는 분~명 없을것 같긴 하지만, 그럼에도 자주 호출되는 함수이기 때문에 실제로 체크를 한번 해보면 좋을 것 같아요. 작성해주신것처럼 가독성은 좋아지지만 결국 함수가 익명으로 호출이 될때마다 선언이 매번 되기 때문에요. 테스트를 해보는게 그렇게 어렵지 않을 것 같아서 한번 데이터의 양을 임의로 깊게하거나 크게 해서 비교해보면 좋을것 같아요! (몇 ms차이는 비교가 어려우니 명시적으로 차이가 나도록 크게요.) 이런 부분도 한번 정리해서 공유해줘도 좋을것 같네요 ㅎㅎ\n\n> 2. useShallowSelector\n\n넵! 아마 언마운트 될때 GC가 될 것 같아요. 다만, 이것과 별개로 비슷하게 메모이제이션이나 클로저 같이 메모리상으로 이점을 누리기 위해 최적화 방식을 쓰는 경우나 DOM 이벤트 할당처럼 명시적으로 해제를 하는게 가독성 측면이나 혹시나 예측이 안되는 부분에 있어서 혹시 있을 일을 미연에 방지하는 좋은 습관일 수 있어요. 물론 브라우저가 똑똑해지고 잘 해주겠지만,이런 부분도 함께 챙겨보시면 더 좋은 습관이 되지 않을까 싶습니다!\n\n> 3. ToastProvider\n\n성능 관점에서 나누는 것도 좋겠지만, 같은 이야기를 하는 같은 관심사의 내용이 분리될만큼 성능적으로 최적화가 필요할까! 라는 지점에 대해서도 함께 고민해보면 좋을것 같아요. 상황에 따라 판단하겠지만, 지금의 상황이라면 메모이제이션을 사용해도 될 만큼 복잡한 상황은 아니지 않을까.. 함께 두는게 더 가독성이나 관심사 분리 측면에서도 좋지 않을까 라는 매우 개인적인 의견이 있습니다 ㅎㅎ 언제 나누고 안나누고는 늘 상황에 따라 다를 것 같고 사람마다도 다를 것 같아요. 대신 일관된 규칙을 갖고 분리하는게 제일 중요한 것 같아요. 찬규님 입장에서 한번 다시 고민해보는것도 좋을 것 같습니다! 정답은 없어요.\n\n이번 주도 고생 많이 하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/37"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "오하늘",
    "feedback": "안녕하세요 하늘님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 실은 그간 보냈던 2주 동안에 listener에 대한 깊이 있는 이해가 부족해서 store를 구현하는 데에도 이게 왜 되지? 싶었는데, 이번 주차 과제를 통해 에라이~ 모르겠다! 하고 listener에 대해 좀 찾아봤다.\n\n블로그 포스트까지 작성해주시고! 너무 고생하셨어요~ 저도 하늘님의 글을 보면서 부족한 지식을 채워나갈 수 있었답니다!\n\n> 결론: 1, 2주차를 경험했어서, 3주차 과제가 수월할 수 있었습니다.\n\n의도했던 부분은 아니지만, 효과가 있었다니 다행이네요!! 감사합니다 ㅎㅎ\n\n> useMemo, useCallback, React.memo의 구체적인? 실무적인? 예시를 모르겠습니다. 단순한 CRUD를 주로 만져서 그런지 메모이제이션을 쓸 일이 많이 없었는데요, 코치님께서는 작업을 하시다가 메모이제이션을 써야겠다! 라는 감이 올 때가 있으신가요?\n\n무조건 이런 상황에는 써야돼! 라기 보단, 제일 좋은건 \"필요한 순간\"에 적용하는거라고 생각해요.\n그렇다면 필요한 순간이 언제일까? 에 대한 판단을 해야될텐데, 이건 비즈니스와 관련이 있답니다.\n내가 만드는 서비스의 사용성에 문제가 있을 때를 인지한 시점이라고 생각해요.\n그 이전까지는 개선을 한다고 해도 개발자 개인의 욕심이지 않을까!? 싶어요 ㅎㅎ\n\n조금 더 수치적으로 이야기해보자면, 인터렉션에 의한 1회 렌더링이 200ms 이상 소모될때!? 라고 해야하나.. 그렇습니다.\n\n이에 대한 부분은 9~10주차 과제에서 체험해볼 수 있으니 조금만 더 기다려주세요!\n혹은 \"렌더링이 많이 발생하는 상황\"을 AI에게 만들어달라고 하고, 해당 코드에 대해 직접 리팩토링을 해보는거죠!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/24"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "안녕하세요 윤우님!\n정리를 너무 잘 해주셨네요 ㅎㅎ\n고생하셨습니다!!\n\n> hideAfter에 useMemo를 사용하지 않을 방법은 없었을까요? useAutoCallback을 사용하면 내부 디바운싱에서 타이머가 초기화되지 않는 문제가 있었습니다. 함수를 메모이제이션 하는거니까 useCallback쪽이 더 어울린다고 생각이 들어서요!\n\n이 때는 useCallback이 아니라 useMemo를 사용해야 한다고 생각해요!\ndebounce로 만든 함수 자체를 메모해야 하기 때문이죠! 그래서 솔루션도 살펴보시면 debounce를 useMemo로 만들어서 사용하고 있답니다 ㅎㅎ\n\n```tsx\nconst hideAfter = useMemo(() => debounce(hide, DEFAULT_DELAY), [hide]);\n```\n\n요로코롬...\n\n근데 생각해보면 useCallback으로 써도 괜찮을 것 같네요!\n\n```tsx\n  const hideAfter = useCallback(debounce(hide, DEFAULT_DELAY), [hide]);\n```\n\n> 이런 Provider 구현 시 useReducer가 더 좋을까요? 저는 useState로 상태값을 두고 handle함수를 Provider 내부에 둔 상태가 한눈에 보여 파악하기 쉽다고 생각했습니다! 코치님은 useReducer를 선호하시나요?? 이유도 궁금합니다!\n\n복잡한 상태를 다룰수록 reducer가 좋다고 생각합니다 ㅎㅎ\n물론 state로 구현해도 충분하지만요!\nreducer로 만들면 순수함수가 되고, 순수함수는 테스트하기가 용이해지는 장점도 있답니다!\n\n다만 이건 팀 컨벤션이 제일 중요하다고 생각해요. 제가 reducer를 쓴 이유는 학습에 대한 이유도 있답니다! 아마 useReducer 자체가 익숙하지 않은 사람들도 많을 것 같아서, 이렇게도 사용할 수 있다는걸 보여주고 싶었어요.\n\n> 얕은 비교 함수를 구현하고나서 Zustand 코드를 살펴보았는데 Map과 Set, Symbol.iterator, 일반 객체를 분리해서 순회하는 부분을 보았습니다. 저는 따로 분리하여 처리하지 않았는데 처리하지 않았을 때 문제가 될 부분이 있을까요?\n\nMap, Set 등을 처리할 때 문제되겠죠!? 사실 실무에서는 대부분 만들어진 것들을 사용하기 때문에, 내부가 어떻게 동작하는구나 정도만 알고 있어도 충분하다고 생각해요 ㅎㅎ\n\ndeppEqual도 fast-deep-equal 같은 라이브러리를 사용한답니다 ㅋㅋ",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/10"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "윤영서",
    "feedback": "더 했으면 좋겠다고 하니 정말 더 하셨네요.\n영서님 고생하셨습니다.\n따로 과제나 회고에 대해서는 피드백을 드릴건 정말 잘 작성해주셔서 없을것 같고 다른 분들도 이걸 함께 나눠봤으면 좋겠네요.\n작성된 하나하나의 주제들이 생각해보면 크고 알차기 때문에 발표나 글로..해서 하면 참 도움이 될 것 같고 좋겠네여\n\n테스트 관련해서 답변해보면 노드 환경에서 할 수 있는 최대한의 시나리오 테스트 였던 것 같아요. 이 시스템 자체를 구현하는 관점에서 명확하게 하면 좋은 테스트이고 유의미했다고 생각해요. 다만 알겠지만, 해당 동작은 브라우저 구현에 달려있는 부분이 어느정도 있고 그게 잘 되었다는 가정하에 내용을 검증하는 것이기 때문에 지금 이벤트를 구현하는데 있어 복잡도가 높다보니 운영하는데 있어 그정도 효용이 있나~ 정도만 고민해보면 되지 않을까! (실제 모듈입장에서는 검증하는 범위가 같을 수도 있을 것 같아서요)\n\nuseEffect 구현 관련해서는 제가 알기로도 effect queue를 리액트에서 별도로 관리하기 때문에 큐를 별도로 쓰거나 하긴 해야할 것 같은데요. 아니면 setTimeout이나 Promise로 비슷...하게는 할 수 있을 것 같은데 직접 구현을 해봐야겠네요.\n사실 알다시피 테스트는 이 과제를 위한 테스트이니 저도 추측이지만 waitFor를 사용해서 기다리는 게 어느정도 필요하지 않을까 싶어요. 저도 궁금한데 요거 한번 해보고 알려주실수 있나요? ㅎㅎㅎㅎ\n  \n고생하셨고 회고에서 남긴것처럼 코테전형이나 면접 일정이 남아있다고 하셨는데 준비 잘 하시고 우선순위 잘 나눠서 시간분배 잘 하고 과제 하셨으면 좋겠습니다. ",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/13"
    }
  },
  {
    "passed": true,
    "name": "이가은",
    "feedback": "안녕하세요 가은님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 너무 고생하셨습니다!\n\n> useAutoCallback은 나중에 적극적으로 도입해보고 싶어요. ESLint exhaustive-deps 규칙 위반으로 의존성 배열에 eslint-disable 주석 처리하던 부분을 사용하지 않고 의존성 배열을 신경쓰지 않아도 되서 실무에서 사용해도 너무 좋을 것 같다는 생각이 들었습니다.\n\n맞아요.. 저도 최근에 발견(?) 해서 유용하게 쓰일 수 있을 것 같다고 생각했고 부랴부랴 과제로 만든거였답니다 ㅋㅋ 알아봐주시니 감사할따름..\n\n> 테스트 코드에 대한 학습이 필요하다고 느꼈습니다. 테스트 주도 개발에 대해 익숙하지 않다보니 아직도 테스트 코드 기반으로 내부 로직을 이해하는데 시간이 오래걸립니다. (물론 발제 자료가 훌륭해서 많은 도움이 됩니다!) 하지만 주차별 과제를 진행하면서 계속 나아질 수 있는 부분이라고 생각하고 열심히 진행해보려고합니다 ☀️\n\n원하지 않아도 7주차에 디테일하게 학습할 수 있답니다 ㅎㅎ ~~짜증도 내면서~~\n\n> 현재 기능상에 문제는 없지만 useSyncExternalStore에 전달하고 있는 세번째 인자를 다음과 같이 사용해도 되는건지 궁금합니다. useStore에 serverSnapshot을 받는 경우를 생각하고 다음과 같은 코드로 사용해도 괜찮을까요?\n\n이게 금요일 코드리뷰 세션에서 했던 이야기군요! 결론은 \"서버에서 어떤식으로 동작할지에 대한 고찰이 필요함\" 이라고 생각해요. 이걸 라이브러리 코드 내부에 바로 지정하기보단 인자로 받아와서 처리해주는게 안전할 것 같네요!\n\n```tsx\nexport const useStore = <T, S = T>(\n  store: Store<T>, \n  selector: (state: T) => S = defaultSelector<T, S>,\n  serverSnapshot?: S // 서버사이드 스냅샷 옵셔널로 명시\n) => {\n  const shallowSelector = useShallowSelector(selector);\n  const { getState, subscribe } = store;\n  const value = useSyncExternalStore(\n    subscribe,\n    () => shallowSelector(getState()),\n    serverSnapshot ? () => serverSnapshot : undefined\n  );\n  return value;\n};\n```\n\n요로코롬..\n\n> ToastProvider에서 show와 hide 엑션을 최적화 하기 위해 코치님께서 언급해주신 최적화 방법중에 하나인 useState를 사용했습니다. useMemo를 사용하여 최적화 하신 분들도 많이 보였는데 기능상의 문제는 없으나 useState를 사용할 떄와 useMemo를 사용할때의 차이점이 궁금합니다. 분명 차이가 있을 것 같은데 어떤 점을 고려하고 선택해야할지 고민이에요.\n\n이 상황에서는 useMemo 를 사용하는게 목적에 더 적합하다고 생각해요! state는 \"상태 변이의 가능성\"을 염두하고 정의하는건고, useMemo는 \"값을 저장\"하는 목적으로 사용되는거라서요.\n그래서 지금 케이스에서는 useState보다는 useMemo가 좋다고 생각합니다!\n\n---\n\n고생하셨어요 가은님!!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/31"
    }
  },
  {
    "passed": true,
    "name": "이민재",
    "feedback": "민재님 고생하셨습니다 ㅎㅎ\n다른분들 PR에도 좋은 의견 많이 남겨주시고 리뷰 보니 명확한 기준을 가지고 잘 구현해주셨습니다 shallowEquals 접근도 좋은 접근이였습니다. 성능 최적화를 고려하고 작성해주신 것 같더라구요. \n일정 자체가 빠듯하고 순식간에 흘러가지만 말씀해주신것처럼 회고를 작성하고 이런 배경, 고민한 흔적들을 함께 나눌 수 있는 시간이 있으면 확실히 좋을 것 같아요. 저희가 따로 뭔가 이런 시간을 추후에 마련할 수 있을지 이야기를 나눠봐야 하지만 어렵다면 팀 내에서라도 꼭 이런 부분 주도적으로 해보셔도 좋을 것 같습니다 ㅎㅎ\n\n질문해주셨던 내용 답변 드려보면요!\n\n이 부분은 아마 여러 고민을 하셨기 때문에 저와 비슷할 것 같은데, 과거에는 모든 코드에 메모이제이션을 하는 파와 절대 하지않는다 파(?)로 나뉘어져서 막 논쟁이 있었던 것 같은데, 최근에는 그런 사람들이 많이 사라진 것 같아요. 일반적으로 저희가 따르는 최적화 논리대로 섣부른 최적화는 하지 않되, 성능적으로 이슈가 발생하는 지점이 생긴다면 그 지점에 대해서 파악한 뒤 그 부분만 국지적으로 처리하는게 적절한 사용 방법인 것 같아요. 내부적으로 이미 처리가 어느정도 되어있고 최근 들어서는 모든걸 해결해주는 관점에서 개발을 하는 것은 아니지만 컴파일러의 발전도 지속되고 있잖아요. 필요한 부분이 발견되면 그 때 적용하는 형태로 하면 좋을 것 같습니다.\n\n고생하셨고 다음 주도 지금처럼 팀원들과 함께 잘 진행해주시면 좋을것 같습니다. 고생하셨어요!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/25"
    }
  },
  {
    "passed": true,
    "name": "이유진",
    "feedback": "안녕하세요 유진님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨스비낟!!\n\n> 3주간 프레임워크 없이 SPA 만들기를 진행하면서 SPA 프레임워크의 동작 원리를 어느정도 알고있다고 생각했는데 알고있기는 커녕 저는 여태껏 궁금해 한 적 조차 없었다는 사실을 깨달았고, 자바스크립트 실력이 많이 부족하다는 것도 느꼈습니다.\n\n\"여태껏 궁금해한 적 조차 없었다는 사실\"이 인상적이네요 ㅋㅋ 언젠간 왜 이렇게 동작하는거지!? 라는 근원적인 궁금함을 느낄수 있으리라 생각해요!\n\n> useMemo에서 의존성 배열에 대한 depsRef와 factory 실행 결과를 저장하는 resultRef를 하나의 객체로 두는게 더 좋은 구조일지에 대한 고민을 했습니다. 하나의 객체로 두는 것이 더 나은 구조인지, 코치님께서는 어떤 방식을 선호하시는지 궁금합니다.\n\n저는 하나의 객체를 통해 관리하는게 더 좋지 않을까 싶어요! 사실 몇 개의 ref로 관리하든 큰 차이가 없긴 한데, 중요한건 사용성이라고 생각합니다. 하나의 ref로 관리해야 객체를 다루기가 더 쉽지 않나!? 라는 생각이랍니다.\n\n> 타입스크립트가 최대한 알아서 추론하게 두고, 타입 단언은 지양해라! 라는 내용을 늘 생각하면서 개발하고자 하는데요, 과제 구현 과정에서 타입 이슈 해결을 위해서 타입 단언을 사용한 부분이 꽤 있습니다. 이 중에서 특히 useMemo의 return 에서 한 타입 단언이 안전한지 궁금합니다.\n\n지금은 최선의 작업을 해주신 것 같아요. 물론 타입이 자연스럽게 추론되면 좋지만... 그렇지 못한 상황도 분명 있으니까요!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/32"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이은지",
    "feedback": "안녕하세요 은지, 수고했습니다! 이번 과제는 React의 내장 훅들을 직접 구현해보면서 프레임워크가 어떻게 상태를 관리하고 최적화하는지 깊이 이해하는 것이 목표였습니다. \n\n단순히 과제를 완성하는 것에 그치지 않고, React의 실제 동작 원리부터 Object.is의 세부 사항, useSyncExternalStore의 탄생 배경까지 깊이 있게 탐구하신 모습이 인상적이네요. 아주 잘했습니다!\n\n특히 Hook의 상태 관리가 연결 리스트 구조로 되어있다는 점을 발견하고, 왜 훅을 조건문 안에서 쓰면 안 되는지 원리적으로 이해하신 부분이 참 좋네요. 이론으로만 접근하면 단순히 하면 안되는 Rule정도로 치부할 수 있지만 실제로 만들어 보니 그럴 수 밖에 없구나 하는 식으로 귀결이 되는 지식이 쌓이는 것이 깊이를 이해하는 것이지요.\n\n그밖에도 isArray, isObject 등 유틸리티를 별도 파일로 분리해서 예측가능한 코드를 잘 분리해둔 부분도 좋았습니다.\n\n이번 과제를 통해 React가 제공하는 편리한 API들이 내부적으로 어떤 문제를 해결하고 있는지 몸소 체험하셨을 거예요. 특히 \"메모이제이션은 만능이 아니다\"라는 깨달음과 함께 구조적 개선의 중요성을 인식하신 점이 훌륭합니다.\n\n---\n\nQ) useRef를 useState 없이 구현할 방법이 없을까요?\n\n=> 함수는 특성상 재실행될 때마다 내부 변수들이 초기화되기 때문에, 상태를 유지하려면 함수 외부의 값을 사용해야 하지요.\n\n그렇게 하기 위해서는 전역변수, 혹은 레퍼런스 객체, 혹은 클로저 등을 사용하는 방식이 있습니다. 이중에서 전역변수는 답이 아니니 React도 내부적으로 FiberNode의 memoizedState에 저장하는 방식을 사용하죠. \n\n그리고 두번째는 값을 보관해서 가져오는 방식입니다. 기존의 데이터에서 값을 가져오기 위해서는 정확한 위치를 알아야 하죠. 그러면 선택할 수 있는 방법은 같은 객체를 사용해서 값을 가져와서 prop에 접근하거나 index혹은 key이름을 통해서 가져오는 방식등이 있습니다.\n\nuseState는 index를 통해 접근하는 방식, useRef는 객체에 접근하고 current를 사용하는 방식을 사용했죠.\n\n위와 같은 응용법을 이용해서 useRef와 useState의 체계를 별도로 구성하는 방법이 없지는 않겠지만 같은 리렌더링 체계를 공유하고 있으므로 상태를 관리하는 공통적인 방법을 가지고 만드는 방식이 가장 효율적인 체계입니다.\n\n\nQ) useMemo를 useRef 사용없이 구현할 방법이 없을까요?\n\n=> 안될 이유는 없지만 이미 상태관리의 추상화 계층을 만들어 두었는데 활용하지 않는 건 매우 비효율적인 방식입니다. 이미 Array라는 배열을 다루는 방식이 있는데 굳이 List라는 새로운 계층을 사용하는 거죠. \n\n렌더링 간 값을 유지해야 하는데, useState를 사용하면 setState로 인한 불필요한 리렌더링이 발생하고, 전역 변수를 사용하면 컴포넌트 인스턴스 간 상태가 공유되는 문제가 생깁니다. useRef가 바로 이런 문제를 해결하기 위한 훅이므로, 메모제이션의 값을 보관하기에는 적절한 도구이죠. 대안을 찾기보다는 적절한 도구를 사용하는 것이 맞다고 생각해요.\n\n수고하셨습니다. 깊이 있는 탐구와 실험 정신이 정말 인상적이었어요. 다음 클린코드 챕터에서도 이런 열정으로 좋은 인사이트를 얻으시길 바랍니다. 화이팅입니다! :)",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/49"
    }
  },
  {
    "passed": true,
    "name": "이의찬",
    "feedback": "안녕하세요 의찬, 수고하셨습니다! 이번 과제는 React의 내장 훅들을 직접 구현해보며 프레임워크가 어떻게 상태를 관리하고 최적화하는지 내부 원리를 깊이 이해하는 것이 목표였습니다. React가 제공하는 편리한 API들이 내부적으로 어떤 문제를 해결하고 있는지 체험하셨기를 바랍니다.\n\nAI 활용에 대한 성찰적인 접근이 인상적이네요. 쓰면 안된다 써야 된다 이분법 적인 부분도 아니고 적게 써야 내것이 된다도 아니고 직접 다양하게 체험하면서 나에게 맞는 사용법을 익혀가는 것이 중요한 방식이죠. 적절한 나만의 노하우들을 많이 만들고 또 많이 공유해보면 좋겠습니다.\n\n메모이제이션과 ToastProvider에 대해 추가 학습하고 싶다고 하셨는데, 이는 실무에서도 매우 중요한 개념들입니다. 메모이제이션은 \"만능이 아니다\"라는 점을 인지하는 것이 중요하고, Context 분리를 통한 렌더링 최적화는 실제 프로젝트에서 자주 마주치는 과제입니다!\n\n수고하셨습니다. 이번 Deep Dive 경험이 앞으로의 개발 여정에 든든한 기초가 되었기를 바랍니다. 클린코드 챕터도 잘 부탁드려요! 화이팅입니다 :)",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/36"
    }
  },
  {
    "passed": true,
    "name": "이정우",
    "feedback": "안녕하세요 정우님~\n3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n다만 과제 PR에는 내용이 많이 없어서 아쉽네요 ㅠㅠ\n많이 바쁘셔서 그런거겠죠!?\n저도 백엔드 과제 불합격이라 어떤 심정인지 알 것 같아요.\n그래도 다음에는 잘 작성해주세요~! 화이팅입니다!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/52"
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "지현님 고생하셨어요!\n필요한 부분에 대해서 명확하게 잘 구현해주셨네요.\n과제를 진행하시면서 실제로 preact나 react구현도 살펴보시고 직접 옮겨오시면서 많은 부분을 학습하실 수 있었던 것 같아서 좋네요 :+1\n\n궁금해하셨던 부분 먼저 답변 드려보면요.\n\n> contextAPI를 활용한 코드를 작성하다보면 어떻게 파일 및 코드 분리를 해놓을지 고민이 되기도합니다.\n\n일반적으로 제가 쓰는 경우에는 해당 로직이 복잡해지는 경우 Context, Provider와 사용하는 훅을 분리해서 파일로 관리하기도 하는데요. 다만, 요즘의 상태가 그리고 전역 상태를 사용하는 케이스가 UI관련된 단순한 케이스들이 많기 때문에 하나의 파일로 관리하는 경우도 종종 있는거같아요!\n\n규모가 어느정도로 커지냐를 기준으로 잡고, 그리고 컨텍스트를 프로젝트에서 얼마나 사용하는지를 기준으로 해서 판단하고 나누면 좋을 것 같아요 ㅎㅎ\n\n> Object.is와 shallowEquals를 보면서 궁금했던 부분이 있습니다.\n\n넵 나름 합리적인 접근 방법인 것 같아요 ㅎㅎ \n밑에 희진님이 남겨주신 강조의 표시 처럼 \"\"확실\"하다면 저장되는 데이터를 기준으로 비교 로직을 다르게 가져갈 수 있을 것 같아요.\n다만, 그렇지 않다면 일관적이게 비교를 하고 옵션 형태로 제공해서 사용하는 측에서 성능 최적화를 할 수 있게 하는 것도 방법일 수 있을 것 같아요.\n\n고생하셨고 다음 주 과제도 화이팅입니다!!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/17"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이지훈",
    "feedback": "지훈님 고생하셨습니다!\n농담처럼 재미때문이라고 말씀해주시기는 하는데 저번 주에 말씀드린 것처럼 함께 팀원분들 특히 정석님과 함께 성장해나가는 모습이 너무 보기 좋네요 ㅎㅎ\n필요하신 부분 딱딱 코드도 깔끔하게 코드도 작성해주셨고, 학습한 내용도 문서로 잘 남겨주셨네요 :+1 이 방식은 학습하는데 정말 도움이 많이 될 것 같아요.\n지금까지 정리한 내용을 기반으로 하나의 rules를 만들어서 앞으로 AI로 생성하는 코드의 규칙을 만들어 올바르게 생성하게 할 수도 있을 것 같구요 ㅎㅎ\n\n작성해주셨던 질문 답변 드려보면요!\n\n> 자주 사용하는 커스텀훅이 있는지 궁금합니다. useAutoCallback 처럼 기존 훅을 더 쉽게 사용할 수 있도록 만든 훅들이 있을까요?\n\n당시에는 이런 저장소들을 많이 참고하고 사용하고 했었는데요.\n* https://github.com/streamich/react-use\n* https://github.com/rehooks/awesome-react-hooks\n\n이런 유틸성 훅들을 가져다가 구현적 이점을 많이 누렸던 것 같아요 ㅎㅎ 이미 알고 계실거 같지만 아직 모르시다면 요거 참고해보면 좋지 않을까!\n\n> 메모이제이션을 사용하다 보면 결국 모든 값을 메모이제이션 해야 하는 상황들이 발생하는 것 같은데, 모든 컴포넌트와 값들에 메모이제이션을 적용하는건 어떻게 생각하시나요? 물론 불필요한 비교 과정은 비효율 적이지만, 코드를 지속적으로 유지보수하면서 메모이제이션을 알맞게 사용하기 어렵다 느껴져서 질문 드립니다.\n\n음..! 우선 저는 모든 값을 메모이제이션 해야하는 상황이 그렇게 막 오지는 않을 것 같은데요. 과거에는 모든 코드에 메모이제이션을 하는 파와 절대 하지않는다 파(?)로 나뉘어져서 막 논쟁이 있었던 것 같은데, 최근에는 그런 사람들이 많이 사라진 것 같아요. 일반적으로 저희가 따르는 최적화 논리대로 섣부른 최적화는 하지 않되, 성능적으로 이슈가 발생하는 지점이 생긴다면 그 지점에 대해서 파악한 뒤 그 부분만 국지적으로 처리하는게 적절한 사용 방법인 것 같아요. 내부적으로 이미 처리가 어느정도 되어있고 최근 들어서는 모든걸 해결해주는 관점에서 개발을 하는 것은 아니지만 컴파일러의 발전도 지속되고 있잖아요. 필요한 부분이 발견되면 그 때 적용하는 형태로 하면 좋을 것 같습니다.\n\n이번주도 고생하셨고 다음주도 이번주처럼 화이팅 하시고 뿌숴주세요!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/14"
    }
  },
  {
    "passed": true,
    "name": "이진희",
    "feedback": "안녕하세요 진희님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨씁니다!\n\n---\n\n> 코치님은 이런 경우, 어디까지를 \"분리할 만한 단위\"로 보시는지 의견이 궁금합니다.\n\n저는 함수의 추상화 수준이 제일 중요하다고 생각합니다.\n가령 equals 함수를 토대로 생각해보자면\n\n```tsx\nif (원시타입) {\n  ...\n}\n\nif (배열) {\n  ...\n}\n\nif (객체) {\n  ...\n}\n\nreturn false\n```\n\n차라리 이렇게 전체적으로 함수를 사용하는 모습이 아니라고 가정했을 때, 조금 도 융통성(?)이 있죠 ㅎㅎ 그런데 한 부분만 함수로 분리되어있다고 가정해보면\n\n```tsx\nif (원시타입) {\n  ...\n}\n\nif (이건배열임) { return 배열일때처리함() }\n\nif (객체) {\n  ...\n}\n\nreturn false\n```\n\n이러면 \"저 구간은 왜 함수로 분리된거지?\" 라는 의문이 생길 수 있어요.그래서 차라리 이렇게 전체적으로 함수로 분리해서 \"추상화 수준\"을 유지해야 한다고 생각합니다.\n\n```tsx\nreturn pick(\n  [원시타입일때(), 원시타입처리()],\n  [배열일때(), 배열처리()],\n  [객채일때(), 객체처리()],\n  [전부다아니면False()]\n)\n```\n\n대충 이런 모습이랄까..\n\n아니면 타입가드만 함수로 분리하거나 혹은 각 타입에 대한 내부 구현을 함수로 분리하는 등 여러가지 방법이 있겠네요 ㅎㅎ\n\n> 명확함을 위해 긴 네이밍을 쓰는 게 좋을까요? 저는 변수나 함수 이름을 지을 때, isEnabledByUserAction, fetchPostsByCategoryId처럼다소 길어지더라도 형용사나 전치사(by 등)를 붙여서 더 명확하게 표현하는 걸 선호하는 편입니다. 그런데 코드 리뷰를 하다 보면, 길다는 이유로 이름을 더 간결하게 바꾸자는 피드백을 받는 경우도 있어서 고민됩니다. 코치님은 협업 코드에서 가독성과 간결성 사이의 네이밍 밸런스를 어떻게 잡으시나요? 그리고 긴 이름이더라도 명확하면 괜찮다고 보는지, 혹은 더 좋은 네이밍 전략이 있는지 궁금합니다.\n\n저는 함수가 쓰이는 맥락이 중요하다고 생각해요.\n가령, 어디서든 독립적으로 쓰이는 함수의 경우 말씀해주신 것 처럼 구체적인게 좋지만,\n네임스페이스나 훅을 통해 정의되는 함수는 이렇게 쓰일 수도 있겠죠!?\n\n```tsx\n// 객체로 쓰일 때\nuserAction.isEnabled();\npostsService.fetchByCategoryId();\n\n// 혹은 훅으로 쓰일 때\nconst userAction = useUserAction();\nconst posts = usePosts();\n\nuserAction.isEnabled();\nposts.fetchByCategoryId();\n```\n\n그런데 네임스페이스와 중복된다면 조금 읽는게 불편한다고 생각해요.\n\n```tsx\nuserAction.isEnabledByUserAction();\nposts.fetchPostsByCategoryId();\n```\n\n그래서 이 함수가 어떤 맥락에서 쓰이는지를 토대로 구체성을 정의해야 한다고 생각한답니다!\n\n",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/7"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "태영님 이번 한 주 알차게 보내신게 회고에서 드러나네요 ㅎㅎ\n과제는 당연히 잘 작성해주셨고 정리한 내용도 각각 문서로 만들어서 정리해주셨네요. (요거는 직접 작성해주셨으려나요?)\n명확하게 잘 정리해주셨고 나중에 이 과제를 다시 봤을때에도 귀중한 자료가 되지 않을까 싶습니다 :+1\n\n질문 주셨던 내용 답변드려보면요! \n\n> Docs 문서나 글을 통해 제가 직접 Auto-Memoization, Compiler... 그래서 추후에 이게 반영이 된다면 기존과 어떤 차이점이 있는데? 를 파악해야 하는데 현재는 React Compiler로 useMemeo, useCallback 안 써도 되겠다. 싶은 생각 정도까지 했습니다.\n\n이 부분에 대해서는 꾸준히 저도 트래킹하고 있는데요.\n결론적인 답변을 원하셨으니 말해보면.. 지금의 수준에서는 모든걸 대체하기에는 어려워보여요. 다만, 초창기에 비해서는 최적화수준이 많이 올라왔고 처음에 제가 이걸 접했을 때는 못쓸거라고 생각했지만 지금은 대체가 될 수도 있겠다라는 생각이였거든요. 비슷한 라이브러리에서는 이미 해당 기능을 제공하고 있고 리액트 측에서도 이 기능을 완성시키겠다고 공언을 이미 했고..라이브러리 시장에서 리액트가 안좋다! 라는 근거로 가장 많이 쓰이는 부분이기 때문에 어떻게든 되게 만들지 않을까 라는 생각이긴해요.\n\n다만, 지금처럼 가야한다면 명확한 메모이제이션 사용법에 대해 이해하고 각각 사용해야 하며 컴파일러는 부수적인 도움을 주는 역할이다라고 봐야하지 않을까 싶습니다. RC인 만큼 계속 트래킹을 해야할거같아요!\n\n> 추가적으로 React docs나 그 외 다른 어떤 개발적인 내용을 공부 할 때 어떤 식으로 확인하고 공부하는 것이 좋을까요?\n\n이 부분에 대해서는 \n1. 궁금한 것을 기준으로 명확한 공부의 범위 또는 주제를 단일로 지정하세요.\n2. 그리고 그걸 도달하기 위해 가는 과정을 본격적으로 공부하기전에 추측하고 적어보세요.\n3. 공부를 하는 과정에서 정말 도움이 되는 부분이라면 정리해둔 목차에 추가를 하고, 아니다 싶으면 목차를 제거해보세요. 다만, 이 목차를 추가하는 시점에 처음 지정한 범위를 벗어난다 싶으면 키워드만 적어두고 넘어가세요. 이 키워드는 다음 공부에서 주제가 될 수 있겟죠?\n4. 그리고 이 목차를 채우면서 주제에 대한 결론을 낼 수 있으면 마무리하세요\n\n말씀해주신것처럼 새로운 기술에 대해 너무 자주 나오고, 공부할 것도 너무 많죠. 다만 그냥 꼬리 물기로 공부하다보면 내가 궁금해 했던 것들을 이해하지 못하게 되고 확장적인 생각을 갖는데에도 좋지 않은것 같아요.\n저는 저런식으로 공부를 많이 해서 도움을 받았는데 한번 해보고 다음에 함께 이야기 나눠보면 좋겠네요!\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/16"
    }
  },
  {
    "passed": true,
    "name": "임규원",
    "feedback": "안녕하세요 규원! 수고하셨습니다. 이번 과제는 React의 내장 훅들을 직접 구현해보면서 프레임워크가 어떻게 상태를 관리하고 최적화하는지 이론을 넘어 몸으로 깊이 이해하는 것이 목표였습니다.\n\nAI 의존도를 줄이고 스스로 고민하며 구현하려는 태도 칭찬합니다. 사실 한번 편리를 경험하면 스스로 안하겠다 생각하기가 쉽지 않았을텐데 수고했어요. \"설계 친구 AI\"라고 표현하신 것처럼, AI를 설계 가이드로만 활용하고 직접 구현해보신 과정이 정말 값진 학습 경험이었을 것입니다. \n\n답답하겠지만 그 만큼 스스로 생각하는 힘이 길러졌을거라고 생각해요. 노션의 정리 과정도 좋았습니다.\n\n이번 과제를 통해 React가 제공하는 편리한 API들이 내부적으로 어떤 문제를 해결하고 있는지 몸소 체험하셨을 거예요. 특히 렌더링 최적화와 상태 관리에 대한 깊이 있는 이해를 얻으셨기를 바랍니다.\n\n---\n\nQ) 실제로 이렇게 많은 useMemo 사용이 일반적일까요?\n\n=> 좋은 질문이에요! 실무에서는 이렇게 많은 useMemo를 한 컴포넌트에 사용하는 경우는 드뭅니다. useMemo를 쓴다는 건 리렌더링이 되는 그룹이 2개이상으로 나눠진다는 건데 그렇다는 건 컴포넌트가 단일책임하지 않을 확률이 높기 때문입니다. 대부분의 경우는 컴포넌트를 단일책임하게 만들면 useMemo를 써야할 이유가 많이 없습니다.\n\n수고하셨습니다. 재밌었다! 라는 말로 시작한 것 처럼 계속해서 클린코드 과제도 재밌기를 바래요. 화이팅입니다! :)",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/39"
    }
  },
  {
    "passed": true,
    "name": "임두현",
    "feedback": "안녕하세요 두현, 수고하셨습니다! 이번 과제는 React의 내장 훅들을 직접 구현해보면서 프레임워크의 내부 동작 원리를 깊이 이해하는 것이 목표였습니다. \n\n\"...개인적으로 효과가 좋다고 생각하는 학습방식이 있습니다.\n원리를 다 파악하고 실제로 활용하는 것보다는, 일단 원리도 모르는 상태에서 다들 하는대로 적용하고 보는 것입니다.\n그렇게 익숙해질 즈음에 다시 이론적인 개념을 파악하면 그 때 이해가 쏙쏙 됩니다. ...\"\n\n저희 과제의 취지에 너무 부합하는 말이라 좋았습니다. 언제든 새로운 개념을 학습하게 되면 최소한의 방식으로 직접 구현해보는 것이 그 개념을 이해하는데 가장 크게 도움이 되는 것 같아요. 상태관리나 서버상태관리등도 꼭 이러한 방식으로 접근해보기를 바랍니다.\n\nContext와 상태관리에 대한 철학적 고민도 인상깊었습니다. props drilling을 통한 명시적 데이터 흐름을 선호하시는 이유가 매우 합리적이에요. 특히 \"데이터 흐름이 명확하게 보이는 것\"의 가치를 아시는 것은 복잡한 애플리케이션을 다룰 때 큰 도움이 될 거예요.\n\n클린코드 시간에는 이러한 여러가지 철학적 베이스로 어떤 코드가 더 좋은 코드가 될지 함께 고민해보는 시간을 가져봅시다! 수고하셨습니다. 다음 클린코드 챕터에서도 이런 탐구 정신을 발휘해서 더욱 성장하시길 바랍니다! 화이팅입니다! :)",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/45"
    }
  },
  {
    "passed": true,
    "name": "장루빈",
    "feedback": "안녕하세요 루빈님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 이런 과제를 수행한다면 코치님은 AI를 어떻게 활용할 것인지 궁금합니다.\n\n저는 딱 영서님이 진행하신게 생각나는데요,\n내가 고민이 되는 부분에 대해 더 딥다이브를 할 때 사용할 것 같아요 ㅎㅎ\n\n과제는 \"학습을 위한 수단\"을 수단이라고 생각하고, 학습에 대한 설계는 결국 스스로 하는거죠.\n가령, 제가 1년차 때\n\"간단한 할 일 목록\"이라는 주제로 코드를 작성했어요. 필수기능을 일단 다 구현해놓고\n여기서 난이도를 최도로 높여서 내가 할 수 있는 최대 수준의 오버엔지니어링을 하는거죠\n\n그리고 오버엔지니어링을 하면서 습득하는 지식을 정리해서 글로 작성한다거나!?\n이런 방식으로 진행할 것 같아요.\n\n이번 과제의 경우 hook을 만드는게 주제인데요,\n지금은 useState를 통해 만들어가고 있는데\n\n아예 \"모든 시스템을 내가 처음부터 만들어간다면 어떻게 될까?\" 라는 가정을 해보는거죠.\n혹은 여태까지 만들어놓은 훅을 이용하여 app 폴더에 적용해본다거나?\n새로운 기능을 만들어본다거나?\n\n이런 시도를 할 것 같습니다 ㅎㅎ\n\n정해진 틀을 계속 깨부수는 연습을 해보시면 좋겠어요!\n\n> 이번 과제는 완료하는 것을 목표로 했습니다. 과정을 완벽하게 이해하지 않고 넘어간 부분도 있으나 pr을 작성하면서 재학습하는 식으로 진행했는데요 정리한 내용중에 모호하거나 본질적인 내용과 거리가 있다면 그것이 궁금합니다!\n\n잘 진행해주셧다고 생각합니다! PR을 작성하면서 복습하는 과정도 잘 해주셨어요! 이렇게 해야 기억에 남는 것 같아요 ㅎㅎ 고생하셨습니다!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/54"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "장희진",
    "feedback": "희진님 고생하셨어요!\n회고를 보니 명확하게 과제를 통해 어떤 부분을 학습하셨는지 설득력있게 다가와서 저도 많이 보고 배웠네요.\n개발자 도구를 통한 분석이나 원인을 파악하고 해결해나가는 모습도 좋았네요 :+1 말씀해주신 것처럼 해당 부분에 있어서 한번 꼭 찾아보셨으면 좋겠네요.\n과제는 당연히 잘 작성해주셨습니다 ㅎㅎ\n\n그럼 작성해주신 질문 이어서 답변 남겨볼게요.\n\n> Context 대신 createStore를 사용해 전역 상태를 분리했는데, 기존 Context 기반 상태 관리에서 발생하던 불필요한 리렌더링 문제를 효과적으로 줄일 수 있었습니다. 다만, createStore의 구독 범위를 어떻게 최적화해야 하는지, 상태 접근 시 필요한 최소한의 구독만 유지하는 좋은 패턴이 무엇인지 아직 명확하지 않습니다. 이와 관련해 권장하는 설계 방식에 대해 조언 받고 싶습니다.\n\n음 제가 질문을 제대로 이해했는지 조금 헷갈리지만, 이런 식으로 스토어를 구성하다 보면..일반적으로 고민하는 것처럼 셀렉터 함수를 분리하고 별도로 필요한 데이터만 구독하는 형태로 운영되면 성능적인 측면에서도 좋을거에요. 또는 구독되는 아이템들을 기반으로 메모이제이션을 걸어 셀렉터를 생성할 수 도 있을 것 같구요. 이 과정에서 이런 최적화가 이전에 작성해주셨던 것처럼 실제 렌더링 성능에 어떤 영향을 미치고 개선을 했을 때 얼마나 나아지는지는 함께 체크해보면 좋을것 같아요!\n\n> 저는 지금까지 React 프로젝트에서 Context보다는 주로 Zustand 같은 전역 상태 관리 라이브러리를 활용해 왔습니다. 실무에서도 큰 문제 없이 상태 관리가 잘 되었고, 성능 이슈도 거의 경험하지 못해 Context에 대해서는 상대적으로 크게 신경 쓰지 않았던 것 같습니다.\n이번에 Context에 대해서도 배우고 이해했지만, 앞으로도 단순한 전역 상태에서도 Zustand 같은 상태 관리 라이브러리를 사용해도 크게 문제가 없을 것 같다는 생각이 듭니다.\n코치님께서는 실무에서 꼭 Context를 사용해야 했던 특별한 상황이나 이유가 있으셨는지 궁금합니다.\n\n실무적인 관점에서 최근 상태를 관리하는 방식은 서버 상태와 UI를 위한 전역 상태 관리로 나뉘는 것 같아요. 그럼 여기서 말씀해주시는 zustand같은 것들은 후자를 관리 하기 위한 상태일텐데요. 말씀해주신것처럼 context를 사용하다보면 직접 각 구역을 나눠 렌더링 최적화를 진행해줘야 하기 때문에 오히려 번거로운 지점이 많이 생기는 것 같아요. 과거에는 이런 전역 상태 관리 라이브러리의 크기가 크고 보일러 플레이트 코드가 많아졌었는데, 이런 지점은 zustand나 jotai로 들어서면서 매우 경량화가 되고 사용도 용이해져서 더 이상 저는 중요하지는 않다고 생각이 들더라구요. \n\n개인적으로는 너무 프롭 드릴링이 발생하는 것이 아니라면 각 컴포넌트에서 관리를 하고 필요해지는 시점이 오면 그때 부담없이(?) 선택을 하면 되지 않을까 라는 생각입니다. 반드시 context를 사용해야만 하는 경우는 없었던 것 같아요.\n\n이번 주 과제 너무 잘해주셨고 다음주도 이번주처럼 화이팅입니다~",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/27"
    }
  },
  {
    "passed": true,
    "name": "정건휘",
    "feedback": "건휘님 이번에도 무난히 합격하셨네요 :) \n과제  MR에 회고 내용이 없던데(금요일 오후7시 기준)\n제가 뭔가 잘못본건 아닌지 모르겠네욥.\n내용을 보면 각 모듈을 스펙을 md로 만들어뒀던데 호오.. 이건 뭔죵 ㅎㅎ\n수고많으셨습니다!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/44"
    }
  },
  {
    "passed": true,
    "name": "정도은",
    "feedback": "안녕하세요 도은님! 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 개인적으로는 리액트 같은 도구를 쓰는 이유가 개발 편의성에 있다고 생각해서 뭔가 문제가 생기기 전까지는 리액트에게 최적화 기능을 전담하고 기능구현 하는 방식을 선택했던거 같습니다..ㅎㅎ 지금도 사실 어떤 상황에서 메모이제이션을 적용해야 하는지 판단하는 게 쉽지는 않네요. 나중에 병목이 생기면 하나하나 뜯어보면서 깨닳아보겠습니다.\n\n저도 이런 전략이 좋다고 생각합니다 ㅋㅋ 사실 많이 써보질 않으면 필요성을 느끼는 것 자체가 어렵다고 생각해요.\n\n> 컨텍스트는 해당 페이지 또는 UI 범위 내에서만 사용하는 간단한 값을 공유할 때 사용합니다. (예: 테마, 언어 설정, 모달 상태 등)\n\n제 생각과 똑같네요!!\n\n> 상태관리 라이브러리는 구조적으로 직접 연결되지 않은 컴포넌트들 간에 데이터를 전달해야 하거나 앱 전역에서 일관된 상태가 필요한 경우에만 사용합니다.\n\n제가 항상 상태관리를 언제써야할까? 라고 설명할 때 용어 정리가 안되서 어려웠는데 이걸 한 문장으로 잘 정리해주셨어요!! 속이 뻥 뚫리는 기분입니다 ㅎㅎ\n\n> 상태관리로 처리하면 데이터를 주고받기는 편하지만 프로젝트가 커질수록 상태 흐름을 파악하거나 유지보수하기 어려워진다고 생각되어\n\n이건 저와 다른 생각인데요, 저는 오히려 프로젝트가 커질수록 상태관리 라이브러리를 통해 제어하는게 중요하다고 생각했어요 ㅎㅎ\n상태 변이를 상태관리에서 제공하는 함수를 통해 추적만 하면 되니까요!\n그런데 상태관리가 없다면... 전체적인 구조를 이해해야 이 상태가 어디에 어떻게 전파되는지 알 수 있기 때문에 훨씬 이해하는데 시간이 오래 걸린다고 생각해요.\n\n> ToastProvider에서 useMemo vs useCallback 선택 기준\n\n어차피 useCallback도 useMemo로 만드는거라서요 ㅎㅎ\n이 상황에서 useCallback을 사용한다고 가정해보면\n`useCallback(debounce(hide, DEFAULT_DELAY), [hide])` 처럼 정의할 수 있을 것 같아요!\n\nshowWithHide의 경우, useAutoCallback도 좋고 useCallback도 좋습니다. 다만 useAutoCallback은 값을 캐싱한다기보단, 참조를 캐싱하는거라서, debounce 처럼 실제 \"함수의 과거 상태\"를 유지해야 하는 경우에는 적합하지 않을 수 있답니다 ㅎㅎ\n\n언제나 최신 값을 참조해야 한다면 useAutoCallback을 쓰는게 좋을 것 같아요!\n\n> 타입 안정성 vs 개발 생산성 중 어느 것을 우선해야 하는지\n\n지금 당장 일정이 급해서 미치겠따! 라는 상태가 아니라면 저는 어떻게든 타입 안정성을 더 채우려고 하는 편입니다 ㅎㅎ 그래야 장기적으로 봤을 때 생산성이 더 높아지니까요!\n\n> 팀에서 타입 우회를 허용할 명확한 기준이 있으신지\n\nPR 올린 다음에 말씀해주신 type ignore lint 가 있으면 팀원들이 먼저 물어보기도해요. 혹은 대신 해결해주기도 하거나!?\n\n다만 메모이제이션에 대한 판단 사례처럼, 결국 타입을 제대로 학습하려면 타입과 관련된 문제들을 많이 겪어봐야 한다고 생각합니다. 타입 오류가 있으면 이를 기회삼아 공부하는거죠 ㅎㅎ",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/9"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "정민기",
    "feedback": "안녕하세요 민기님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n---\n\n\n리액트 렌더링 과정을 무척 재밌게 서술해주셨어요 ㅋㅋ 다른 사람들도 이해하기 쉽도록 만들어주셨네요!!  재밌게 작성해주셔서 감사합니다 ㅎㅎ\n\n> 2번의 무조건 메모이제이션 전략은 과연 괜찮을까에 대한 고민이 있었다. 개발 과정에서 메모이제이션(Memoization)을 적용할지 말지를 고민하는 것 자체가 때로는 더 큰 비용과 병목 현상을 초래한다. 적절한 순간에 메모이제이션을 해야지라고 판단하고 적용 포인트를 찾는 데 드는 시간과 인지적 부하가, 실제로 얻게 될 성능 이득보다 커질 수 있다는 의미가 됨. 내나름의 결론은 그냥 다 적용하자라고 생각이든다.\n\n물론 저의 의견을 따라가는 것도 좋지만, 추후에 민기님께서 스스로 납득할 수 있는 경험을 해보는게 중요하다고 생각해요! 그러기 위해선 많이 해보는 방법 밖에는.... 없을 것 같네요 ㅋㅋㅋ 여튼 화이팅입니다!\n\n> ToastProvider 구현중 질문드립니다. 저는 useCallback을 사용하였는데요. 다른분들은 useAutoCallback을 사용하신분들이 몇분 있으시더라구요. showWithHide는 stableShow만 의존성으로 갖고 있고, stableShow는 useCallback(show, [])로, 사실상 불변. hideAfterRef는 ref이므로, ref 객체 자체는 변하지 않아보입니다. 즉, 현재의 의존성 배열([stableShow])은 사실상 빈 배열과 동일한 효과를 내는거같아보입니다. 현재처럼 의존성이 명확하고, 특별히 바뀔 일이 없는 경우에 useAutoCallback을 쓰는게 오히려 더 좋은 판단이였을까요? 아님 더 좋은 방안이 있었을까요..?\n\n잘 살펴보시면 구현된 내용이 useAutoCallback과 굉장히 유사한데요, 지금 코드 그대로 useAutoCallback으로 바꾸면 사실 동작은 똑같습니다.\n\n```tsx\nconst hideAfter = useAutoCallback(debounce(hide, DEFAULT_DELAY));\n```\n\n다만 useAutoCallback의 문제는, 함수를 고정시키는게 아니라 변화시킨다는 점입니다. 그래서 이럴 때 오히려 useAutoCallback이 아니라 useMemo나 useCallback을 사용해야 정상적으로 동작할 것 같아요!\n\n```tsx\n// useMemo로 사용할 경우\nconst hideAfter = useMemo(() => debounce(hide, DEFAULT_DELAY), []);\n\n// useCallback으로 사용할 경우\nconst hideAfter = useCallback(debounce(hide, DEFAULT_DELAY), []);\n```\n\n이렇게 작성해야 함수가 변하지 않고 고정이 되니까요!\n\nuseAutoCallback을 사용하면 렌더링이 될 때 마다 최신 함수로 변경하기 때문에 문제가 될 수 있답니다 ㅎㅎ",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/8"
    }
  },
  {
    "passed": true,
    "name": "정유열",
    "feedback": "안녕하세요 유열, 수고하셨습니다! 이번 과제는 React의 내장 훅들을 직접 구현해보면서 프레임워크가 어떻게 상태를 관리하고 최적화하는지 깊이 이해하는 것이 목표였어요. 정유열님의 코드와 회고를 보니 이런 학습 목표를 충분히 달성했다 느껴지네요.\n\n특히 useShallowState를 구현하면서 setState가 동일한 값에 대해서는 리렌더링을 하지 않는다는 사실을 발견하고, 그럼에도 불구하고 참조값의 경우에는 얕은 비교가 여전히 중요하다는 걸 알게 되었다는 점이 좋네요. 사실 이러한 정보들은 이론만 공부할때에는 그냥 지나치기 쉬운데 이렇게 직접 구현을 하면서 공부하다보면 경험을 통해 지식이 완성이 된다 생각합니다!\n\n코드를 살펴보니 일관성 있는 코딩 스타일과 early return을 활용한 명확한 분기 처리, 그리고 타입 안정성을 고려한 구현 좋았습니다. \n\ncreateObserver에서 useSyncExternalStore에 적합한 subscribe 함수로\nstore, storage, router의 유기적 연결을 파악하는 과정에서 어려움을 겪으셨다고 하셨는데, 이런 고민 과정 자체가 정말 소중한 학습 경험이에요. 답습을 하더라도 왜 그럴까 고민을 해보는 것 자체가 더 신경써서 뭘 알아야 하는지를 생각하게 만들어주었을거에요!\n\n과제의 수행은 결과가 아니라 그 과정에서 오는 학습과 이러한 과정 자체 알려주고 싶은 것이기에 결과보다는 이 과정이 중요한거죠!\n\n이번 과제를 통해 메모이제이션이 만능이 아니라는 깨달음과 함께 구조적 개선의 중요성을 인식하신 것도 훌륭한 성과입니다. 실제로 성능 최적화는 단순히 메모이제이션만으로 해결되는 것이 아니라, 적절한 아키텍처와 상태 설계가 더 중요한 경우가 많지요 수고하셨습니다!!\n\n---\n\nQ) 어떤 방식으로 상태 관리를 하는 것을 선호하시는지(방법론, 상태관리 라이브러리 종류 등)\n\n저는 tanstackQuery와 jotai를 사용하고 선호했습니다. 대부분의 경우 데이터를 다루는 것은 서버로직에 있으므로 API를 다루는 tanstackQuery로 충분하고 나머지 언어, 설정, 회원정보 등등은 jotai를 통해서 개발했어요. jotai를 좋아했던건 React 컴포넌트에서 개발을 하고 난 이후에 그 코드를 그대로 jotai로 옮겨놓기만 하면 되니까 그런 직관성과 편리성 측면에서 좋아했습니다.\n\n\nQ) 여러 팀이나 프로젝트 환경에서 상태관리 라이브러리를 사용해 보셨을텐데 어떤 불편함을 겪었고 어떻게 해결하셨는지\n저의 경우 전역 상태관리의 특성 상 특히나 팀 협업 시 관리되지 못하는 스토어가 증식하여 관리가 어려워서 합리적인 해결책을 생각해보고 있습니다.\n \n=> 팀 차원에서 상태관리의 경우 어떤 상태관리를 사용하는 것보다 어떤 인터페이스를 쓸 것인가? 하는 것을 함께 결정하는 것이 중요합니다. 사실 상태관리를 구현의 문제라기 보다는 사용의 문제이니까요.\n\n=> 그래서 언어는 어떻게 할래? useLocale? useLanguage? 값은 함수는? 이런 인터페이스들을 사전에 합의하고 새로운 전역상태가 필요할때마다 그 인터페이스만 합의해두고 나면 믿고 쓰면 되고 문제가 생겨도 인터페이스는 변하지 않으므로 인터페이스를 변경하지 않고 개발한다는 원칙을 지킨다면 무분별해지는건 어느정도 방지 할 수 있습니다.\n\n=> 그리고 당연히 모두가 사용하는 layer인 만큼 누군가의 충분한 책임감을 가지고 담당해야하 하는 담당자 지정은 반드시 필요하다고 생각해요 :)\n\n\nQ) 상태관리에 대한 베스트프랙티스나 잘 할 수 있는 방법론을 다루는 책이나 글이 있다면 소개해주시면 감사할 것 같습니다.\n\n=> 책이나 글은 잘 떠오르지 않네요. 뭔가 상태관리만 다뤄낸 책을 따로 본 기억이 없어서 제가 찾아지면 공유할게요. 클린코드의 챕터의 2-2, 2-3이 그 상태관리를 다루고 있는만큼 해당 챕터에서 본격적으로 익혀보자구요!\n\n수고하셨습니다. 정유열님의 깊이 있는 탐구 정신과 체계적인 학습 접근법이 앞으로도 큰 성장의 원동력이 될 것이라 확신합니다. 클린코드 챕터도 화이팅입니다!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/15"
    }
  },
  {
    "passed": true,
    "name": "조영민",
    "feedback": "고생하셨어요 영민님! \n아숩게 회고가 작성되어 있지 않아서 한 주 고생하신걸 온전히 제가 이해하기는 어려웠는데요. 그래도 필요한 부분에 대해 코드 명료하게 잘 작성해주셨습니다.\n\n질문 주신 부분 이어서 살펴보면요.\n이미 적용해주고 계신 기준이 저는 개인적으로 맞다고 생각해요.\n과거에는 모든 코드에 메모이제이션을 하는 파와 절대 하지않는다 파(?)로 나뉘어져서 막 논쟁이 있었던 것 같은데, 최근에는 그런 사람들이 많이 사라진 것 같아요. 일반적으로 저희가 따르는 최적화 논리대로 섣부른 최적화는 하지 않되, 성능적으로 이슈가 발생하는 지점이 생긴다면 그 지점에 대해서 파악한 뒤 그 부분만 국지적으로 처리하는게 적절한 사용 방법인 것 같아요. 내부적으로 이미 처리가 어느정도 되어있고 최근 들어서는 모든걸 해결해주는 관점에서 개발을 하는 것은 아니지만 컴파일러의 발전도 지속되고 있잖아요. 필요한 부분이 발견되면 그 때 적용하는 형태로 하면 좋을 것 같습니다.\n\n고생하셨고 다음 주 과제도 화이팅입니다!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/43"
    }
  },
  {
    "passed": true,
    "name": "주산들",
    "feedback": "안녕하세요 산들! 수고 많으셨습니다. 이번 과제는 React의 내장 훅들을 직접 구현해보면서 프레임워크가 어떻게 상태를 관리하고 최적화하는지 이론을 넘어 몸으로 깊이 이해하는 것이 목표였습니다.\n\n몇몇 함수들은 AI를 사용하지 않고 직접 고민하며 구현해본 과정 칭찬합니다. 스스로 도전해서 내가 이정도까지 할 수 있다는 확신을 가지는 경험을 쌓아가는건 개발자로써 정말 중요한 경험이죠. 이렇게 세부 구현을 하게 되면서 React라는 도구가 흑마법이 아니라 React도 그저 JavaScript로 구현된 논리적인 시스템이라는 것을 체감하면서 원리가 이해가 되었을거라 생각해요.\n\nContext를 이용한 개념도 이번 기회에 잘 이해하게 된것 같아서 좋네요. 상태관리 라이브러리들도 이렇게 상태와 액션을 분리해서 다루고 있죠. 이런 개념적 분리가 아키텍처를 더 선명하게 바라볼 수 있게 해줄거에요.\n\n---\n\nQ) 타입 단언(as T) 사용에 대해\n\n=> 가급적 사용하지 않도록 하는 것이 제일 좋지만 타입스크립트에서 이러한 문법을 만들었다는 건 다 필요한 부분은 있다라는 것이죠. 사람마다 취향은 다른데 저는 최대한 타입 추론을 통해서 가능하도록 만들고자 하는 편입니다. \n\n그렇지만 사용자에게 제공하는 라이브러리를 만들 때에는 내부의 복잡한 구조로 인해서 타입이 굉장히 복잡해지는 경우가 있는데 이럴때 타입 단업을 통해서 사용자에게 전달해지는 라이브러리는 깔끔하게 정리할수가 있죠.\n\nProxy라던가 사실 꼭 T 타입이 아닐수도 있는 타입들을 단언을 통해서 해당 타입을 강제할수도 있구요.\n\n가급적 타입추론을 통해서 해결하고자 하되 내가 의도가 있어서 as T라고 써야 할때 쓰는 건 좋다고 생각합니다. 반면 가장 추상화 바깥의 영역에서 단지 type 에러를 수정하기 위해서 사용하는건 지양해야 곘죠.\n\n\nQ) ToastProvider 개선 방향\n\n=> 현재 구현도 충분히 깔끔합니다! Context 분리와 `useMemo` 활용이 잘 되어있어요. 더 개선한다면 로직을 Custom Hook으로 추출해볼 수 있겠네요. 예를 들어 `useToastLogic` 같은 훅을 만들어 debounce 로직과 상태 관리를 캡슐화하면 Provider 컴포넌트가 더 간결해질 거예요. 하지만 현재 수준에서도 충분히 실무에서 사용할 만한 품질입니다.\n\n---\n\n이번 과제를 통해 \"기초가 중요하다\"는 말의 진정한 의미를 체감하셨다니 정말 기쁩니다. useState로 useRef를 구현할 수 있다는 발견, useMemo가 의존성을 직접 비교한다는 깨달음 - 이런 \"아하!\" 모먼트들이 쌓여서 깊이 있는 개발자로 성장하게 됩니다.\n\nReact 레포지토리를 뜯어보고 싶다는 열망도 멋집니다! 그런 호기심이 계속된다면 머지않아 오픈소스에 기여하는 개발자가 되실 수도 있을 거예요.\n\n수고하셨습니다. 클린코드 챕터에서도 이런 깊이 있는 탐구를 계속 이어가시길 바랍니다. 화이팅입니다! :)",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/33"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "최용훈",
    "feedback": "용훈님 수고 많으셨습니다!\nMR 회고 내용이 없네욥~\n역랑을 궁극적으로 발전시키는데에는 동작하는 코드도 중요하지만 코드에대한 생각 정리와 과정에 대한 복기인 것 같습니다!\n다음에는 MR회고 내용도 같이 준비해주시면 좋을 것 같습니다~",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/11"
    }
  },
  {
    "passed": true,
    "name": "최재환",
    "feedback": "수고하셧어요 재환! 이번 과제는 React의 핵심 원리를 직접 구현해보면서 프레임워크가 내부적으로 어떻게 상태를 관리하고 최적화하는지 깊이 이해하는 것이 목표였습니다. 해당 취지가 잘 느껴지는 지난 3주간이었길 바래요!\n\nuseAutoCallback 구현 과정에서의 고민들이 회고에 잘 드러난 것 같아서 좋았습니다. useLayoutEffect로 시작해서 렌더링 타이밍 문제를 발견하고, 두 개의 useRef를 활용한 해결책으로 발전시킨 과정을 세세하게 잘 풀어낸 부분 좋습니다.\n\nReact의 동시성 모드에서의 안정성 우려를 표현하셨는데, 실제로는 매우 안전한 구현입니다. React가 컴포넌트를 재시작하더라도 useRef는 동일한 객체를 유지하므로 예상치 못한 부작용은 발생하지 않을 거예요.\n\nuseRef에서는 라이브러리 사용성을 위한 복잡도 증가를 고민하셨다고 하셨는데, 분명 고민을 해볼 부분이죠. useRef의 오버로딩이 복잡해보이지만 코드로 보았을때의 복잡도나 일관성 그리고 학습곡선이 낮다면 해볼만한 선택입니다. \n\n만약 그렇지 않았다면 useRef, useRefFn, useRefWithNull 등 여러가지 함수를 만들었어야 하는데 복잡도와 간결성과 직관성등을 모두 고려해 최적을 찾아가보는게 개발자의 관점이죠. 수고하셨습니다.\n\n앞으로 클린코드 챕터에서는 이런 구조적 사고를 더욱 발전시켜 나가봅시다!! 아자 아자! 2주차도 지금과 같은 해보고 익힉다의 정신으로 화이팅입니다! ",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/56"
    }
  },
  {
    "passed": true,
    "name": "한아름",
    "feedback": "안녕하세요 아름! 수고하셨습니다! 이번 과제는 React의 내장 훅들을 직접 구현해보면서 프레임워크의 내부 동작 원리를 깊이 이해하고, 상태 관리와 최적화 메커니즘을 체득하는 것이 목표였습니다.\n\n\"비밀을 파헤친 느낌\" ㅋ 재밌네요. 맞아요! 개발에서 깊이를 파내려가는 공부라는 이런 방식이죠. React 훅의 내부 구조를 직접 탐구하며 얻은 통찰이 정말 값진 경험이 되었기를 바랍니다. 특히 직접 구현한 훅들이 서로 연결되어 복잡하면서도 깔끔한 구조를 만들어내는 과정을 즐기신 점이 멋져요\n\n코드 리뷰에서 언급된 타입 가드류 유틸리티 함수를 별개로 만들어 두는 방식은 좋은 방식이죠. 타입 가드를 별도 함수로 분리하면 가독성과 재사용성이 향상됩니다. 참고해두시면 좋을 것에요.\n\nconst isObject = (target: unknown): target is Record<string, unknown> => {\n  return target !== null && typeof target === \"object\" && !Array.isArray(target);\n};\n\n---\n\nQ) useCallback vs useAutoCallback 사용 시나리오\n\nuseCallback이 React가 기본적으로 제공하는 훅이며 useAutoCallback은 사용자(커뮤니티)가 만들어 낸 custom hook입니다. 공식적인거라기 보다는 편의를 제공하기 위해서 만들어 낸 거죠.\n\n엄밀하게는 useCallback에 의존성 배열을 두는게 맞습니다. 그러나 이런 방식은 휴먼에러가 발생하기 쉽죠. 그래서 메모가 되면 안될때 메모가 되어버리면 오동작을 하는데 이걸 찾아내기가 상당히 어렵습니다.\n\nuseCallback을 안쓰면 항상 함수가 새롭게 만들어지므로 이런 문제가 해결이 되죠. 그렇지만 이 함수를 자식 컴포넌트의 props로 전달하면 자식 컴포넌트의 memo가 전혀 동작하지 않습니다. 왜냐하면 늘 새로운 함수를 만들어 낼테니까요. \n\nuseAutoCallback은 의존성 배열을 통한 엄밀한 비교는 하지 말고 항상 최신의 값을 만들지만 자식 컴포넌트에서 React.memo를 쓰고 있을때 메모가 가능하도록 만들어주기 위해 만든 편의성 유틸리티 함수입니다.\n\n정리하자면 해당 함수가 자식 컴포넌트의 props로 전달되고 있는 경우, 엄밀한 의존성 관리의 복잡함을 사용하지 않는 대신 자식 컴포넌트의 memo는 가능하도록 하기 위한 편의성 hook이라고 생각해주세요.\n\nQ) shallowEquals와 deepEquals 구현 관련\n\n=> 제출하신 구현 방식도 좋지만, 재귀적 접근을 통해 더 견고하게 만들 수 있습니다:\n```javascript\nconst baseEquals = (a: unknown, b: unknown, equalsFn: typeof Object.is) => {\n  if (Object.is(a, b)) return true;\n  \n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && \n           a.every((val, idx) => equalsFn(val, b[idx]));\n  }\n  \n  if (isObject(a) && isObject(b)) {\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    return aKeys.length === bKeys.length && \n           aKeys.every(key => equalsFn(a[key], b[key]));\n  }\n  \n  return false;\n};\n\nexport const shallowEquals = (a: unknown, b: unknown) => \n  baseEquals(a, b, Object.is);\n\nexport const deepEquals = (a: unknown, b: unknown) => \n  baseEquals(a, b, deepEquals); // 재귀적으로 자기 자신 호출\n```\n\n---\n\n수고하셨습니다. React의 내부 동작을 직접 구현해보며 얻은 이번 경험이 앞으로의 개발 여정에서 든든한 기초가 되기를 바랍니다. 클린코드 챕터에서도 이런 깊이 있는 탐구 정신을 계속 이어가시길 응원합니다! 화이팅입니다! :)",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/55"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "허정석",
    "feedback": "정석님 배포 링크에 감동을 받았네요. 그나저나 gemini cli 결과를 보는 부분에서는 저 파랑색은 참 색이 화려하네요.\n\n전에 말했던것 처럼 이전 항해를 하셨던 분들 중 정말 많은 분들 중에 리액트를 사용해보지 않았던 분들이 계셨지만 이렇게 문서까지 남기시면서 하셨던 분들은 정말 없었어요. 너무너무 잘해주고 계십니다 :+1\n이런 부분들이 이제 추후에 리액트를 활용해 과정을 해나가시는데 있어서 적절하게 요소요소마다 API를 고르고 사용하는데 큰 도움이 될 것 같네요.\n\n질문 주신거 바로 살펴보면요.\n\n> 개선이 필요한 코드에서도 useAutoCallback 를 언급했습니다. latestFnRef와 dispatcherRef라는 두 개의 ref를 사용하여 구현했습니다. 주석으로 표기를 해놨으나 패턴을 쉽게 이해하기는 어려울 것으로 보입니다. 구조를 명확하지만 쉽게 파악할 수 있는 방법에 대해 리뷰 부탁드리겠습니다. 감사합니다.\n\n우선 지금 구현을 보면 중간 과정에 어떤 의도가 있었는지 제가 파악은 못했지만 지금의 구조를 수정한다면 dispatcherRef가 불필요한 것 같아요! 바로 latestFn을 호출 하는 방식으로 하면 충분할 것 같아요. 혹시 궁금하셨던 부분이나 의도하셨던 부분이 제가 답변 드린 부분과 달랐다면 꼭 다시 질문주세요! (지훈님 코드리뷰 하시면서 본 것 같네요 ㅋㅋㅋ 동일한 의견입니다)\n\n지치신거 아니죠? 정석님 지켜보겠습니다.. 다음 주도 화이팅입니다!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/19"
    }
  },
  {
    "passed": true,
    "name": "현지수",
    "feedback": "안녕하세요 지수, 수고하셨습니다! 이번 과제는 React의 내장 훅들을 직접 구현해보면서 프레임워크가 어떻게 상태를 관리하고 최적화하는지 이론을 넘어 몸으로 깊이 이해하는 것이 목표였습니다.\n\n코드 스타일이 정말로 최소한의 코드 구현만 하면서 간결하게 작성하려고 하는 스타일이 눈에 띄는데 참 잘했습니다! 가능하다면 가독성이 확보되는 수준에서 코드의 양은 줄일 수 있는게 좋죠. 계속 그러한 코드 스타일을 유지해주길 바래요!\n\n렌더링, 메모제이션, 컨텍스트와 상태관리등은 React의 핵심 개념이며 해당 개념들을 실제로 구현을 해보니 왜 메모제이션을 필요할 때에만 하라고 하고 만능이 아닌 것인지, 코드를 해부하고 원리를 이해하는 것을 통해서 개발 과정과 선택 과정이 더 선명해지는 계기가 되었기를 바랍니다.\n\n---\n\nQ) deepEquals 순환 참조 처리의 필요성과 구현 방법\n\n=> React 생태계에서 순환 참조는 실제로 그리 흔하지 않습니다. React가 아무래도 객체를 데이터로만 다루는 함수형 프로그래밍을 지향하다보니 props나 state는 대부분 직렬화 가능한 데이터인 경우가 많죠. \n\n성능 측면에서는 WeakSet 연산 자체는 빠르지만 메모리 오버헤드가 있습니다. 일반적인 애플리케이션에서는 현재 구현으로 충분하고, 순환 참조가 예상되는 특수한 경우에만 추가하는 것이 실용적이에요.\n\n언제나 성능과 메모리, 간결함과 복잡함의 트레이드 오프는 언제나 개발에서의 딜레마라 생각합니다. 대개는 최대한 간결한 구조를 유지하고자 하다가 문제가 제보(?)되다보면 점점 복잡해지거나 개선하는 식으로 만들어지곤 합니다.\n\n\nQ) useAutoCallback의 개발자 경험과 실무 활용도\n\n=> 해당 방식은 함수를 자식 컴포넌트의 props으로 넘길때에는 useCallback등으로 참조로 만들지 않으면 언제나 새로운 함수가 전달이 되므로 memo가 되지 않는 문제를 해결하는데 도움을 줍니다. 함수는 useMemo와 달리 비싼 로직이 아니니까요. 의존성 배열을 명시하지 않고 언제나 최신 함수를 전달하지만 참조는 유지하므로써 자식 컴포넌트로 props도 메모제이션이 가능하도록 하는 편의성 유틸리티 함수죠.\n\n=> 편의냐? 아니면 명확성이냐? 도 개발자간의 취향이 갈리는 부분입니다. 물론 여기서 useAutoCallback의 경우 공식적인 hook이 아니라 학습을 위한 그리고 커뮤니티에서 만들어진 방식이고, useCallback은 명시적이고 공식적인 방식이다보니 아무래도 useCallback을 사용하겠죠? 대부분은 많이 사용하는 것을 사용하는 것을 선호하니까요.\n\n이러한 개발자적인 고민들 철학에 대한 나의 취향 그리고 근거나 확신등을 고민을 통해서 만들어가는 것도 좋은 경험이 될거에요. 화이팅입니다!",
    "assignment": {
      "name": "STEP06 JS & React 딥다이브 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter1-3/pull/42"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "강병준",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/21"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "권지호",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/7"
    }
  },
  {
    "passed": false,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/29"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/20"
    }
  },
  {
    "passed": true,
    "name": "김소희",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/43"
    }
  },
  {
    "passed": true,
    "name": "김수민",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/50"
    }
  },
  {
    "passed": true,
    "name": "김수현",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/19"
    }
  },
  {
    "passed": true,
    "name": "김연수",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/58"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김유현",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/25"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/22"
    }
  },
  {
    "passed": true,
    "name": "김효진",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/9"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김휘린",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/51"
    }
  },
  {
    "passed": true,
    "name": "박상수",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/23"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/30"
    }
  },
  {
    "passed": false,
    "name": "박의근",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/63"
    }
  },
  {
    "passed": true,
    "name": "박준형",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/4"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박창준",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/17"
    }
  },
  {
    "passed": true,
    "name": "신홍준",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/57"
    }
  },
  {
    "passed": true,
    "name": "신희원",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/38"
    }
  },
  {
    "passed": true,
    "name": "양성진",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/42"
    }
  },
  {
    "passed": true,
    "name": "양창훈",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/39"
    }
  },
  {
    "passed": true,
    "name": "여진석",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/62"
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/61"
    }
  },
  {
    "passed": true,
    "name": "오하늘",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/16"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/15"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "윤영서",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/6"
    }
  },
  {
    "passed": true,
    "name": "이가은",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/36"
    }
  },
  {
    "passed": true,
    "name": "이민재",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/32"
    }
  },
  {
    "passed": true,
    "name": "이유진",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/53"
    }
  },
  {
    "passed": true,
    "name": "이은지",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/55"
    }
  },
  {
    "passed": true,
    "name": "이의찬",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/37"
    }
  },
  {
    "passed": true,
    "name": "이정우",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/54"
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/48"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/5"
    }
  },
  {
    "passed": true,
    "name": "이진희",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/34"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/24"
    }
  },
  {
    "passed": false,
    "name": "임규원",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/26"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "임두현",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/27"
    }
  },
  {
    "passed": true,
    "name": "장루빈",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/59"
    }
  },
  {
    "passed": true,
    "name": "장희진",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/18"
    }
  },
  {
    "passed": true,
    "name": "정건휘",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/56"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "정도은",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/35"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "정민기",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/8"
    }
  },
  {
    "passed": true,
    "name": "정유열",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/11"
    }
  },
  {
    "passed": true,
    "name": "조영민",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/45"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "주산들",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/10"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "최용훈",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/3"
    }
  },
  {
    "passed": true,
    "name": "최재환",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/52"
    }
  },
  {
    "passed": true,
    "name": "한아름",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/60"
    }
  },
  {
    "passed": true,
    "name": "허정석",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/41"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "현지수",
    "feedback": "",
    "assignment": {
      "name": "STEP07 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/46"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "강병준",
    "feedback": "안녕하세요 병준님!\n\n4주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 리팩토링이나 기능 개발을 하다 보면 전체 흐름은 잡혔는데 세부 구조에서 계속 맴도는 경우가 종종 있습니다. 너무 깊게 고민하다가 진행이 막히는 이런 상황에서는 어떻게 풀어가야 할까요? (개인 프로젝트나 과제처럼 개인이 수행해야 하는 경우가 궁금합니다!)\n\n이럴 땐 일단 한 파일에 다 몰아넣어버리는 것도 나쁘지 않은 방법이라고 생각해요 ㅎㅎ 다 만들어놓고 그 다음에 세세하게 고민하고 분리하는거죠.\n\n어쨌든 일단 돌아가도록 만들어놓는게 제일 중요하지 않을까 싶어요!\n\n그리고, 이 때 개선에 대한 가치 판단은 \"어떻게 해야 다양한 요구사항을 수용할 수 있을까?\" 에 대해 고민해보는거죠!\n\n> 추가로 기능 구현 및 리팩토링을 위한 설계는 어느정도 수준까지 이루어지는게 적절할까요? (너무 추상적인 질문이긴하지만... 전체적인 틀을 잡아주는 방향으로 대답해주시면 감사하겠습니다!!!)\n\n회사 프로젝트와 개인 학습을 위한 프로젝트가 다르다고 생각해요.\n개인학습을 할 때에는 \"오버엔지니어링\"을 해보는게 좋습니다. 최대한 깊이있게 고민해보는거죠. 그러다보면 \"이런 고민은 지금 단계에서 불필요한데!?\" 라고 판단할 수 있어요. 이걸 또 실무에서 적용해보는거죠 ㅋㅋ\n\n기능 구현 및 리팩토링을 위한 설계도... \"어떤 요구사항까지 수용해야 좋을까?\" 를 토대로 고민해보시면 좋답니다!\n\n가령, 할인율에 대한 규칙이 100개정도로 늘어났을 때 이걸 최대한 자연스럽게 수용하는 구조를 상상해보시면 좋아요!\n\n100개가 아니라 무한대의 경우의 수가 있다면 또 어떨까요?\n백오피스에서 계속 할인율 규칙을 만들고 이게 어플리케이션이랑 실시간으로 동기화가 되어야 하는거죠.\n\n이럴 때 내 코드가 수용할 수 있는 구조인가!? 라는 질문을 던져보면 좋답니다.",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/21"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "권지호",
    "feedback": "우선 지호님.. 회고문서 정말 대박이네요..\n이렇게 회고 열심히 작성해주신 분은 처음입니다.\n열정이 보입니다!!\n\nQ. FSD기반 슬라이스 구조..\n\nA. 코드를 어떻게 하면 독립적이고 재사용가능성 있게 만들 수 있는지는 저도 아직까지 화두이고 항상 생각이 바뀌는 것 같아요. 어차피 정답은 없는 것일 것 같아요.\n\"이 프로젝트에서는 현재의 구조가 최선으로 보인다\" 정도의 믿음으로 필요한 부분들을 개선하려는 노력이 더 중요한 것 같습니다 끝판왕은 없으니까요.\n\n저도 FSD의 슬라이스와 세그먼트구조는 괜찮다고 생각해요 컴포넌트 기반으로 개발하는 것이 일상화 된 상황에서는 어찌보면 자연스럽게 만들어지는 형태가 아닐까 생각합니다.\n다만 레이어부분은 FSD가 정해놓은 것 보다는 프로덕트에 맞게 팀에서 적절히 다시 구성하는 편이 좋다는 생각정도만 하고 있습니다.\n이렇게 프로젝트에 맞게 레이어를 구성해 위계를 만들고, 각 컴포넌트는 추상화된 개념으로 일관성있게 세그먼트 형태로 나눠서 개발하는 형태, 거기에 더해 수평적으로 공통적으로 사용할 수 있는 레이어정도만 추가되면 저는 일단 기본은 커버하는 구조라고 생각합니다.\n물론 이것도 프로젝트마다 다를 것 같아요. 지금 지호님 이 잡으신 구조는 저는 오히려 FSD를 억지로 구현하려는 것보다, 장점만 취한 심플하고 좋은 구조라고 생각합니다.\n어떻게 보면 제가 말씀드린 요건들을 다 갖춘것 같아요 다만 컴포넌트의 레이어 구분이 없긴하지만 사실 지금 과제를 기준으로 볼때는 레이어 구분은 오히려 오버엔지니어링일지도 모르겠네요.\n\nQ. 훅들의 의존\n\nA. 훅이 하나의 역할로만 잘 나눠지면 나줘질수록 오히려 의존성은 더 높아지는 것 같아요 어떻게보면 중복을 제거하는 과정이니 당연한 것 아닌 가 싶습니다.\n의존은 피할 수 없을 것 같고 다만 훅도 모두 같은 훅으로 보지말고 훅도 적절한 개념의 레이어로 추상화해서 서로 위계를 만들고 의존의 방향을 설정해주 형태로 유지를 하는 편이 저는 옳은 것 같아요. 이것은 코드의 위치로도 구분할 수 있고 단순히 개념적으로 약속하고 네이밍으로 프리픽스나 서픽스를 다는형태로 구분할 수도 있을 것 같아요. 일단 레이어를 구분하기로 했다면 어떤형태로는 구분할 필요는 있어보입니다.\n\nQ. 추상화 레벨의 일관성을 맞추기 위해 이런식으로 다른 훅을 조합하는 역할만 하는 훅이 만들어지는 경우가 생기는 것 같습니다.\n이러한 분리도 의미가 있을까요?\n\nA. 어떻게 보면 2번째 질문의 답변에서 같이 답변된 것 같은데요. 넵 이러한 분리도 당연히 의미가 있는 것 같아요. 기본 재료에 해당하는 훅이 있고 그런 레이어를 베이스훅 뭐 이런 이름으로 부르기로 \"약속\"할 수 있을 것 같아요. 그리고 그 재료들을 활용해서 더 추상화된 개념의 작업을 수행하는 훅도 있겠쭁. 다만 이때 의존의 방향을 한방향으로 흐르는 것으로 약속을 해야할 것 같아요. 레이어 안에서 의존을 허용할지 말지도 규칙을 정해야할 것이고요. 재사용성을 위해 어쩔수 없는 부분이라고 생각합니다.",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/7"
    }
  },
  {
    "passed": false,
    "name": "김민지",
    "feedback": "오우 민지님 아쉽게도 과제가 진행이 되지 않았던 것 같네요 ㅠㅠ\n바쁘신 일이 있었겠죠?ㅎㅎ\n우선 순위에 맞춰서 시간 여유가 생기실 때 과제 진행하시고 항해가 끝나기 전에 다같이 고민했던 그 경험이 있었을 때 이야기를 하는 방향으로 진행하시면 좋을 것 같습니다. ",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/29"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "ㅋㅋㅋㅋㅋ상수님 고생하셨어요!\n뭔가 커밋로그나 흔적들을 보면 정말 많은 시도를 하셨던것 같네요.\n근데 결론에 대한 부분에 있어서 저는 죄송하시지 않아도 된다고 생각해요. 지금 회고에서도 작성해주신 것 처럼 정확하게 의도에 맞춘 경험을 하셨다고 생각하거든요.\n\n다만, \"바이브 코딩 절대 안하겠습니다\"는 안돼요 ㅎㅎㅎㅎ\n\"AI한테 딱 맞는 질문을 던져줘야 원하는 결과가 나오고, 그냥 이거 해줘 이런 식으로는 한계가 있다\"로 작성해주셨으니까 우리는 잘 맞춘 적절한 요청을 하는 연습을 해야 하는거죠 ㅎㅎ\n아직은 '~해줘 알아서 똑똑하게' 하면 똑똑하게 뚝딱 만드는 AI는 아니지만 사람을 10명써서 할 일을 AI에게 똑똑하게 질문할 수 있는 2명을 써서 할 수 있게 하는건 맞는 것 같아요. \n그럼 저희는 그 2명이 되어야 하지 않을까 싶습니다. \n\n작업의 단위를 작게 작게 하고 테스트나 명확한 피드백 루프를 만들어서 개선하신다면 지금의 나쁜 경험을 좋은 방향으로 바꿀 수 있다고 저는 확신하니까 포기하지 말고 나아가보시죠\n\n(추가로 대규모 파일 그리고 폴더간의 모듈 구조를 파악하고 전반적인 코드를 개선하는게 용량이 커질수록 지금의 LLM이 별도 지침없이 완벽하게 하는 단계는 아닌것 같아요. 그런 부분에서 응답이 모호하고 추상적이게 나올 수 있는건데 이건 시간이 지나고 모델이 발전함에 따라 자연스럽게 사라질 걱정이라고 개인적으로는 생각합니다 ㅎㅎ)\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/20"
    }
  },
  {
    "passed": true,
    "name": "김소희",
    "feedback": "정말 정말 재밌었다니 과제 출제자로써 뿌듯하네요. 고맙습니다.  \n\n\"..과제를 처음 받았을 때는 무슨 수단을 써서라도 완벽한 코드를 만들어 보자! 다짐 했었는데요.\" 맞아요. 개발자로써 뭔가 이상적이고 완벽한 코드를 만들고 싶어하는 바람들이 다들 있죠. 그렇지만 그런건 존재하지 않죠. 프로젝트가 성장하고 세상이 바뀌면서 코드는 바뀌기 마련이니까요.\n\n\"...적어도 바로 전보다는 나은 코드를 만들어가잔 마음으로 차근차근 임했습니다.\" 라는 인사이트를 느꼈다니 너무 멋지네요. \n\n\"..기본 과제의 큰 방향성은 리액트스러움(?)으로 잡았습니다!\" 잘했습니다! 어쨌든 지난 10여년간 개발자 선배님들의 시행착오 끝에 합의가 된 방향인 만큼 분명 더 나은 무언가가 있을진 모르지만 지금까지 고민해온 결과의 이유들을 이해했기를 바랬요. 단순히 이렇게 해야한다가 아니라 더 좋은 코드의 고민의 결과물로써 리액트스러움을 이해했기를 바랍니다.\n\n\"감각적으로다가 코드를 휘리릭 클린하게 짜는 사람이었다면 더 많은 부분을 캐치할 수 있었을텐데!\" 라는 의식을 가진다는 건 중요한 감각입니다. 전에 멘토링때 클린코드에 대한 감각은 패션센스? 혹은 정리정돈같은 감각인건데 신경안쓰면 신경이 안쓰이는데 신경쓰다보면 정리 안된거나 제대로 안된거 보면 불편하고 신경쓰게 되는 것 같은거요.\n\nQ) 화면을 그리는 코드와 계산에 필요한 코드를 자알 분리해보고 싶었는데, 혹시나 눈에 띄게 위반되는 지점이 있다면 꼬옥 알ㄹㅕ주세요!\n\n=> 잘했습니다. context를 이용해서 state와 dispatch를 분리하는 방식으로 잘 작성을 했네요! 이런 방식은 상태의 변화가 한군에 있고 어떤 동작을 통해 상태가 변화는지를 한눈에 볼 수 있어서 좋은 방식이죠. 지금과 같이 add, remove, inc등 다양한 액션이 있을 때 특히나 좋은 방식입니다. \n\nQ) 변수나 함수의 의미를 명확하게 하려고 하다보니 자꾸만 길어지는데 요런 경우 어떻게 하시는지 꿀팁! 아니면 규칙! 그런 게 궁금합니다!\n\n=> 자기만의 개발네이밍 사전등을 한번 갖춰보면 좋습니다. 어차피 개발에서 쓰이는 네이밍이라는건 도메인에서 쓰이는 특별한 용어를 제외하고는 대부분 비슷비슷하거든요. 그럴때마다 이런 이름을 뭐라고 지으면 좋지? 할때마다 좋은 기회를 삼아서 개발 어휘를 늘리기 위해서 여러가지를 비교하고 뉘앙스등을 면밀히 비교하는거죠.\n\n=> 그리고 나만의 조립 법도 고민하면 좋습니다. 변수의 경우 가장 단순한 명사로 시작해서 맥락에 따라 형용사를 늘리는 식으로 index, selectedIndex, selectedProductIndex 중에서 주변 맥락을 통해 없어도 알 수 있을 것들은 안쓰고 적어주지 않으면 예측하기 어려운건 적어주는 편이 좋습니다.\n\n=> 함수의 경우 동사, (형용사+)명사, (+전치사 명사) 와 같은 조립으로 대부분의 경우는 동사명사 2개의 조립이나 변수명처럼 findProduct() findSelectedProduct() 처럼 맥락을 더해야하는 경우와  indSelectedProductFromPoint() 입력값을 명확하게 해주기 위한 전치사를 더해주는 식 정도 입니다.\n\n=> 컴포넌트나 다른 파일명등도 핵심이 되는 명사를 기준으로 얼마만큼 형용사로 맥락을 더해주어야 하나? 이런 방식들을 고민해보세요. 이러한 세세한 컨벤션등을 한번 나는 어떻게 하고 있나? 이런 고민들을 해보면 더 선명해지는 걸 느낄거에요\n\n\nQ) basic 단계에서 현재 선택된 상품 값을 전역 변수로 관리하고 리렌더링 시 상태를 유지해주려고 했어요. 그래서 onChange 이벤트 핸들러를 걸어서 값이 바뀔 때마다 상태를 업데이트 하도록 했는데, 테스트 코드에서는 change 이벤트가 발생하지 않고 값이 직접 바뀌는 구조라 트리거가 안 되더라고요,, 최대한 핸들러에서 해결을 하고 싶었는데 아무리 생각해도 오직 테스트 통과만을 위한 못난 코드가(?) 되는 것 같아 결국 테스트 코드를 수정했습니다. 괜찮은 해결 방법이었을까요? 🥹🥹🥹\n\n=> 테스트 코드와 실제 코드는 서로를 견제(?)하고 보강하기 위한 관계입니다. 테스트 코드로 하여금 실제 코드를 변경하더라도 문제가 없도록 할 수 있죠. 그렇지만 React로 넘어가고 나면 그 테스트 코드는 다시 쓰여져야 했을 거에요. 이 경우에는 실제 코드는 건들지 않고 테스트 코드를 다시 작성해야겠죠. 서로가 서로가 변하지 않을 거라는 전제로 의미가 생깁니다.\n\n=> 이번에는 좋은 판단이었습니다. 해당 테스트 코드를 유지해야하는 이유가 사라지는 때였으니까요. 낡은 코드는 어느쪽이던간에 변경이 되어야 하죠. 내가 그 이유를 인지하고 변경하는 건 좋습니다. 우리가 경계해야 하는건 내 코드가 검증이 되지 않았는데 테스트 통과를 위해 코드를 변경하는 행위죠. 이건 경계가 뚜렷하지 않으므로 뭐라 딱 잘라 말하기는 어렵습니다만, 언젠가 폐기되거나 수정되어야 하는 코드는 수정이 되는게 맞습니다. 본인의 역할을 다 할 수 없는 코드라면 변경이 되어야 겠죠\n\n이러한 고민 고민들이 쌓여서 본인의 감각으로 센스로 만들어지는 것이기에 지금의 과제가 그러한 의식을 가지는 계기가 되길 바라며 현업에서 만나는 코드에서도 조금만 더 시간을 들여서 클린코드를 만들고자 하는 생각들도 함께 가져가 보길 바래요. 수고했습니다! 5주차도 화이팅입니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/43"
    }
  },
  {
    "passed": true,
    "name": "김수민",
    "feedback": "수고했습니다. 이번 과제는 더티코드를 클린코드로 개선하면서 유지보수성을 높이고, 더 나아가 React와 TypeScript로 기술 고도화까지 진행하는 것이 목표였어요. 수민이 팀원분들과 함께 코드 컨벤션을 정하고 중간 코드 리뷰를 통해 협업하신 과정이 정말 인상적이네요.\n\n코드를 작성하다보면 다들 자신만의 철학이나 좋다고 생각하는 생각들이 미묘하게 다른데 이러한 내용들을 서로 주고 받는 것만으로도 관점이 늘어나고 생각이 성장할 수 있죠. 앞으로도 과제를 하기 전 컨벤션 뿐만 아니라 코드를 하는 과정에서도 함께 리뷰등을 자주 해보길 바래요. 생각보다 그럴 기회가 많이 없거든요\n\n과제를 하면서 아쉬운 순간 특히나 AI를 많이 사용한게 아쉽다고 했는데 그러한 것들을 느끼는 것들도 소중한 인사이트죠. 5주차는 그러면 한번 AI없이 도전해보는건 어떨까요? 앞으로도 계속 학습을 해야 할테고 AI는 당연한 도구가 되어 갈텐데 어떻게 하면 그 밸런스를 잡고 나에게 유리하게 잘 활용할 수 있을지 알아보는 것도 좋은 경험이 될 거라 생각해요.\n\nQ) 테오가 doubleQuote를 선호하는 이유는 무엇인가요? 궁금해요 !!!\n\n=> 저는 C++로 개발을 먼저 배워서 C++에서는 문자열이 doubleQuote이기 때문에 습관이 그렇게 든 부분이 한 몫합니다. 그렇다고 바꿀 생각을 안해본 것은 아니지만 js는 둘다 가능하더라도 HTML이나 특히 JSON의 경우 doubleQuote가 표준인만큼 검색을 하는 과정에서 JSON에서 누락하는 경우가 있어서 저는 좀 싫었습니다. 다른 사람은 그래서 검색에서 구분할 수 있다고 해서 좋았다고 하는거 보면 개인취향이라 생각해요. 아무래도 익숙함의 차이겠죠? ㅎ\n\n5주차도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/50"
    }
  },
  {
    "passed": true,
    "name": "김수현",
    "feedback": "\"처음 코드를 봤을 때 너무 막막해서 \"어디서부터 손대야 하지?\" 싶은 마음뿐이었고, 평큐 타임에 테오의 힌트를 듣고 나서야 겨우 시작할 수 있었습니다. ... main 파일에서 로직의 분리를 통해 클린 코드로 구성해나갔지만, 각각의 로직 자체는 아직 클린 코드라고 할 수 없습니다. 과제를 다시 한다면 로직 자체도 클린하게 구현해보고 싶습니다.\" 라고 했지만 코드를 보니 충분히 잘 해냈는걸요? \n\n뭔가 본인만의 클린코드에 대한 이상이 너무 높지 않았나 싶어요. 어쩄든 맨 처음에 제가 드렸던 코드에 비해서 지금은 충분히 쓸만해졌잖아요? 레거시 코드를 만났을때 막막하더라도 조금씩 조금씩 어찌되었든간에 지금 보다는 조금 더 낫도록 하는것들이 쌓여서 클린코드가 되는 것이니까요.\n\n수고많았습니다. 5주차 과제에서는 너무 높은 목표보다는 지금까지 어쨌든 지금까지 했던 것에 대해서 과정을 돌이켜보는 회고를 써보길 바래요. 화이팅입니다!\n",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/19"
    }
  },
  {
    "passed": false,
    "name": "김연수",
    "feedback": "연수님 고생하셨습니다!\n기본 코드 개선은 잘 해주신 것 같아요 ㅎㅎ\n전반적으로 AI를 활용해 개선해주신 것 같은데요. 지금도 잘 하셨지만 작업 단위를 명확한 기준으로 잡고 차근차근 변경해 나간다면 좀 더 좋을 것 같아요. 테오가 클린코드 관련해서 설명해줬던 여러가지 키워드들을 명시해서 작업을 지시해도 괜찮을 것 같구요. 고생하셨고 지금은 따로 회고가 작성이 되어있지 않은데 과제를 마무리하시고 나서는 회고를 작성하시는게 큰 도움이 되니 더 늦기 전에 작성해보시면 좋을 것 같아요. \n\n담주도 화이팅입니다~",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/58"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김유현",
    "feedback": "안녕하세요 유현님! 4주차 과제 너무 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n지금 기본과제에서 심화과제로 이어지는 부분이 어느정도 매끄럽게 느껴지는데 아쉬운 부분도 있어요.\n\n기본과제의 calcCartTotals과 심화과제의 calcCartTotals을 보면 함수는 똑같은데 내용이 조금 상이합니다.\n\n아예 기본과제에서 만든 코드를 심화과제에서 불러와서 사용하는 방식을 상상해보면 어떤식으로 코드를 분리하면 좋았을지 감이 잡혔을 것 같아요!\n\n---\n\n> CartItem에서 매번 find 수행 시 대규모 productList에서의 성능 저하 가능성이 있을 것 같습니다. React.memo 외에 Context API or memoizedProduct 전달이 더 나은 선택일까요?\n\n지금은 아예 ProductList를 넘기고 있는데요,\n딱 필요한 데이터만 가져와서 넘겨주는 방식을 상상해보시면 좋을 것 같아요.\n```tsx\n\n// 어딘가에서 carts와 products를 정규화해서 관리해야 함.\nconst toMap = (items, targetKey) => items.reduce((acc, item) => ({\n\t...acc,\n\t[item[targetKey]]: item\n}), {});\n\nconst carts = cartList => toMap(cartList, 'id');\n\nconst products = productList => toMap(productList, 'id');\n\nconst Cart = ({ carts, products , onCartClick }: CartProps) => {\n\tconst cartWithProduct = useMemo(\n\t\t() => Object.values(carts).map(cart => ({\n\t\t\t...cart,\n\t\t\tproduct: products[cart.id]\n\t\t})),\n\t\t[carts, products]\n\t)\n  return (\n    <div\n      id=\"cart-items\"\n      role=\"group\"\n      aria-label=\"Cart Items\"\n      onClick={onCartClick}\n    >\n      {cartItems.length === 0 ? (\n        <p className=\"text-center text-gray-500 py-10\">\n          장바구니가 비어있습니다.\n        </p>\n      ) : (\n        cartWithProduct.map(({ quantity, product }) => {\n          return (\n            <CartItem key={item.id} {...product} quantity={quantity} />\n          );\n        })\n      )}\n    </div>\n  );\n};\n```\n\n요로코롬..\n그리고 CartItem을 메모이제이션 해주는거죠 ㅎㅎ\n이러면 CartItem의 props 중 객체가 없기 때문에 높은 확률로 메모이제이션이 잘 적용될 수 있어요.\n\n그리고 context를 만약 CartItem에서 불러온다면 결국 최적화가 제대로 안 될 확률이 높답니다.\n차라리 zustand나 jotai 등을 이용하여 최적화를 하는게 더 좋은 방법이라고 생각해요!\n",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/25"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "안녕하세요 지혜, 수고했습니다! 이번 과제는 리팩토링의 진정한 어려움과 가치를 체감하는 것이 목표였어요. 지혜가 써준 회고는 정말 모범생 답안처럼 과제에서 가져갔으면 하는 것들이 다 적혀있어서 참 좋네요. 특히 \"코드는 한 번 쓰고 여러 번 읽힌다\"는 말의 진정한 의미를 깊이 체감했습니다.\" 라는 내용이 너무 와닿았습니다.\n\n리팩토링이 단순히 코드를 깔끔하게 만드는 작업이 아니라 \"미래의 자신과 동료를 위한 배려\"라는 본질을 정확히 파악해준거 같아요. 특히 더티코드 분석 과정에서 p, q, amt, sel 같은 모호한 변수명들로 인해 겪으신 고생 - 결국 내가 겪어보니까 알 수 있는건 데 - 정말 값진(!) 경험이었을 거예요. 그렇게 안 좋은걸 정말 본인이 느껴봐야 알 수 있는데 코드를 더럽게 만든 보람이 생기는군요.\n\n점진적 개선에 대한 깨달음도 인상적입니다. AI가 제안하는 단계에서도 더 세세하게 나누어야 한다는 것을 직접 경험하신 것은 정말 소중한 인사이트예요. 제가 강조했던 것 중 하나로 리팩토링에서 가장 중요한 것이 바로 \"작은 단위로 안전하게 개선하기\"인데, AI에게 일을 시키면 그런거 없이 자기가 알고 있는 최선을 만들겠다고 하다가 고장나버리잖아요? 내가 가고자 하는 목표를 가기 위해서 점진적인 계획을 촘촘하게 잘 세울수 있는것이 정말 중요하구나 하는걸 느꼈기를 바랍니다.\n\nQ) \n의존성 주입 패턴의 최적화 : 현재 createSetupEventListeners 함수에서 7개의 함수를 매개변수로 받고 있는데, 이는 함수 시그니처가 복잡해지고 호출하는 쪽에서도 많은 의존성을 전달해야 합니다. 이런 구조에서 의존성을 더 효율적으로 관리할 수 있는 방법이 있을까요? 예를 들어, 의존성 컨테이너 패턴이나 서비스 로케이터 패턴을 도입하는 것이 이 규모의 애플리케이션에서는 과도한가요?\n\n=> 함수의 적절한 인자의 개수는 3개 이하이며 그 이상이 되는 경우에는 하나의 객체로 받아주는게 좋습니다. 그렇지 않다면 재활용을 하기에 어렵다는 반증이니까요. 그렇지만 단순히 코드를 분리하고 정리하기 위해서 그렇게 사용하는 경우가 있습니다. 함수가 재사용이 아니라 단순히 경계만 만들어주기 위한 도구로 말이죠. 그건 그거 나름대로 괜찮다고 생각합니다.\n\n\nQ) DOM 조작 추상화의 적절한 수준 : domElements.js에서 20개 이상의 안전한 래퍼 함수들을 만들었는데, 이는 DOM 조작의 안전성을 높였지만 동시에 코드 복잡성도 증가시켰습니다. 이런 수준의 추상화가 적절한지, 아니면 더 간단한 방식으로 DOM 조작을 안전하게 할 수 있는 방법이 있는지 조언 부탁드립니다.\n\n=> jQuery의 패러다임이 DOM 조작의 래퍼함수였죠. 그리고 그게 현대 웹 프레임워크에서는 DOM API를 아예 쓰지 않는 방향으로 진화했습니다. 현대의 관점에서 볼 때에는 낡은 패러다임의 전략이긴 하죠. 그리고 현대의 DOM API는 나쁘지 않기에 래퍼함수 없이 최소한의 DOM API를 직접 사용하거나 완전히 현대적 프레임워크 방식으로 넘어가는게 더 좋은 전략이라고 생각합니다.\n\nQ) 비즈니스 로직과 UI 로직의 분리 기준 : 현재 businessLogic.js에서 516줄의 복잡한 계산 로직을 담고 있는데, 이 파일이 너무 크고 복잡해졌습니다. 이런 비즈니스 로직을 더 세분화하여 분리할 수 있는 기준이나 패턴이 있을까요? 예를 들어, 할인 계산, 포인트 계산, 재고 관리 등으로 더 세분화하는 것이 좋을까요?\n\n=> 비즈니스 로직의 분리 기준은 언제나 요구사항입니다. 요구사항으로 분리를 하다보면 자연스럽게 상위 개념의 그룹이 만들어지고 그러니까 할인, 포인트, 재고 등으로 그룹핑을 할 수 있는거죠. 처음부터 내려 오듯이 세분화를 하면 더 복잡해지기 마련입니다. 하나의 온전한 요구사항을 해결할 수 있는 단위를 분리하고 이들이 함께 있으면 좋을 곳으로 배치한다가 결합도를 낮추고 응집도를 높여가는 좋은 전략입니다.\n\n수고하셨습니다. 다음 주차도 화이팅입니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/22"
    }
  },
  {
    "passed": true,
    "name": "김효진",
    "feedback": "안녕하세요 효진님! 4주차 과제 잘 진행해주셨네요 ㅎㅎ 너무 고생하셨습니다!\n기본과제에 있는 코드를 심화과제에 재활용 하기 위한 노력들이 많이 보이는데요,\n\nutils 폴더에 작성된 다양한 비즈니스 로직을 아예 공용 폴더로 만들어서 기본과제에서도 사용하고 심화과제에서도 사용하는 방식으로 작성이 되었으면 더 좋았을 것 같아요!\n\n특별한 질문은 없어서 피드백은 여기서 마무리하도록 하겠습니다 ㅎㅎ\n고생하셨어요!!\n\n---\n\n안녕하세요 효진님~ 다시 확인해보니 과제에 질문이 생겼네요 ㅎㅎ\n\n> 리팩토링 진행의 우선순위를 어떻게 잡았으면 좀 더 안정적인 코드 리팩토링을 할 수 있었을까요?\n\nAI를 활용한다면.. 저는 아마 이런 질의를 통해 진행할 것 같아요!\n\n1. 현재 테스트 코드와 구현된 코드를 토대로 실제 이 어플리케이션의 요구사항과 엣지케이스를 추출해줘.\n2. 먼저 현재 코드에서 UI에 대한 부분과 비즈니스(도메인)에 대한 부분을 점진적으로 분리하고 싶어. 어떤 단계로 진행하면 좋을지 알려줄 수 있을까?\n3. 계획을 잘 세워줬네! 여기서 내가 하면 더 효과적인 부분과 너를 사용하면 더 효과적인 부분을 구분해줄 수 있을까?\n4. 잘 구분해줬네! 이제 우리가 서로 협업하면서 진행을 해보자.\n\n~~~ 쭊쭊 진행\n\n5. 어느정도 정리가 된 것 같아. 여태까지 진행한 내용을 문서로 만들어줄 수 있을까?\n(문서화 진행)\n\n그 다음 이제 새로운 채팅을 하나 만들어주세요.\n1. 여태까지 내가 작업한 내용이 XXX.md 에 기록되어있어. 이제 다음 단계를 진행할 차례야. 요구사항/엣지케이스/테스트코드/JS 등을 기반으로 react로 구성하고 싶어. 이 때 재활용할 수 있는 코드가 얼마나 있을까?\n2. 그렇다면 재활용할 수 있는 형태가 최대한 많았으면 좋겠어. 이를 토대로 현재 코드를 리팩토링 하고 싶어. 어떤 코드부터 정리하면 좋을지 알려줄 수 있을까? 작업은 내가 해볼게\n3.. 현재까지 진행한 내용을 문서로 정리해줘.\n\n다시 새로운 채팅을 만든 후에\n1. 여태까지 내가 작업한 내용이 XXXX.md 파일에 있어. 이제 작업을 이어서 해야 돼. 리액트로 코드를 구성해줄 수 있을까? 특히 엣지케이스를 꼼꼼하게 채워주면 좋겠어. 무엇보다 기존 코드를 최대한 재활용하는 방식이어야해!\n2. 여태까지 작성된 코드에 대한 단위테스트를 만들고 싶어. UI보단 hook과 function 위주로 테스트를 만들어주고, 엣지케이스가 최대한 많으면 좋겠어.\n\n> AI로 작업을 할 때 중간중간 룰을 바꾸면서 진행하는게 좋지 않은 방법일까요? 아니면 상황에 따라 룰을 변경해도 크게 상관없을까요?\n\n저는 굉장히 자주 바꾸는 편이랍니다 ㅋㅋ 뭔가 마음에 안 들면 그냥 바꿔버린달까...",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/9"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김휘린",
    "feedback": "수고했어요! 전역변수를 해결하는 방식으로 만든 현대적 방법인 store를 떠올리고 변수를 직접 건드리는 형태가 아니라 액션을 통해서 격리하는 방식을 느껴본 부분이 참 좋네요. 또한 테스트가 제일 중요하다고 이 과제를 통해서 느꼈다고 하니 너무 좋습니다.\n\nstore을 만드는데 걸리는 시간이 거의 대부분이었다니 실제로 현업에서도 UI와 기능이 만들어지고 나면 그 다음에 수정하는 건 전부 데이터와 관련해서죠. \n\nAI를 쓰지 않으니 몰입이 된다는 인사이트도 좋네요. 언젠가 우리 모두 AI를 쓰게 되더라도 그 몰입의 감각을 기억하면서 잘 쓰고 있는지 의존하고 있는지 구분하면 좋겠네요\n\n(웃음) \"... 그냥 마음속으로는 내가 basic을 잘 만들어놔서 AI가 쉽게 가져온걸꺼야.. 라고 생각하는 중이긴 합니다..!!\" 라는건 실제입니다. 좋은 응집도와 분리하기 쉬운 구조를 가지고 만든다면 나머지는 정해진 방법이 있다는 뜻이고 그게 우리가 좋은 구조를 유지해야하는 이유인거죠! 잘했습니다. 만약 AI의 능력이 뛰어난 것이라면 내가 아무것도 하지 않아도 잘 했어야 겠죠ㅎ\n\n함수를 어디까지 쪼개야 하는가? 정답은 있죠. 단일 책임이어야 한다는 거, 추상화 계층을 지켜야 한다는 거. 그렇지만 제가 알려준다고 한들 감은 본인이 잡아야 하는거겠죠? 감이 오지 않기에 최대한 다양한 방법들로 시도하면서 이정도가 좋구나 하는 것들을 이번 5주차 6주차 과제를 하면서 느껴보세요.\n\n감을 찾는데 힌트를 느리자면 좋은 코드는 와! 너무 좋다 이런 느낌은 아니에요. 신경 쓰이지 않는 느낌이랍니다. 그래서 나쁜 코드가 아닌 코드들을에서 왜 나는 이 함수 정도면 괜찮다하고 넘어간거지? 하면서 그걸 말로 표현하거나 서술해보려고 해보세요. 경험적으로 감각은 길러지는데 왜 그런가에 대해서 언어로 정립을 해보려고 하면 훨씬 더 빨리 감을 잡을 수 있을거에요.\n\n수고하셨습니다. 5주차 과제도 화이팅입니다.",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/51"
    }
  },
  {
    "passed": false,
    "name": "박상수",
    "feedback": "상수님 수고 많으셨습니다!\nMR 회고 내용이 없네욥~(제가 못찾은건가요? 지금 리뷰하는시점에는 없습니다~)\n역랑을 궁극적으로 발전시키는데에는 동작하는 코드도 중요하지만 코드에대한 생각 정리와 과정에 대한 복기인 것 같습니다!\n다음에는 과제 수행여부에 상관없이 MR회고 내용도 같이 준비해주시면 좋을 것 같습니다~",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/23"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "고생하셨습니다 소연님!\n꽤 과제양이 많았던 것 같은데 그래도 마무리를 잘 해주셨네요!\n전반적으로 작성해주신 코드를 보면 아직까지는 조금 더 개선할 여지가 많이 남아있는 것 같아요! 한 함수 또는 컴포넌트에서 너무 많은 책임을 갖고 있는 부분도 보이고 절차적으로 쭉 나열이 되어있다보니 가독성 측면이나 추후 유지보수를 하는데 있어서도 아쉬운 부분도 있구요!\n\n회고에 작성해주신 것 처럼 리팩토링에 시간을 많이 들이다보니 전반적인 시간 관리가 아쉬웠다고 말씀을 해주셨는데요. \n사실 현업에서 이런 전체적인 리팩토링을 1주일안에 모두 마무리 하는 경우는 크게 없죠 ㅎㅎㅎ 큰 수정인 경우 명확한 검증이 뒤따라야 하니까요. 다만, 경험적인 측면에서 그리고 리팩토링 기법을 훈련한다는 측면에서 작게작게 단위를 나눠보면 좋을 것 같아요. 이런 주제들은 테오가 피피티 또는 블로그를 통해 공유해주신 글들을 참고하면 좋을 것 같은데요. 여기서 등장하는 하나의 소제목 대제목들을 내가 이번 리팩토링 기한내에 이번 모듈에서 해결한다는 관점에서 가는거죠. 요즘은 AI를 활용할 수 있으니 모듈의 범위를 좀 더 넓게 잡고 한번에 개선하고 검토하는 것도 방법이 될 수 있겠죠?\n\n개인적으로는 이런 주제를 전부 AI에게 던지고 수정을 맡기는것보다는 어떤 과정으로 작업을 진행할 지 물어보고 검토를 하면서 수정을 진행하는 형태나 작게 작게 명확한 작업 지침을 주고 검토하는게 작업속도 측면에서 아직 괜찮더라구요. 아니면 rules를 매우 구체적이게 주는 것도 방법일 수 있구요.\n\n아무튼 말이 길었는데, 정리하면 리팩토링의 단위는 작게 그리고 검증 이에 따른 반복이 핵심입니다. 작성해주신 것 처럼 검증 단계를 명확하게 하는 연습이 필요합니다.\n\n담주도 화이팅입니다~",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/30"
    }
  },
  {
    "passed": false,
    "name": "박의근",
    "feedback": "안녕하세요 의근님!\n이번주는 많이 바쁘셨나보군요 ㅎㅎ\n그래도 팀원들이 응원하는 모습을 보니까 마음이 따듯해져서 좋네요!\n\n너무 무리하지 말고 할 수 있는 만큼만 해주세요!! 화이팅입니다!!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/63"
    }
  },
  {
    "passed": false,
    "name": "박준형",
    "feedback": "안녕하세요 준형님! 역시 믿고 보는 준형님의 과제네요 ㅎㅎ\n\n### 1. MVVM 패턴 적용에 대한 방향성\n\n저는 react 자체가 mvvm 이라고 생각했는데요, 제가 생각하는 MVVM은 이렇습니다.\n\n- Model: 데이터\n- View: UI(=HTML)\n- ViewModel: UI를 본따서 만든 데이터\n\nreact에서의 view model은 jsx 인거죠 ㅎㅎ 그리고 이 jsx에 변화를 가하면 ui에도 변화가 생기는 모습이 mvvm 이라고 생각했어요.\n\n여튼, 각설하고\n\n현재 작성해주신 패턴에 대해서는 큰 이견이 없는 상태입니다. 제가 생각하기에 View Model 보다는 VAC 에 조금 더 가깝지 않나!? 라는 생각이 들어요! VAC는 component로 분리하는 모습인데, 준형님께서는 hook으로 분리해주신거죠 ㅎㅎ\n\nhttps://wit.nts-corp.com/2021/08/11/6461\n\n그리고 적합함을 판단하는 기준이 필요할 것 같은데요,\n저는 \"요구사항에 잘 대응할 수 있는가\"를 기준으로 살펴볼 것 같아요.\n\n가령, 할인율에 대한 요구사항이 추가된다고 했을 때 이를 잘 대응하는가!? 에 대한 부분인데요\n컴포넌트는 수정하지 않아도 될 것 같고\nViewModel 내부의 로직들을 수정하면 되기 때문에 나쁘지 않다고 생각해요 ㅎㅎ\n\n그런데 제가 코드를 쭉 살펴봤는데...\n안쓰이는 코드가 너무 많네요 ㅠㅠ\n\n심화과제에서 어디서 어떻게 할인이 이루어지는지 파악하는게 지금... 너무 힘들어요\n다른 이유 때문이 아니라 가짜 코드 때문에 힘들달까..\n이름은 할인율에 대한 코드인데 살펴보면 이 코드를 쓰는 곳이 없어요. 테스트는 작성되어있지만...?\n\n- UI가 수정 될 때 -> 핵심 로직을 그대로 사용하면 됨.\n- 비즈니스 로직이 수정될 때 -> MVVM 때문이라기보단... 현재 정리되지 않은 코드들 때문에 애매한 부분이 있음\n\n이렇게 요약할 수 있겠네요!\n\n\n### 2. 페르소나 기반 협업 전략\n\n개인적으로 \"아키텍쳐 전문가\" 라는 페르소나도 있으면 좋을 것 같아요 ㅎㅎ 현재 설계에 대한 장단점, 확작성에 대해 평가하고 개선점을 제안하는 그런 역할이 있으면 어땠을까 싶네요!\n\n이 외에 부분은 무척 좋은 방향이라고 생각합니다.\n\n다만, \"사용자 시나리오\"를 페르소나 단위 보다는 엣지케이스 단위로 정의하면 어땠을까 싶습니다.\n\n최대한 많은 엣지케이스를 뽑아내고\n이 엣지케이스에 대응하기 적절한 전략을 가져오는거죠.\n\n지금은 \"이 설계대로 만들꺼야!\"를 정의 하여 진행하는 방식인데, 저는 제품과 제품의 도메인 대한 설계 전략이 있어야 한다고 생각해요.\n\n목표가 설계가 되기보단, 목표가 제품이 되고 이 제품에 들어맞는 설계를 찾아내는 방식으로 시도해보는거죠\n\n\n### 3. 마이그레이션 시점과 전략\n\n앞선 내용과 이어지는 부분인데요, 꼭 MVVM을 선택해야 했는가? 에 대한 부분이 의문이랄까...\nMVVM으로 했어야 하는 이유가 있으면 좋았을 것 같아요. 필요한 이유를 산출하는 과정 같은게 필요하지 않을까요!?\n\n진입장벽이 높아졌다는게 아마 코드를 수정할 때 알아야할 것들이 많아졌다 라고 제가 이해했는데요,\n\n제가 아마 이 과제를 수행했다면,\n\n기본과제와 심화과제의 코드를 공유하기 위한 domain package 를 하나 더 추가했을 것 같아요 ㅎㅎ\n그리고 이 코드를 양쪽에서 연결하기 위한 장치가 있으면 좋아겠죠? 아니면 아예 그냥 양쪽 모두 reducer로 개선한다거나.\n\n\n### 4. 테스트 전략 및 ViewModel 단위 테스트\n\n저는 ViewModel에 대해서는 100%의 커버리지를 채워주면 어떨까!? 라는 생각입니다. 충분히 현실적인 테스트 전략이라고 생각해요.\n\n저는 component의 비즈니스 로직을 훅으로 분리하고 이 훅에 대해서는 커버리지를 100% 채우려고 하는 편입니다. 그게 저희 팀에서 PR이 머지되어야 하는 조건 중에 하나이기도 해요.\n\n다만 꼭 훅이 알 필요 없는 UI와 관련된 로직은 그냥 Component에 잔류시키는 편이랍니다 ㅎㅎ\n\n### 5. 성능 최적화 및 상태 관리 전략\n\n성능에 대한 관점으로 보자면.. 최악이라고 할 수 있죠 ㅋㅋ\n모든 값이 다 context를 의존하고 있고 context가 최상위 계층을 의존하고 있어요.\n\nMVVM 구조에서 꼭 context를 선택해야 했는가? 라고 했을 때.. 굳이? 라는 생각이 있어요.\n말씀해주신 것 처럼 zustand를 사용하는 방법도 있고!?\n\n무엇보다 모든 값을 다 최상위에서 관리할 필요는 없다고 생각합니다 ㅎㅎ\n더 정확히는, 도메인에 대한 로직은 한 폴더에 묶어서 관리하면 좋지만 \n이 값을 아예 최상위에서 다 내려주는건 다른 문제라고 생각해요.\n\n### 6. 확장성과 유지보수 관점\n\n말씀해주신 것처럼 가령 멀티뷰나 서버 API 변경 등에 대응하기가 지금 당장은 어려울 수 있겠지만\n그런데 또 그렇게 어려운가? 라고 생각해보면 아니라고 생각해요 ㅎㅎ\n현재 구조에서 외부 의존성을 받아들일 수 있는 구멍을 하나 만들어준다거나 하는 방식으로 확장하면 어떨까 싶어요.\n\n\n---\n\n이번 과제를 아예 MVVM으로 만들꺼야! 라는 목표로 진행해주신 것 같아요.\n다만 MVVM을 꼭 써야만하는 이유나 의사결정 과정이 눈에 보이지 않은게 제일 아쉽달까..\n특히 기본과제와의 연결성이 약해요.\n기본과제에서 작성한 코드가 재활용되면 좋겠는데 구조가 완전히 바뀌면서 연결되는 모습이 흐려졌네요 ㅠㅠ\n\n---\n\n현재 할인율 기능이 누락되어서,\n테오코치님과 상의한 결과 \"그러면 아쉽지만 탈락이라고 생각합니다. 리팩토링에서 제일 중요한건 기존 로직을 누락시키지 않는다는 것인데... 기존 로직이 누락된 리팩토링을 구조가 좋다고 잘했다고 할수는 없다고 생각합니다\" 라는 결론이 내려졌어요.\n\n열심히해주셨는데.. 아쉽지만 불합격입니다 ㅠㅠ",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/4"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박창준",
    "feedback": "고생하셨습니다 창준님.\n이런 코드를 개선하는데에서 즐거움을 느끼셨다니 대단하신데요 ㅎㅎ\n나름의 흐름을 정의하고 접근 하는 방향은 매우 좋았습니다.\n클린 코드의 관점에서도 많은 부분을 고민하셨던 게 문서에 나와있어서 잘 하셨습니다.\n과제에 있어서는 좀 더 개선이 필요한 부분이 있지만 충분히 시간적 여유가 있다면 지금의 관점으로 접근하면 개선이 가능할 것 같아요. 잘 하셨습니다!\n\n질문 주신 부분 답변 드려보고 마무리해볼게요.\n\n> 특정 서비스에서 아주 일부 기능(1~2개 함수)만 사용하기 위해 전체 서비스를 주입하는 건 과도한 의존일까요?\n\n우선 지금의 설계가 나쁘다고는 전혀 생각이 들지는 않는 것 같아요. 회고에서 작성해주신것처럼 서비스간의 의존성을 낮추는 관점, 테스트의 용이성 관점에서 코드 파악이 쉬워지고 응집도도 높아지는 것 같아요. 변경에 유연하기도 하구요. 전혀 과도해보이지는 않아요!\n\n\n고생하셨고 다음주 과제도 이번 주처럼 잘 진행해보시면 좋겠습니다. 화이팅입니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/17"
    }
  },
  {
    "passed": true,
    "name": "신홍준",
    "feedback": "홍준님 수고많으셨습니다!\n\nQ. 좋은 커스텀 훅은 무엇인지, 커스텀 훅은 어떤 식으로 작성해야 하는지 궁금합니다.\n\n일단 useAutoEvent 아이디어는 좋다고 생각합니다. 그리고 사실 답이 정해진 것은 아닐 것 같아요.\n저라면 \"번개세일\", \"추천할인\"을 별도의 코드로 구분하지 않고 데이터로 활용할 것 같아요.\n.\n...음 저라면 어떻게 할지 적으려니까 너무 많아지는 것 같아서요. 저라면 할 것을 요약하면..\n\n구조적인 것보다는 코드를 리팩토링해서 중복되는 코드를 제거할 것 같아요.\n핵심은 이벤트를 추상화해서 번개인지 추천할인인지는 데이터로 구분하겠다 입니다.\n그리고 만들어진 이벤트 목록을 start, destory하는 인터페이스를 노출하게 될 것 같아요.\n이렇게되면 n개의 타입을 가진 n개의 이벤트를 관리할 수 있게 확장할 것 같습니다.\n왜냐하면 번개세일과 같은 프로모션 타입은 언제든지 늘어날 수 있으니까요.\n이벤트라는 것을 추상화해서 이 이벤트가 어떤 타입인지를 아는 코드를 줄이겠다는 것이 큰 아이디어입니다.\n\n\nQ. 컴포넌트는 어느 정도 단위로 나누어야 할까요?\n\nA. 정답이 없는 것 같아요~ 다만 컴포넌트를 나누려고 나누기보다는 컴포넌트가 나눠달라고 신호를 보낼때 나눠도 충분하다는게 제 생각입니다\n너무 나누는 것부터 시작하시지 마시고 큰 덩어리 컴포넌트 하나라도 괜찮으니 기본적이 아이디어로만 나누고 일단 시작하면서 코드가 보내는 신호를 보면서 그때그때마다 분리하고 혹은 반대로 합쳐도 됩니다.\n\n그 신호는 로직의 그루핑이 될 수 있고, 코드의 재사용일 수도, 혹은 코드의 길이 일 수도 있습니다. \n너무 나누는 것에 집착하실 필요 전혀 없습니다! 나누면 나눌수록 아시다시피 코드를 읽는 시간이 더 걸립니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/57"
    }
  },
  {
    "passed": true,
    "name": "신희원",
    "feedback": "수고했습니다! AI에게 질문을 잘하는게 중요하죠. 이번 과제에서 특히나 내가 목적지를 모른채로 해달라고 큰일(?) 날 수 있다는 걸 꼭 알려주고 싶었어요. AI를 잘쓴다라는 건 AI를 잘 아는게 아니라 내가 필요한 관련 지식을 잘 설명하는 능력이라 생각해요.\n\n처음에는 계획했던 대로 진행을 했지만 점점 테스트 통과가 목표에 급급해서 아쉽다해서 테스트 코드에 연연하지 않고 리팩토링을 해야겠다 생각을 했다 하지만 테스트 코드가 없이 리팩토링을 하는건 훨씬 더 어려운 작업이랍니다. \n\n내가 수정한 코드가 문제가 없을 거라는 확신을 가진채로 코드 수정을 해야 하니까요. 내가 한땀 한땀 수정을 한다면 이 코드는 이렇게 변경을 해도 버그가 없을거야 라고 진행할 수도 있겠지만 AI를 활용한다면 AI가 수정한 코드가 문제가 없을거라고 확신하면서 리팩토링을 하는게 참 어렵죠.\n\n물론 그 또한 본인이 느껴보는게 제일 좋죠. 테스트 코드가 없는 상태에서 리팩토링을 한번 도전해보는 것도 흥미로운 경험이 될거에요. 코딩은 학문이 아니라 운동의 일종이라 결국 실습하고 경험을 해봐야 성장할 수 있을테니까요. \n\n어떤 순서인지는 중요하진 않아요. 다만 너무 큰 구조 변경을 한번에 하려고 하기 보다는 이런 수정은 해도 코드에 전혀 문제가 생기지 않는 작업을 시작으로 언제든 분리가 가능할 수 있도록 엉켜있는 걸 풀어 두는게 중요해요. 그래서 줄바꿈, 주석 추가, var -> const, 템플릿 변경, 코드 순서 변경, 이름 변경등 코드의 영향을 주지 않는데 코드가 더 나아지는걸 우선으로 함수 빼내기, 순수함수로 만들기, 등등으로 결합도를 낮추는 작업을 하고 나면 이제 서로 연관이 있는 것끼리 한 곳에 두는 응집도를 높이는 방향으로 진행하게 됩니다.\n\n수고많았어요! 5주차 과제도 화이팅입니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/38"
    }
  },
  {
    "passed": true,
    "name": "양성진",
    "feedback": "안녕하세요 성진님! 4주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n\n> 너무 많은 props 전달이 괜찮은가여? OrderSummary에 10개 이상이 props 전달을 하는데 더 나은 데이터 구조화 방법이 있을까요?\n\n현재 props를 관심사에 따라 그룹핑해주면 어떨까 싶어요.\n일단 제가 임의로 추출한건 4가지인데요\n\n```tsx\n<OrderSummary\n\t장바구니데이터={장바구니데이터}\n\t할인율데이터={할인율데이터}\n\t포인트데이터={포인트데이터}\n\tonCheckout={handleCheckout}\n/>\n```\n\n이렇게 네 가지로 분리해서 넘겨주면 어떨까 싶네요!\n\n꼭 1depth로 모든걸 다 처리할 필요는 없답니다 ㅎㅎ\n\n> Layout 컴포넌트 구조가 적절한가요? leftContent/rightContent로 나눴는데 이런 식으로 구조를 나눠보는게 괜찮은가요?\n\n적절함을 판단하는 기준이 뭘까요? 이런 질문은 사실 모호해서 답변드리기가 어려워요.\n다음부터는 \"저는 이러이러한 기준으로 적절함을 판단했고, 그래서 이렇게 작성했어요. 괜찮을까요?\" 처럼 질문을 주셔야 답변드리기가 수월하답니다!\n\n일단 저의 기준을 토대로 이야기드리자면, 저는 \"다양한 요구사항에 대응할 수 있는가\"를 기준으로 판단할 것 같아요.\n여기서 가령 지금은 PC 버전의 UI만 대응할 수 있는데요, 만약에 모바일 버전의 UI를 동시에 대응해야 한다면 left,right 라는 이름이 병목이 될 수 있겠죠!? 모바일에서는 좌/우 UI가 아니라 상/하 UI로 표현이 되어야 할테니까요 ㅎㅎ\n\n> 타입 정의 위치 기준이 따로 있을까요? 언제 types/ 폴더에 빼고, 언제 컴포넌트 내부에 두나요? 따로 이런걸 판단하거나 하는 기준이 있을까요?\n\n현재 정의한 type과 가장 가까운 곳에 위치시키면 좋답니다!\n가령, 내가 작성한 코드를 라이브러리 혹은 모듈로 똑 떼어서 다른 프로젝트에 적용한다고 했을 때 이게 깔끔하게 도려내져야해요.\n함께 쓰이는 코드의 위치가 멀리 있으면 이걸 분리하기가 굉장히 어렵답니다 ㅎㅎ\n즉, 응집도가 낮은거죠.\n\n응집도가 높다면 라이브러리/모듈 등으로 분리하기가 굉장히 쉬워요!\n\n\n---\n\n기본과제에서 작성한 코드를 심화과제에서도 잘 사용해주신 모습이 인상적이네요!\n회고만 더 체계적으로 작성되어있다면 완벽했을 것 같아요..!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/42"
    }
  },
  {
    "passed": false,
    "name": "양창훈",
    "feedback": "안녕하세요 창훈님!\n4주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다. 다만 심화과제는 진행할 시간이 없었나보네요 ㅠㅠ\n\n---\n\n> 제가 협업 프로젝트에대한 경험이 없어서 그러는데 실제 큰프로젝트에선 무조건 한개의 함수안에서 한개의 책임만을 가지게 하나요? 아니면 상황에 따라 다르게 구현 할까요?~\n\n무조건... 은 없는 것 같아요 ㅋㅋ\n가능하면 한 개의 함수가 한 개의 일만 하도록 만들어야 유지보수 하기가 수월해지기는 해요!\n\n가령 회사에서 팀장은 팀원이 하는 일에 대한 오케스트레이션을 하거나, 매니징을 하거나, 조금 더 어려운 문제를 찾아서 해결방안을 제시하고 위임하는 등 조금 더 넓은 범위의 일을 해야 하는데 자잘한 업무를 한다거나 직접 실무를 하게 된다면 다른 일을 하기가 어려워져요.\n\n여기서 이야기 하는 \"책임\"과 \"한 가지 일\"의 의미는 이런 것들입니다. 나의 책임과 책임에 맡은 일을 하고 있는가 에 대한 부분인거죠.\n\nhttps://junilhwang.github.io/TIL/clean-code/%EC%A1%B0%EA%B0%81%EB%AA%A8%EC%9D%8C/%EC%B6%94%EC%83%81%ED%99%94%EB%A5%BC-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/\n\n제가 최근에 작성한 글인데요, \"한 가지 일\"을 조금 더 구체적으로 정의한 내용이니 한 번 참고 부탁드려요!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/39"
    }
  },
  {
    "passed": true,
    "name": "여진석",
    "feedback": "안녕하세요 진석님! 4주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 이런 리팩토링을 진행할 때 테스트코드가 제일 중요하다고 느낀 것 같습니다.\nAI한테 기본 과제 테스트코드 내용을 그대로 반영해서 React에서 사용하는 코드 기반으로 테스트코드를 만들어달라고 했는데, 기능 자체를 누락해서 만들어주는 일들이 있었습니다. 테스트 코드에서 이런일이 발생해서는 안될텐데, 테스트코드를 AI에게 작성시키는 것에 대해서 어떻게 생각하시는지 궁금합니다!\n\n이건 AI가 잘못한게 아니라 명령을 잘못한거라고 생각해요 ㅋㅋ\n더 정교하게 요구사항을 전달하면 잘 작성해주었으리라 생각합니다.\n\n이런식으로 진행하면 어땠을까요?\n\n1. 현재 테스트 코드와 구현된 코드를 토대로 실제 이 어플리케이션의 요구사항과 엣지케이스를 추출해줘.\n2. 요구사항/엣지케이스/테스트코드/JS 등을 기반으로 react로 구성하고 싶어. 이 때 재활용할 수 있는 코드가 얼마나 있을까?\n3. 그렇다면 재활용할 수 있는 형태가 최대한 많았으면 좋겠어. 이를 토대로 현재 코드를 리팩토링 해줄 수 있을까?\n4. 현재까지 진행한 내용을 문서로 정리해줘.\n\n그 다음에 새로운 채팅을 만든 후에\n5. 여태까지 내가 작업한 내용이 XXXX.md 파일에 있어. 이제 작업을 이어서 해야 돼. 리액트로 코드를 구성해줄 수 있을까? 특히 엣지케이스를 꼼꼼하게 채워주면 좋겠어. 무엇보다 기존 코드를 최대한 재활용하는 방식이어야해!\n\n요로코롬 진행하면 어땠을까 싶네요 ㅎㅎ\n\n> 이렇게 큰 파일 기반의 리팩토링할 때 AI를 사용했더니 비용이 너무 많이 나가게되는 것 같습니다. 이럴 때 token비용을 절약할 수 있는 노하우가 있을까요?\n\n모든 기능을 AI에게 위임하는건 좋지 않다고 생각해요. 가령, js를 react로 전환할 때 재활용할 수 있는 코드가 많다면 굳이 AI를 사용하지 않고 내가 진행해도 빠르게 진행할 수 있었으리라 생각합니다.\n\n그리고 제가 위에 남긴 피드백처럼, 중간정산을 항상 잘 해주세요 ㅎㅎ 진행한 내용을 문서로 남기고 이 문서를 기반으로 다시 새로운 컨텍스트를 만들어서 진행하는거죠.\n\n이렇게 하면 꽤 많이 절약할 수 있답니다!\n\n---\n\n저는 심화과제를 진행할 때 제일 중요한건 기본과제와의 연결성이라고 생각해요. 이게 지금 약해서 아쉽네요..!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/62"
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "안녕하세요 찬규님!\n4주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n---\n\n> app-state에 전역 상태를 몰아넣은 구조가 적절한가?\n\n전역 상태를 몰아넣는 방법은 좋다고 생각해요!\n다만 전역 상태를 props를 통해 계속 하위 컴포넌트로 전달하는 방식은 사실 좋은 방법이 아니라고 생각해요.\n\n불필요한 렌더링이 계속 발생하기 때문이죠 ㅎㅎ\n그래서 이럴 때 상태관리 라이브러리를 통해 관리하면 좋답니다!\n\n> feature 간 의존성(shopping-cart에서 product-selection 타입 참조 등)이 생기는 게 괜찮은가?\n\n상호 참조(shopping-cart가 product를 참조하고, 다시 product가 shopping-cart를 참조)가 생기는게 아니라면 무방하다고 생각합니다! 자연스러운 현상이지 않을까 싶네요!\n\n> 실무에서도 이런 구조를 쓰는가?\n\n저희 팀은 이렇게 작성하는 편입니다 ㅎㅎ 다만 feature라는 이름을 직접적으로 사용하진 않고 있어요.\n\n중요한건 feature가 아니라 \"응집도\" 라고 생각합니다. 응집도를 높일 수 있다면 어떤 구조든 상관없다고 생각해요!\n\n지금은 응집도가 높은 형태로 구성해주셔서 사실 feature인지 아닌지는 중요하지 않은 것 같네요 ㅎㅎ\n\n\n---\n\n다만 조금 아쉬운 점은 basic의 코드를 advanced에서 재활용하면 좋았을텐데 이게 아쉬워요!\n\n가령, basic의 service가 advanced에는 없다거나.. 똑같은 이름의 service여도 내부를 보면 코드가 아예 다르네요..!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/61"
    }
  },
  {
    "passed": true,
    "name": "오하늘",
    "feedback": "눈물을 머금고 롤백. ㅋㅋㅋ 수고했습니다. 그렇게 시행착오를 겪어가면서 특히나 뭔가 강렬한(!) 경험이 있을 수록 얻어가는게 많은 만큼 좋은 경험이 되었을거라 생각합니다. \n\n\"... 또 문제가 생겼다. 이제 토큰 거의 다 바닥 났어요... 하는 AI를 붙잡고 이것저것 물어보면서 변경하는 중에, **이 친구가 이벤트 함수 리팩토링을 전혀 하지 못하는 것이다.** 즉, 이벤트 함수만 만지기만 했다고 하면 테스트 코드 함수가 전부 fail 뜨는 것이다. (이럴 수가 있나?)\n**결국.. 이벤트 함수는 내가 작성했다..**...\"\n\nㅋㅋ 마치 소설마냥 재밌는 표현이었습니다. AI는 특히나 이렇게 본인이 학습하지 않은 결과 밖에서의 맥락에서 상당히 많이 헤맨다고 생각해요. AI가 잘할 수 있는 것과 내가 하는게 더 빠르고 나은 것들에 대한 경계등을 생각해 볼 수 있는 좋은 시간이 되었기를 바래요.\n\n\"나.. 성장했구나..! 생각이 들었다. 아무튼 결론은, for문은 죄악이다.\" ... 맞습니다. 죄악 까지는 아니겠지만 명령형 코딩에서 왜 선언적 코딩을 하는 식으로 진화를 했는지를 짧은 시간내에 느꼈다니 너무 좋습니다. 생각을 더 확장해서 단순히 for보다는 map, reduce가 DOM보다는 jsx방식으로 점점 선언적으로 개발하는 방법으로 진화했다는 것을 느끼는 시간이었기를 바래요.\n\nQ) 아직 폴더 구조를 어떻게 나누어야 할지 모르겠습니다. 회사에서 프로젝트를 진행하는데, 에이전시이다 보니까 유지/보수보다는 처음부터 구축할 일이 많은데요, component 폴더 안에 공통 컴포넌트는 또 common으로 나누어야 하나? 그런데 common으로 쓰다가 또 자주 쓰일 일이 없으면 어쩌지? 한 곳에서만 쓰일 줄 알았던 컴포넌트가 사실은 공통이면 어쩌지? 같은 생각과.. core 폴더보다는 ts라는 폴더로 사용한 경험이 많아서 익숙하지가 않습니다. 코치님께서는 어떤 기준으로 폴더를 나누시나요? 이건 다음 주차 때 나올 이야기가 맞지요? \n\n=> 폴더구조는 6주차에 만나게 될거에요ㅎ 우선 이미 개념적으로 확립된 분리 기준이 있어요. 크게 화면, 데이터, 기능 이라는 큰 카테고리를 중심으로 구분을 합니다. 그리고 도메인과 비도메인을 구분해요. 그리고 순수함수와 비순수함수가 있구요. 역할로는 component, hooks, utils 등이 있겠네요. 일단 분리의 개념을 먼저 익혀보세요. 계층을 먼저 신경을 쓰다보면 안 분리해도 될 걸 억지로 계층에 맞춰서 분리하려고 하게 되죠\n\n=> 분리를 하고 import를 통해 재사용을 하도록 하다보면 서로 가까이 두는게 좋은 것들 성격이나 목적이 비슷한 것들을 느끼게 될거에요. 자연스럽게 그런 파일들을 한곳에 두면서 적절한 이름을 붙이는 방식이 폴더구조를 만드는 방식입니다. 그렇게 만들어진 폴더구조 위에서 다음번에 만드는 것들은 자연스레 폴더구조를 따라가고 확장해나가는 식으로 진행이 되는거죠. 자세한 내용은 폴더 구조 시간에 또 설명해줄게요 :)\n\n\nQ) * 정말 함수 하나하나 다 나누었습니다. 단일 책임의 원칙이라고는 하지만.. 너무 많은 책임을 준 건 아닐까 생각이 듭니다. 이런 함수가 있는데요. 장바구니에 아이템을 추가하는 함수인데, 고작 두 줄밖에 되지 않습니다. 이럴 경우 따로 함수로 빼지 말고 그냥 이벤트 함수 안에서 쓰는 게 더 낫지 않을까요? 함수를 잘게잘게 찢어 놓으면 장점이 있을까요? 저는 이 파일, 저 파일 왔다갔다 보는 게 조금 힘들어서.. 코드 길이가 긴 것 아니면 한 곳에 쓰려고 하는데, 이게.. 클린한 게 맞을까 고민이 됩니다.\n\n=> 함수를 잘게 잘게 찢어둔다고만 해서 좋아지지는 않습니다. 적절한 띄어쓰기는 가독성을 높이지만 이 렇 게 하 나 씩 다 떨 어 져 있 다 고 좋 은 구 조 가 되 는 것 은 아 니 잖 아 요? 이 파일 저 파일 왔다갔다 보는게 힘들다는게 좋지 않은 구조를 가지고 있다는 반증이죠.\n\n=> 함수는 기본적으로 요구사항이라는 경계로 분리는 해두어야 합니다. 분리라는건 인간의 개념적 사고와 일치하게 만들어서 인지적 부담을 줄이고자 하는거니까요. \"장바구니 아이템의 숫자를 1로 늘리고 재고를 줄인 다음에 화면을 갱신해\" 라고 말하기 보다는 \"아! 장바구니에 아이템 추가하라는거지?\" 라고 이해하죠. 그런 측면에서 addNewItem(item) 이라는 함수는 필요합니다.\n\n=> 다만 지금의 함수가 좋은 위치 좋은 구조 좋은 방식으로 만들어진게 아니다보니 이게 맞나? 싶은 생각이 들었을거에요. 5주차 과제를 하면서 적절한 좋은 함수와 위치라는건 무엇인가? 하는 것들을 느낄 수 있게 되기를 바래요.\n",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/16"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "윤우님 고생하셨습니다!\n과제가 굉장히 방대했는데, 꼼꼼하게 그리고 시간을 많이 들이신 것 처럼 보이네요. 잘 하셨습니다 ㅎㅎ\n작업을 잘게잘게 나눠 접근하는 방식도 좋았어요 :+1 복잡한 문제나 양이 많은 문제들 특히 지금과 같은 과제들처럼 여러 개선점을 한번에 적용해야 하는 경우에서는 좋은 접근법이였습니다. \n\n추가로 중간 회고에서 '약 main을 400줄로 줄였지만 폴더는 services, modules 등 어떤 개념으로 만들었는지 저조차도 헷갈리는 방향으로 분리가 되어있는걸 보았습니다' 라고 해주셨는데, 결국 AI에게 구체적인 작업 지침을 주지 않으면, 검수를 하는 그 과정 조차도 어려워지더라구요. 가능하면 작업 단위도 주제별로 전달하거나, 그것이 어렵다면 AI에게 계획을 세우고 그 작업의 기준과 지침을 보여달라고 한 다음 확인한 뒤에 작업을 시키면 이런 문제는 줄어들 것 같아요.\n\n그럼 질문 주신 부분 답변 남겨볼게요!\n\n> HTML 관련 로직은 views 로 분리하고 순수함수는 utils, 상태나 렌더링에 관련된건 services로 분리해보려 했는데 약간 역할이 혼재되는 함수들이 있습니다. 예를 들면 카트에 아이템을 넣는 함수면 Services에 존재해야 한다고 생각했는데 새로운 상품을 만드는 부분은 views에 있어야 할 것 같고 이런 역할이 혼재된다고 할때 어떻게든 순수함수를 고려하며 분리해야할까요?\n\n답변은 지금의 레이어 구조를 기준으로만 말해볼게요. 일단 이런 분리는 명확한 규칙이 수립되어야 하는게 기본인 것 같아요. 애매한 부분이 생기면 그 부분에 대한 규칙을 명확하게 만들고 앞으로 작성하는 코드들은 모두 그 위치에 작성하는거죠. 그것만으로도 중간은 가는 것 같아요. \n\n일단 지금의 구조에서 규칙을 만든다면\n* 이 함수가 DOM을 직접 조작하나? → Views\n* 비즈니스 규칙이나 도메인 지식이 필요한가? → Services\n* 순수하게 데이터만 변환하나? → Utils\n* 여러 곳에서 재사용되는가? → Utils (순수함수라면)\n뭐 이런식으로 규칙을 만들어보는거죠. 프로젝트에서는 분리 기준도 중요하지만 일관성이 가장 중요한 것 같아요. \n이런식으로 하다보면 질문 주신 부분에 대해서는 일단 명확해지지 않을까요! 추가로 어떻게든 순수함수를 고려한다기보다는 여러 군데에서 사용할 수 있는 로직들을 재사용성을 높이는 관점에서 역할을 분리한다는 관점에서 순수함수로 분리해야 하기 때문에 어떻게서든지 분리한다 관점으로 접근하지는 않았으면 좋겠어요 ㅎㅎ\n\n> 다른곳에서 재사용이 되지않는 순수함수들도 별도 파일에 분리하는게 좋을까요? 코치님이라면 어떠한 디자인패턴 or 아키텍처를 적용하셨을 것 같나요?\n\n저라면 분리를 안했을 거 같긴한데 이것도 결국 규칙을 만들고 지키기만 하면 되는 문제같아요. 함께 둔다면 사용하는 곳에 가깝게 두는 맥락인거고 분리를 한다면 목적에 맞게 폴더를 구획한다는 관점인거니까요! \n\n지금에 있어서 디자인 패턴이나 아키텍처를 적용한다고 하면 저도 막 엄청 대단한 걸 적용하지는 않았을 것 같아요. 실무 관점이라면 최대한 지금의 구조를 확장성 있게 개선하는 관점, 그리고 제대로 동작하면서 기존 실 서비스에 영향을 주지 않아야 하기 때문에 점진적으로 개선할 수 있는 관점의 아키텍처들을 고민해봤을 것 같아요. 당장 시간이 여유롭지 않다면 윤우님이 작성해주신 패턴을 보면 역할 기반으로 폴더가 나눠지고 단순화 되어있는 구조이기도 하고 서비스 레이어에서 담당하는 일이 많아진 거 같아요. 그러다 보니 비즈니스 로직이나 네트워크 통신, 도메인 규칙 등등이 담기게 될 것 같은데요. 이런 부분을 세분화하고 더 나아가는 형태로 고민해보지 않았을까 싶네요.\n\n> 심화과제에서도 동일하게 utils를 순수함수로 두려고 생각했고 react와 연관이 있다면 컴포넌트 내부 혹은 hooks에 두고 컨트롤하려고 했습니다. priceUtils에 renderPriceWithDiscountStyle 함수는 성질이 컴포넌트에 조금 더 가깝다고 느껴지는데 현재 utils 함수에 두는게 맞을까요?\n\n요것도 위에 작성한 것처럼 규칙을 만들고 그대로 지키면 되지 않을까요! ㅎㅎ\n\n> 클린코드에서 지향하는 방향성이나 지침들이 분명히 있지만 저는 판단이 주관적인 부분도 많이 들어가게 되는 것 같습니다. 이렇게 리팩토링을 진행하며 명확하게 판단이 서지 않을 때 어떤 기준으로 코드의 방향성을 정하시나요?\n\n맞아요. 사실 선배들이 말하는 '이렇게 코드를 짜면 이런 장점이 있다'가 있는 것이지 절대적인 법칙에 해당되는 내용이 아니니까 그런것 같아요. 대신 그 선배들이 말하는 기준들을 왜 그렇게 하라고 했는지 읽어보고 공감하는 내용이 있다면 (또는, 지키는데 크게 어렵지도 않고 노력대비 쉽게 얻을 수 있는 효과도 있고) 그걸 명확하게 해나가면 나만의 클린 코드 규칙이 되지 않을까 싶어요.  (대신 대다수가 싫어하는 규칙이 있으니 그런 부분들이 공감이 안된다고 팀 내에서 고집을 부리면 안되겠죠 ㅎㅎㅎ )\n\n> 비대한 함수에서 (handleCalculateCartStuff) 개선을 시작할 때 이 부분은 순수함수로 빼고 이 부분은 ~~로 처리하고 같은 판단이 잘 서지않는건 클린코드에 대한 아티클이나 레퍼런스같은걸 모르는걸까요? 명령형으로 작성된 코드를 파악해서 기능의 돌아가는 원리는 파악이 되지만 이건 순수함수로 개선이 가능하다! 같은 판단이 어렵습니다..\n\n음 일단 클린코드 책에서 말하기에는 함수는 한 가지 책임만 져야 한다. 의존성을 최소로 져야 한다. 사이드 이펙트를 최소화 해야한다 이런 관점으로 많이 이야기가 될 텐데요. 고민이 된다면 함수에서 몇 가지 역할을 하고 있는지 고민을 해보고 그 역할별로 함수를 나누는게 첫번째 기준일 것 같고 아니면, 해당 부분에 있어서 (함수로 분리가 고민되는 부분에 있어서) 항상 같은 입출력을 내는 부분이 있는가? 외부와 상호작용이 있나? 사이드 이펙트가 발생하지는 않을까? 이런 부분들에 대해 질문을 해보고 항상 같은 입출력을 낸다. 사이드 이펙트 없다. 이런 부분들에 대해서 순수함수로 분리할 수 있을 것 같아요!\n\n이번 주도 고생하셨고 많은 고민하셨던 만큼 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/15"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "윤영서",
    "feedback": "안녕하세요 영서님~ 4주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다.\n이것저것 같이 병행하는게 많아서 쉽지 않았을텐데... 존경합니다.\n\n---\n\nAI 사용 과정에 대한 내용이 재밌네요 ㅋㅋ\n이게 제가 이상한건진 모르겠는데, AI가 다 해줄꺼야! 라는 기대 자체를 별로 안 하고 있다보니.. 어차피 내가 해야돼~ 라고 생각하면 마음이 편안해진답니다.\n\n내가 더 잘 할 수 있는 부분과 AI가 더 잘 할 수 있는 부분을 구분해서 작성하는거죠 ㅎㅎ\n\n그리고 처음부터 Cursor를 채찍질하기보단 ChatGPT 같은 조금 하찮은(?) 녀석에게 명령을 어떻게 하면 잘 동작할까 고민하다보면 Cursor나 Claude 같은 고급 인력을 더 잘 사용할 수 있답니다!\n\n---\n\n과제에 대한 특별한 질문은 없어서 여기서 마무리할게요!\n\n다만, basic에 있는 코드를 advanced에서 잘 활용했는가!? 에 대해 살펴보면 아쉬운 부분이 많이 있어요. service 파일이 몇 개 사라졌다거나... 함수가 그대로 쓰이는게 없다거나... 그렇네요.\n\n아예 basic과 advanced가 코드를 공유하도록 만들었으면 어땠을까 라는 생각도 들어요. advanced가 basic의 코드를 그대로 가져다 사용하는거죠 ㅎㅎ\n\n여튼 고생했어요! 다음주도 화이팅!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/6"
    }
  },
  {
    "passed": true,
    "name": "이가은",
    "feedback": "안녕하세요 가은님! 4주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 멘토링 때 답변 못받고 넘어간 부분인데, 코치님이 리팩토링을 진행하신다면 어떤 절차대로 진행하실지 궁금합니다!\n\nAI를 활용한다면.. 아마 이런 질의를 통해 진행할 것 같아요!\n\n1. 현재 테스트 코드와 구현된 코드를 토대로 실제 이 어플리케이션의 요구사항과 엣지케이스를 추출해줘.\n2. 먼저 현재 코드에서 UI에 대한 부분과 비즈니스(도메인)에 대한 부분을 점진적으로 분리하고 싶어. 어떤 단계로 진행하면 좋을지 알려줄 수 있을까?\n3. 계획을 잘 세워줬네! 여기서 내가 하면 더 효과적인 부분과 너를 사용하면 더 효과적인 부분을 구분해줄 수 있을까?\n4. 잘 구분해줬네! 이제 우리가 서로 협업하면서 진행을 해보자.\n\n~~~ 쭊쭊 진행\n\n5. 어느정도 정리가 된 것 같아. 여태까지 진행한 내용을 문서로 만들어줄 수 있을까?\n(문서화 진행)\n\n그 다음 이제 새로운 채팅을 하나 만들어주세요.\n1. 여태까지 내가 작업한 내용이 XXX.md 에 기록되어있어. 이제 다음 단계를 진행할 차례야. 요구사항/엣지케이스/테스트코드/JS 등을 기반으로 react로 구성하고 싶어. 이 때 재활용할 수 있는 코드가 얼마나 있을까?\n2. 그렇다면 재활용할 수 있는 형태가 최대한 많았으면 좋겠어. 이를 토대로 현재 코드를 리팩토링 하고 싶어. 어떤 코드부터 정리하면 좋을지 알려줄 수 있을까? 작업은 내가 해볼게\n3.. 현재까지 진행한 내용을 문서로 정리해줘.\n\n다시 새로운 채팅을 만든 후에\n1. 여태까지 내가 작업한 내용이 XXXX.md 파일에 있어. 이제 작업을 이어서 해야 돼. 리액트로 코드를 구성해줄 수 있을까? 특히 엣지케이스를 꼼꼼하게 채워주면 좋겠어. 무엇보다 기존 코드를 최대한 재활용하는 방식이어야해!\n2. 여태까지 작성된 코드에 대한 단위테스트를 만들고 싶어. UI보단 hook과 function 위주로 테스트를 만들어주고, 엣지케이스가 최대한 많으면 좋겠어.\n\n...\n\n아마 요로코롬 진행했을 것 같아요 ㅎㅎ\n\n> AI를 적극적으로 활용하는건 너무 좋았는데, 열심히 쓰다보니 이게 맞나..? 해당 주차에서 내가 얻어가는게 뭐가 있을까, AI활용성 고민과 AI로의 문제해결 밖에 안남은 것 같은데 만약 복기하게 된다면 어떻게 복기하면 좋을지 고민입니다.\n\n이번 과제의 핵심이 저는 리팩토링이라고 생각해요. 이걸 AI의 도움을 받아서 해결하는거죠. 그렇다면 리팩토링에서 제일 중요한게 뭘까!? 에 대한 질문을 해보시면 좋아요.\n\n가령, 내가 리팩토링을 통해 달성하고자 하는 목표가 무엇인지.\n어떤 구조가 되길 원하는지\n어떤 요구사항을 잘 수용할 수 있는지\n어떤 요구사항에 대해서는 수용하기가 어려운지\n그렇다면 어떻게 또 코드가 구성이 되어있어야 요구사항을 수용하기가 쉬운지\n\n이런 지점들이랍니다!\n\n이러한 목표를 달성하기 위해 AI에게 어떻게 질의하고 기록해야 매끄럽게 흘러갈 수 있을지 고민해보시면 좋아요!\n",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/36"
    }
  },
  {
    "passed": true,
    "name": "이민재",
    "feedback": "수고했습니다! 이번 과제는 더티코드를 클린코드로 점진적으로 개선하면서 리팩토링의 진정한 어려움과 가치를 체감하는 것이 목표였습니다! 커밋을 보아하니 점진적을 지키기 위해 단계적으로 잘 접근했다 느껴집니다.\n\n\"나름 일련의 구조화를 거쳐 세부적인 수정까지 차례차례 클린코드로 변경하고자 했습니다.\" 아주 좋은 접근입니다. 이러한 체계가 몸에 베이게 되면 처음부터 좋은 코드를 잘 작성하게 되죠. \"매직 넘버 상수화 → var를 let/const로 변경 → 함수 분리 → 컴포넌트 분리 → UI와 상태로직 분리\"등의 순서를 지켜 진행하신 접근 좋았습니다. 한번에 크게 바꾸려는게 아니라 바꿔도 영향력이 적은 것들 부터 수정할 수 있는 순서대로 진행하는것이 좋은 방법이지요.\n\n\"그러나, 워낙 더러운(?) 탓에.. ai 조차도 계속 삽질을 하더라구요 하핫\" ㅋㅋ 다행입니다. 이러한 경험을 통해 AI를 언제 어떻게 활용할지 내가 해줘야 하는 것과 위임에도 되겠다 싶은 것들에 대해서 느껴보기를 바랬어요.\n\n팀원들에게 도움을 받았다고 하시는데, 사실 그런 협업 자체가 정말 소중한 경험이에요. 컨벤션을 정하고 cursor agent를 적용해보고 프롬프트 방식을 배우는 것들 모두가 현업에서도 중요한 스킬이거든요. 혼자서는 절대 얻을 수 없는 관점들을 동료들과 나누면서 성장하는 것 자체가 큰 가치라고 생각합니다.\n\n아쉬웠던 부분으로 언급하신 것들 - spread operator 활용, 고차함수 적용, 테스트 처리 - 이런 것들은 5주차 과제에서 충분히 적용해볼 수 있는 내용들이에요. 컨디션 관리도 개발자에게는 정말 중요한 부분이죠. 우리는 머리와 몸으로 먹고 사는 만큼 체력관리도 개발자에게 중요한 스킬이에요. 머리의 말보다는 몸의 말(느낌, 자극, 쎄함)을 잘 들어가면서 억지다 싶으면 내려놓고 푹 쉬는게 낫습니다. 되겠다 싶을때 짬짬히 해도 되니까 그런 방법도 이번 항해를 하면서 방법을 찾아가봐요 :)\n\n수고하셨습니다. 5주차 과제도 화이팅입니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/32"
    }
  },
  {
    "passed": true,
    "name": "이유진",
    "feedback": "\"...왜 이렇게 어려웠을까를 지금와서 생각해보니, 우선 여전히 바닐라 자바스크립트로 DOM을 직접 다루는건 너무 어렵습니다.\" 맞습니다. 사실 유진이 뿐만 아니라 모든 웹 개발자들이 같은 생각을 했습니다. DOM API는 너무 어렵고 후지다고요. 그래서 처음에 만들어진게 jQuery였습니다. 적어도 j\bQuery는 DOM을 다루는 방식에 있어서 매우 간결하고 수준높은 표현력을 보여줬거든요.\n\n\"...뭔가 DOM 조작을 하고 있는 것 같은데 그 흐름을 찾기가 어려웠습니다.\" 그렇죠. 역시 DOM 조작은 DOM 조작 그 자체에서 한계를 느꼈습니다. 우리의 사고흐름은 HTML을 그리고 동작을 하면 HTML이 변경이 되는 건데 그 중간 과정을 사고해서 변경해야한다는건 어려운 개념이었죠.\n\n그러면서 React와 같이 html과 유사한 개념을 작성하고 수정할 수 있는 개념으로 확장이 되었습니다. 이번에 리액트스럽게 사고해보라고 한건 지난 js개발 패러다임의 변화 역사들을 이해할 수 있기를 바랬어요.\n\n\"basic 과제는 그래도 AI를 최대한 덜 사용하려고 노력했고, 고치면서도 이렇게 리팩토링하는게 맞나? 하는 생각을 수없이 했는데요, 그 과정이 힘들었지만 재밌기도 했습니다.\" 아주 아주 잘했습니다. 이렇게 하는 맞나? 라는 고민 그 자체를 반복하는게 곧 성장이죠. 이게 정답이야 라고 알려주고 작성하는건 수학 문제를 답지를 보고 베껴쓰는것 밖에 안되요. 물론 그것도 학습이 되겠지만 내가 정말로 고민해보고 머리를 써보는 것만큼일수가 없죠. 학습을 하는 과정에서는 결과의 속도보다 과정의 질이 더 중요하다 생각합니다. (그렇지만 과제의 시간이 부족한 부분에 대해서는 미안해요 ^^;)\n\n\"그래도 심화과제를 진행하면서 리액트로 코드를 짜다 보니 제가 기본 과제 수행 중 어느 부분을 잘못 설계했고, 덜 쪼갰는지 등등을 알 수 있었습니다.\" 맞아요. 아마 리액트를 사용하면서 이게 왜 이렇게 만들어졌을까? 라는 생각은 많이 해보지 않았을거에요. 그런데 그 과정을 한번 접하고 나니 리액트가 조금 달리 보이지 않나요? 원리를 이해하게 되면 뭔가 더 선명해지는 그런 안경을 쓴 기분이 들거에요!\n\n\"헤매는 시간도 많았고, 심화과제로 리액트로 바꿔보기도 했고, 솔루션 코드도 본 지금은 그래도 조금 더 감이 오는 것 같습니다.\" 좋습니다. 앞으로 더 많은 코드를 만나게 될거고 솔직히 DOM으로 개발하는 코드를 만나게 되는 경우는 거의 없을 거에요. 이 개념적 원리를 이해하는 접근법을 이해했다면 이러한 방식으로 앞으로 코드를 만날 때 \"이건 왜 이렇게 만드려고 했을까?\" 라는 점들을 의식해서 생각해보면 훨씬 더 빨리 익힐 수 있을거에요.\n\nQ) DOM API 대신 리액트 컴포넌트처럼 html을 반환하라는 함수를 만들라고 하셨던게 이런 방식이 맞을까요...? 리액트로 바꾸려다 보니까 그대로 못쓰고 직접 div 태그 만들고 className 붙여야 하던데... 제가 잘 이해하지 못한건지 궁금함니다..!\n\n=> 잘했습니다. outerHTML을 쓸 수 도 있고 template을 이용해서 full html을 반환하거나 string만 반화하고 리렌더링시 html을 활용하거나 할 수도 있겠지만 어차피 패러다임이 넘어간 이상 어떻게든 크게 상관없었답니다. 과제의 취지는 바닐라스크립트를 잘 하는 건 아니었으니까요. \n\n수고하셨습니다. 5주차 과제도 화이팅입니다",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/53"
    }
  },
  {
    "passed": true,
    "name": "이은지",
    "feedback": "수고했어요, 은지! 이번 과제는 레거시 코드를 React 기반의 현대적인 아키텍처로 고도화하는 것이 목표였어요. 바쁜 일정 속에서도 기본 과제는 AI 활용, 심화 과제는 직접 설계로 명확히 구분해서 접근한 전략이 정말 효율적이었습니다. 커밋 과정에 아주 촘촘하게 개선한 과정이 인상깊네요.\n\nZustnad 도입부터 관심사 분리, 특히 할인정책등을 고민하면서 확장 가능한 구조를 만들기 위해 많은 고민을 하면서 이러한 구조를 만든 부분 아주 좋습니다.\n\n복잡한 할인, 적립 정책에 대해서 보다 좋은 데이터 구조를 설계하고 만들고 싶은 부분에 꽃혀서 고민이 정말 많았었군요. 이 과정에서도 AI와 함께 많은 고민들을 나눠본것 같아요. 아주 좋네요. 앞으로도 뭔가 해보고 싶은게 생겼을 때 고민 파트너 대화 파트너로써 AI를 충분히 활용해보면 좋겠다 생각을 합니다.\n\n---\n\nQ) 확장성, 유지보수성을 고려하여 설계한 현재 할인 정책 관련 데이터 타입과 유틸의 구조가 적절한지 궁금합니다.\n\n좋은 고민입니다. 이번 과제는 리팩토링이고 리팩토링의 목표는 최대한 기존의 코드를 유지하면서 나은 구조를 만드는 것이죠. 지금 고민하는건 재설계에 가까운 고민이라고 생각하는데 함께 생각을 해보도록 하죠.\n\n현재의 구조는 PointPolicy enum을 통해 모든 정책을 관리하면서 text, 포인트 계산등의 함수로 만드는 방식으로 분리한 점입니다. 우선 어떤 정책들이 있는지 한눈에 볼 수 있고 배열을 통해서 순차적으로 조립할 수 있도록 만든 부분은 좋았습니다.\n\n반면 지금의 새로운 정책을 추가하거나 삭제를 할때마다 enum, calculator, text 등 여러 곳을 동시에 수정해야 하는 문제가 있네요. 삭제를 해야할 때 한번에 말끔하게 삭제 되는 구조가 아니라면 응집도를 높다고 말하기는 어려워요. 지금의 구조에서 조금만 더 낫게 고쳐본다면 다음과 같이 정책 자체를 하나로 묶어 버리는게 좋다고 생각합니다.\n\njavascript\nconst POINT_POLICIES = {\n  tuesday: {\n    id: 'tuesday',\n    name: '화요일 2배',\n    calculator: (originalPoint) => originalPoint * POINT_MULTIPLIER_TUESDAY,\n    condition: () => new Date().getDay() === 2\n  },\n  keyboardSet: {\n    id: 'keyboard-set', \n    name: `키보드+마우스 세트 +${POINT_BONUS_KEYBOARD_MOUSE_SET}p`,\n    calculator: (originalPoint) => originalPoint + POINT_BONUS_KEYBOARD_MOUSE_SET,\n    condition: (cartItems) => hasKeyboardAndMouse(cartItems)\n  }\n};\n\nQ) 같은 맥락으로, 실제 이커머스 도메인에서는 복잡한 할인, 포인트, 쿠폰 등의 정책을 어떻게 관리하고 반영하는지 궁금합니다.\n\n사실 필요한만큼만 개발을 한다는 전제대로 지금 정도의 수준이라면 복잡한 설계보다는 위와 같이 적절한 객체나 클래스 정도의 수준으로도 충분합니다. 그러나 소스 코드의 수정으로 정책을 변경할 수 있다라는 것은 정책이 바뀔때마다 소스 코드 배포가 필요하다는 말이기에 해당 기능들은 전부 데이터화 되죠.\n\n그렇게 정책을 다루는 코드들이 데이터 베이스화 되고 API등에서 해당 정책들을 모아서 하나의 계산으로 만들어내는 Rule이나 계산식을 만들어주는 코드가 되죠. 나중에는 우선순위라던가 더 큰 상위정책등 - 가령 더 할인율이 큰거 하나만 적용과 같은 - 도 코드화됩니다. 이런한 경우 모바일, 웹 등의 일원화를 위해서 주로 백엔드가 해당 기능들을 구현하게 되죠.\n\n규모와 수준에 따라 달라지고 정책마다 달라지기에 정해진 답은 없는데 도움이 되는 답변이길 바래요.\n\n수고하셨습니다. 다음 주차도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/55"
    }
  },
  {
    "passed": true,
    "name": "이의찬",
    "feedback": "수고하셨습니다. AI를 활용하겠다고 마음을 먹으니 AI를 더 잘 쓰기 위한 방법들을 찾아가게 되는 군요. 좋습니다. 개발자란 무릇 해결해야할 문제들을 찾아내고 해결하는 방법을 찾는 사람들이니 이러한 접근도 좋다고 생각합니다. \n\n\"...제가 할 일은 AI한테 일을 어떻게 해야할지 생각하고, 그에 따라서 진행하라는 명령 뿐이였습니다.\" 라는 말에서 한번 생각해보면 \"일을 어떻게 해야할지\"가 앞으로는 더 중요해지는 과제가 될거라고 생각해요. 그리고 어떻게 하는지를 제대로 하는지를 감시한다거나 혹은 어떻게 할지는 AI가 더 잘 수행할 수 있도록 하는 방법을 고민하는게 개발자의 역할이 될거라 생각하네요.\n\n어쩄든 \"...React로 마이그레이션해줘\" 라고 그냥 요청만 한다고 내가 원하는걸 AI가 무슨 수로 알고 그걸 수행해낼까요? 그리고 아직 AI는 내가 원하는 것들을 알아내기 위해서 평소에 생각을 나누거나 물어보거나 하지 않고 일단 자기가 자주 학습한대로 그저 해버리는 도구이니까요.\n\nAI를 사용하지 않고 혼자서 가보는 경험도 필요하다고 생각합니다. 내가 한번 해봤던 것을 그대로 재현시키는 걸 AI를 통해서 진행하는 건 좋은 도구의 활용이지만 한번도 가지 않은 길을 내가 가보면서 학습하고 경험하는걸 AI에게 시키는건 아까운 일이지요. 어떤 성찰이 있을지 블로그 길 기대할게요.\n\n앞으로도 AI에게 지시를 구체적으로 하기 위해서 알아야 하는 지식과 그 표현력은 점점 더 중요해질거라고 생각합니다. 기술적인 부분을 언젠가 AI가 뛰어넘을 수도 있겠지만 무엇을 해야하는지를 현재 맥락에 맞춰서 지시하는건 여전히 사람의 몫이자 능력일거라고 생각해요.\n\n변해가는 시대안에서 함께 항해를 하는 동안 의찬이만의 멋진 철학과 경험, 통찰등이 생겨나기를 응원합니다. 수고하셨습니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/37"
    }
  },
  {
    "passed": false,
    "name": "이정우",
    "feedback": "안녕하세요 정우님!\n4주차 과제 잘 진행해주셨네요 ㅎㅎ \n다만 심화과제까지 할 시간적 여유가 부족했나보네요 ㅠㅠ\n\n일단 현재 진행된 모습을 보니 클린 아키텍쳐로 구성해주신 것 같아요!\n이렇게 구성했을 때의 장단점을 정우님께서 기록해주시면 어땠을까 싶네요..!\n\n저의 개인적인 시야로 봤을 때 infra와 domain은 구분이 되어 있으나, infra의 코드가 외부 의존을 하는게 아니라 domain만 의존하고 있어서 사실 없어도 되는 레이어 아닌가!? 라는 생각이 들어요 ㅎㅎ\n\n특별한 질문은 없어서 여기서 마무리하도록 하겠씁니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/54"
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "\"과제 코드를 보자마자 너무 놀라 까무라쳤습니다. 정말 더러운 코드라고 걱정해줬던 테오가 바로 생각 나더라구요.\" 오예!!ㅋㅋ 뿌듯하네요\n\n\"그렇기 때문에 '어쩌면 내 코드가 누군가에게는 이렇게 더러운 코드이지 않을까?' 라는 산뜻한 마음으로 과제를 시작했습니다.\" 멋진 인사이트입니다. 과제의 목적이 나쁜 코드가 왜 나쁜가를 이해해보는 것인 만큼 훌륭한 많은 걸 느꼈길 바랍니다.\n\n\"또한, 1챕터에서 배웠던 내용을 가져와 AI에 지시하여 리팩토링을 진행했습니다.\" 이런 관점도 흥미롭네요. Q&A때 방향성을 알려주지 않고 여러가지를 고민할 수 있도록 해야하나 싶었는데 SPA의 방향성에 대해서도 진행본게 참 좋네요.\n\n\"테스트 코드의 중요성을 체감했습니다\" 그렇죠? 테스트 코드가 없이 이걸 수정한다고 했을때 특히나 내가 하는게 아니라 AI와 함께 할거라고 생각하면 아찔합니다. 안전장치 없이 운전하는 느낌이랄까요? 이러한 느낌을 바탕으로 이번 클린코드가 끝나고 하게 될 테스트 코드 파트에 대해서도 좋은 경험을 할 수 있게 되기를 바래요\n\n\"항상 리액트에서만 코드를 작성하고 폴더구조를 고민하다보니 바닐라 자바스크립트에서의 좋은 폴더구조는 무엇인지 감이 오지않았습니다. .. 팀컨벤션 기준으로 네이밍을 지정하였으며, 익숙한 구조로 정리했습니다.\" 사실 좋은 구조가 바닐라 다르고 React 다르고 그러지는 않습니다. 폴더 구조에 대한 고민은 6주차에 해보게 될텐데 한번 같이 생각해보기로 해요\n\nQ) 테오라면 이 과제의 리팩토링에서 제일 중점적으로 볼 것 같은 요소가 있을까요?\n\n저에게 있어 제일 중요한 기준은 점진적 개선입니다. 테스트 코드라는 안전장치가 있다고 해도 한번에 과도한 리팩토링을 하는 건 함께 일하는 동료에게도 좋지 않습니다. 구조가 한번에 너무 많이 갑자기 바뀌어버리게 하면 그걸 적응하기 위해서 인지적 노력을 써야 하니까요.\n\n현업에서도 문제가 없을거라는 확신내에서 코드를 수정하고 위치를 변경하고 조금씩 조금씩 바꿔가는 습관등이 필요합니다. 그렇기에 리팩토링을 몰아서 하는게 아니라 가능할때 조금씩 점진적으로 하는 습관을 가질 수 있게 되기를 바랬어요.\n\n두 번째는 코드 리뷰 및 페어 프로그래밍입니다. 사실 다양한 방식으로 리팩토링 하도록 하고 각자가 생각하는 좋은 코드의 방향성을 논의하면서 자신만의 철학등을 정립해보는 시간을 가져보기를 바랬어요. 지금은 개념적으로 상당히 정립이 많이 되었고 특히 AI의 등장으로 어느정도의 표준이 만들어진 상태다 보니 되려 각자의 개성적인 철학을 탐구하기 보다는 표준을 따라가는 식으로 학습이 되어버린것 같아 개인적인 아쉬움이 있네요.\n\n앞으로 5주차 6주차에서도 클린코드와 리팩토링 함께 하면서 많은 것을 느낄 수 있는 시간이 되기를 바랍니다. 수고하셨습니다.\n",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/48"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이지훈",
    "feedback": "안녕하세요 지훈님!\n\n> AI 를 적극 활용해 보면서 느낀 점은 AI 에게 명확하게 지시를 내릴 수 있어야 한다는 점이다. 클린코드에서도 클린코드를 만들기 위한 나의 기준이 없다면 AI 를 아무리 활용해도 마음에 드는 결과물을 얻는 것은 매우 어려울 것 이다.\n\n굉장히 중요한 인사이트네요 ㅎㅎ 전적으로 동의합니다!\n\n> 결국 AI 가 작성한 대부분의 코드를 들어내고 직접 코드를 작성하는데 시간을 많이 사용했다. 직접 코드를 작성하면서 느낀 점은 코드를 작성하는 나만의 기준이 없다는 점이다. 폴더와 파일은 어떻게 나눌지, 함수명은 어떻게 지을지, 함수 인자는 객체 형태로만 받을지, 리턴은 어떤 형태로? 이런 것들에 기준이 없다보니 코드를 작성하면서 일관성을 지키기 어려웠다. 이번 챕터를 진행하면서 나만의 컨벤션을 만들어 보는 것도 의미가 있을 것 같다.\n\n맞아요 ㅋㅋ 그리고 컨벤션을 만들어서 eslint로 만들어 배포해서 적용하는 방식도 재밌을 것 같아요!\n\n> 코치님은 어떤 컨벤션을 가지고 코드를 작성하시는지 궁금합니다.\n\n이전에 지수님께서 제가 이전에 공유드렸던 저희 팀의 컨벤션을 아고라에 올려주셨답니다!\n\nhttps://discord.com/channels/1288769861589270590/1391291029226786816/1395759483149488274\n\n중요한건 여기있는 규칙 하나하나를 팀원들과 합의했다는 점이고, 그렇기 때문에 잘 지켜갈 수 있는 규칙이라고 생각해요..!\n\n> 린트는 어떤 옵션을 사용하시는지 궁금합니다.\n\n흠... 너무 많아서 어디서부터 어디까지 설명드려야 좋을지...\n일단 airbnb rule을 상속하여 팀 컨벤션에 맞게 수정해서 사용하고 있어요.\n거의 컨벤션과 정렬이 되어있답니다 ㅎㅎ\n\n",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/5"
    }
  },
  {
    "passed": true,
    "name": "이진희",
    "feedback": "진희님 고생하셨습니다~\n과제 전반적으로 많은 고민하시고 잘 적용해주신 것 같은데요!\n아쉬운점에서 남겨주신것처럼 이번 큰 규모의 리팩토링을 진행할때에는 명확한 기준 또는 규칙없이 진행이 되다보면 시간이 많이 들게 되는것 대비 명확한 개선을 이뤄내는게 참 어려운 것 같아요. 다음 과제를 진행하실 때는 이런 부분들에 대해서 작업들을 명확하게 작게 작게 나누고 피드백을 거치면서 진행해가시면 더 좋을 것 같습니다.\n\n그럼 이어서 질문 주신거 답변 드려볼게요!\n\n> 이런 식의 폴더 구조/레이어링 방식이 괜찮은 접근인지, 혹은 불필요하게 복잡도를 높이는 구조인지 궁금합니다.\n\n좋은 접근인 것 같아요. 다만 말씀주신 것 처럼 프로젝트 규모에 맞게 잘못된 또는 너무 복잡한 아키텍처를 선택하는건 복잡성만 높이는 안좋은 선택일 수 있어요. 폴더가 텅텅 빈 채로 유지가 될수도 있겠죠. 지금은 과제를 진행하는 부분이기 때문에 여러 방식으로 구현해보는것도 방법일 수 있겠지만, 실무였다면 현재 시점에서(또는 예측가능한 시점까지 고려해서) 가장 효율적인 작은 방식으로 운영을 하면서 점진적으로 개선하는게 좋지 않을까 싶습니다.\n\n> 도메인 레이어에 getProductById 같은 유틸 함수가 들어가는 구조도 괜찮은지 궁급합니다.\n\n넵 적절합니다! 좋은 접근이에요. \n\n> controller 레이어의 역할을 따로 두는 게 실제로 클린한 구조인지\n\n이 부분에 대한 답변도 처음과 같아요. 컨트롤러 레이어가 생기면 결국 뷰랑 비즈니스로직을 명확하게 구분할 수 있게 되는데 작은 규모의 프로젝트에서는 불필요하게 느껴질 수 있겠죠. 명확하게 구분이 필요할 때 도입하면 충분할 것 같아요. 대신 일관되게 작성하면 될 것 같습니다 ㅎㅎ\n\n> 추가 질문\n\n좋은 접근인데요. 이미 알고 계시는 것 처럼 블록별로 분리를 하게 되면 해당 로직에 대해서만 컴포넌트에서 관리할 수 있기 때문에 이상적인 상황이면 좋을 것 같아요. 다만, 아시겠지만 해당 데이터를 최종적으로 수집해서 전송해줘야 하는 케이스들이 있고 한 필드의 값이 다른 필드에 영향을 줘야 하는 케이스가 생긴다면 결국 이상태를 어디에 둘 것인가에 대한 고민은 동일할 것 같아요. 이런 문제들을 쉽게 다루기 위해서 RHF같은 라이브러리들을 쓰는 것 같은데요. 개인적으로 이런 상황에 적용한다면 개선이 크게 느껴질 것 같아서 고민해보셔도 좋을 것 같아요.\n\n이번 주도 고민하셨고 남은 과제도 화이팅입니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/34"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "이태영님, 정말 수고하셨습니다! 이번 과제는 더티코드를 클린코드로 개선하면서 React/TypeScript 기반의 현대적 아키텍처로 전환하는 것이 목표였어요. 회고를 읽어보니 과제의 핵심을 정확히 파악하고 정말 체계적으로 접근하셨네요.\n\n\"제가 이번 과제를 하면서 느낀 부분은 더티코드로 작성 된 부분 중 눈에 띄는 아니 그냥 제일 문제는\" 으로 시작되는 구절이 인상깊네요. \"비즈니스 로직과 UI 코드가 뒤섞여 있음\", \"함수/컴포넌트의 책임 불분명\" 등 왜 소프트웨어 공학에서 말하는 좋은 코드의 원칙과 개념적인 학습 등에서 이런 것들을 분리하고 구조화를 하라는지 확실히 느낀 것 같아서 좋습니다.\n\n이번 과제를 통해 리팩토링의 진정한 어려움과 가치를 몸소 체험하셨을 거예요. 특히 \"점진적 개선\"의 중요성을 실감하셨을 텐데, 이런 경험이 쌓여서 나중에는 더 큰 규모의 코드베이스에서도 안전하고 효과적으로 개선 작업을 할 수 있는 감각이 생길 거예요.\n\n---\n\nQ) 어떤 수준까지 AI를 활용하는 것이 \"건강한 학습\"이라고 생각하시나요?\n\nAI 활용에 대한 성찰 부분도 정말 깊이 있는 고민이었습니다. 노마드코더 영상을 보고 \"학습이 결코 편안해서는 안 된다\"는 깨달음을 얻으신 것, 그리고 \"어떻게 활용해야 나 자신도 성장하며 효율적으로 성장할 수 있을까?\"라는 질문을 던지신 것이 정말 중요한 인사이트라고 생각해요.\n\n우리는 개발자로써 문제를 해결하고 결과를 만들어 내야 하죠. 이 때에는 혼자서 코드를 생각하고 만들어내는 것보다 라이브러리를 쓰고 필요한 코드를 구글에서 찾아서 어쩄든 문제를 해결하고 결과를 만들어내는게 잘 하는 개발자입니다. AI도 개발자에게는 새로운 도구이며 이를 잘 활용해서 결과를 만들어내는 건 개발자로써 중요한 소양이지요.\n\n그런데 학습이라는 측면에서는 조금 다릅니다. 왜 이게 나쁜 해결책 인지 좋은 해결책인지 여러가지 시행착오를 하는 과정에서 배우고 느낄 수 있죠. 그리고 스스로 생각하는 힘을 통해서 처음에는 어렵지만 점점 익숙해지면서 다양한 문제들을 만난 경험들이 새로운 문제를 만났을 때 해결하는 힘과 끈기를 만들어준다고 생각합니다.\n\n건강한 AI 활용은 내가 목표를 설정하고 방향을 제시하되, 구체적인 구현 작업에서 도움을 받는 정도라고 생각해요. 예를 들어 \"이 함수를 순수함수로 만들어줘\", \"이 컴포넌트에서 비즈니스 로직을 분리해줘\"처럼 내가 원하는 바를 명확히 알고 있을 때 AI를 활용하는 거죠. 이때는 AI를 해결의 도구로 활용하고 있는걸 꺼에요.\n\n반대로 \"어떻게 해야 할지 모르겠으니 알아서 해줘\"는 어떨까요? 이렇게 해서 문제를 해결하는건 도움이 되지 않습니다. 내가 생각한 바가 있는게 아니니까요. 그렇지만 힌트는 되어줄거라 생각합니다. 왜 이 방식이 좋은 방식인지 혹은 다른 방식도 생각해볼 수 가 있을지 그렇게 고민을 하면서 내것으로 만든 뒤에는 학습이 되었다고 생각합니다. 사실 이러한 방식은 기존에 구글링이나 스택 오버 플로우를 통해서 문제 해결 뒤 학습까지 이어지는것과 다름 없죠.\n\n뇌는 너무 편하면 그걸 의미있게 생각하지는 않는다고 해요. 고생을 한다는 얘기는 에너지가 필요로 한다는 뜻이고 이걸 더 편하게하기 위한 방법을 찾는 거죠. 그리고 편해졌다는 얘기는 더 이상 신경 쓰지 않아도 된다는 의미라고 생각해요. AI를 통해서도 얼마든지 고민하고 물어보고 학습을 할 수 있다고 생각합니다. 모르는 일을 대신 해주는 존재가 아니라 내가 원하는 걸 하기 위해서 혹은 학습하기 위해서 충분히 에너지를 들인다면 내 것이 된다고 생각해요.\n\n책을 읽을때 마음에 드는 구절을 필사를 하면서 몸에 새기는 것 처럼 AI와 함께 하더라도 괜찮은 코드들은 내가 따라 쳐보기도 하고 AI없이 다시 만들어 보기도 하고, 그렇지 않고 컨트롤 C+V를 하더라도 의식적으로 충분히 학습할 수 있다고 생각해요. \n\n수고하셨습니다. 5주차도 화이팅입니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/24"
    }
  },
  {
    "passed": false,
    "name": "임규원",
    "feedback": "규원님 코드는 작성해주신 것 같은데 테스트가 깨져있고 MR의 체크박스도 체크가 확인이 안되네요~ 제가 지금 채점하는 시점에는 그런상황입니다.\n시간이 충분하지 못했던 것 같습니다 ㅜㅜ\n그래도 일부 코드 작성하시느라 수고많으셨습니다. 솔루션 코드 나오면 확인하는 시간을 가지시면 좋을 것 같습니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/26"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "임두현",
    "feedback": "\n아니 두현님..\nMR 회고내용이 너무 좋네요!\n와 9팀은 정말 인재들이 많네요 ㅎㅎ\n \n내용중에 객체 맵을 활용한 전략패턴 비스무리한 코드는 정말 특 참 좋은 전략이라고 생각해요. \n복잡한 if-else를 먼저 고려하기전에 비교 조건이 단순화 가능하다면 객체 맵을 활용하는 형태가 자바스크립트 다운 선택이라고 생각합니다.\n성능을 떠나서 코드 자체가 확줄고 가독성이 확 올라가거든요 :)\n\n수고많으셨습니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/27"
    }
  },
  {
    "passed": false,
    "name": "장루빈",
    "feedback": "안녕하세요 루빈님!\n4주차 과제 잘 진행해주셨네요 ㅎㅎ \n다만 심화과제까지 할 시간적 여유가 부족했나보네요 ㅠㅠ\n\nUI, Event, Data 등으로 레이어를 구분해주신 것 같아요!\n좋은 시도라고 생각합니다 ㅎㅎ\n여기에서 아예 react에서 재활용할 수 있는 부분만 AI에게 문의하여 진행해도 좋았을 것 같아요..!\n\n특별한 질문은 없어서 피드백은 여기서 마무리하도록 하겠습니다. 고생하셨스빈다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/59"
    }
  },
  {
    "passed": true,
    "name": "장희진",
    "feedback": "수고하셨습니다. :)  \"...AI와 마치 협업하듯이 리팩토링의 방향성을 설정하고, 작은 단위부터 차근차근 개선해 나가며, 항상 \"**내가 어떤 목적과 이유로 리팩토링을 진행하는지**\"를 명확히 전달하려고 노력했습니다\" 훌륭합니다. 아주 과제의 취지를 잘 이행해주었다 생각합니다.\n\n특히나 \"AI에게 구체적인 맥락과 목표를 제시해야 효율적인 결과를 얻을 수 있다\"**는 것을 깨달았고, 점차 질문의 방식을 다듬어갔습니다.\" 라는 점에서 매우 뿌듯하네요. AI에게 내가 원하는 바를 아주 구체적인 형태의 결과를 요청하는 것도 중요하지만 그걸 어떻게 진행해야할지 그 길까지도 선명하게 알려주어야 맥락이 틀어지지 않고 기존의 동작이 문제없을수 있는 방향으로 알려줘야 하는 것이죠\n\n구체적인 예시들이 너무나 훌륭하네요. 인간은 구체적인걸 생각하기를 싫어하도록 설계되어 있어서 모호하고 막연하게 말하는걸 좋아하는지라 이 구체적으로 요구한다라는 기술이 정말로 에너지가 많이 들고 어려운 기술이죠. 그러나 컴퓨터는 완벽하게 구체적이지 않으면 동작하지 않기에 개발자의 전문성이 빛나지는 순간이라 생각합니다. 과제를 통해 이 인사이트를 느꼈다니 너무 좋네요.\n\n아쉬운 점들이라고 썼지만 \"시작부터 명확한 원칙을 정하지 못했던 점\", \"리팩토링 시작 전에 큰 그림부터 그리지 못한 점\", \"AI에게 질문하는 방식이 서툴러서 비효율적인 결과가 많았던 점\" 등이 이미 다 본인이 느끼고 배운것이 된 것 같네요. 아주 좋습니다.\n\n\nQ) 1 '변수 선언 방식 개선'부터 시작해 '컴포넌트 분리', '상태 기반 렌더링', '서비스 레이어 분리'와 같은 7단계의 리팩토링 과정을 거쳤습니다. ‘변수 선언 개선’처럼 작은 단위의 수정부터 시작하면 변경 범위를 최소화하면서 점진적으로 리팩토링을 진행할 수 있다는 장점이 있고, 반대로 ‘컴포넌트 분리’처럼 먼저 큰 그림을 그리면 전체 구조를 빠르게 잡고 나머지 세부 사항들을 정리하기 수월하다는 장점도 있다고 느꼈습니다. 이 두 접근 방식 모두 장단점이 있는 것 같아 실제로는 어떤 방식이 더 효과적인지 혼란스러웠습니다. 아직 리팩토링 우선순위를 판단하는 경험이 부족하다 보니, 제가 선택한 순서가 적절했는지 조언을 듣고 싶습니다.\n\n=> 정석적인 방식이라면 변경해도 문제가 없고 영향도가 낮지만 확실한 소소한 것들을 시작으로 분리가 가능하게 결합도를 낮추는 것을 먼저 진행하는 것이 좋습니다. 그리고 분리가 가능하도록 만들었다면 응집도를 높여가면서 있어야 할 곳에 두는 것이 그 다음이긴 하죠.\n\n=> 하지만 '전체 구조를 빠르게 잡고 나머지 세부 사항들을 정리하기 수월하다'는 것처럼 정해진 구조대로 분리를 해두면 편해지는 것도 있습니다. 특히 뷰와 데이터의 분리와 같이 완벽히 보편화된 구조는 분리를 해두는 것도 좋죠\n\n=> 중요한건 이때에도 단순히 분리를 하는게 아니라 현재 코드의 동작을 그대로 유지하면서도 분리가 가능한 구조를 먼저 만들어 두고 큰 구조를 나누고 하는 식의 방식입니다. 완전히 나 분리를 한 다음 조립하진 않더라도 분리 -> 조립 이라는 순서는 지키면 좋겠죠!\n\n=> 일단 분리해두고 에러가 나든 말든 다 만든 다음에 짜잔하고 테스트 굴려가면서 완성할거야만 아니라면 언제나 문제없는 코드내에서 분리 -> 재배치 -> 조립과 같은 식의 사이클을 탈수 있다면 순서는 요령껏 하셔도 무방합니다\n\n\nQ) 가장 어려웠던 부분은 '바닐라 JS의 명령형 로직을 React의 선언형 방식으로 어떻게 자연스럽게 전환할까?'였습니다. ... 기존 코드를 새로운 프레임워크(React)로 전환할 때, 가장 먼저 파악하고 분리해야 할 '핵심'은 무엇이라고 생각하시나요?\n\n=> 제가 농담삼아 말하는 React의 추구미가 무엇인지 이해하는 것입니다. React에서 이상적으로 생각하는 구조와 계층을 이해하고 그에 맞게 분리하는거죠. 이것은 그동안의 프론트엔드의 역사와도 관계가 있습니다. 사실 React의 추구미라기 보다는 FE의 추구미인것이죠. 뷰와 데이터를 분리하고 컨트롤러 대신 데이터 변경감지를 통한 자동 DOM 업데이트, 상태와 파생데이터의 분리, 도메인과 비 도메인의 분리, 컴포넌트의 계층 구조, 부수효과의 격리 등 그동안 화면을 메인으로 하는 개발의 패러다임이 갖춰지면서 만들어진 계층과 모듈과 데이터 흐름을 이해하는 것이 핵심입니다. 그걸 React가 만들어진 결과를 통해서 이해하게 된다면 다른 프레임워크나 다른 코드의 구성들도 그러한 시각으로 바라볼수 있는거겠죠\n\n앞으로 5주차 6주차를 거치면서 계층과 모듈, 결합도와 응집도에 대해서 찬찬히 이해해나가보도록 합시다.\n\n수고하셨습니다!\n",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/18"
    }
  },
  {
    "passed": true,
    "name": "정건휘",
    "feedback": "안녕하세요 건휘님! 4주차 과제 잘 진행해주셨네요. 고생하셨습니다~!\n\n---\n\n> 자바스크립트에서 리액트로 변환할 때, 추천하는 아키텍처가 있을까요?\n\n아키텍쳐가 중요하진 않다고 생각해요 ㅎㅎ\n아마 5주차 발제에서 나올 이야기 중에 \"쏙쏙 들어오는 함수형 프로그래밍\"에 대한 내용이 있을 것 같은데요,\n리액트와 호환되는 코드는 순수함수와 데이터일 것이고 이를 잘 분리하기만 해도 큰 도움이 된답니다!\n\n> 자바스크립트로 개발을 많이 안해보아서 폴더구조나 패턴에 대해서 고민이 됩니다.\n\n저는 '응집도'를 높일 수 있는 방법이면 무엇이든 좋다고 생각해요.\n'응집도'가 높은 모습은... 가령 현재 코드에서 \"장바구니 모듈\"을 만든다고 가정했을 때 이를 깔끔하게 분리하여 제공할 수 있을지 보면 좋답니다. 깔끔하게 분리한다 = 한 폴더를 통째로 옮긴다 이렇게 보셔도 좋을 것 같아요.\n\n가령, 보통 회사에서는 기능조직(개발자들이 한 팀)과 목적조직(제품 중심으로 기획자 / 디자이너 / 개발자 / PO 가 한 팀)이 있는데요\n목적조직을 그대로 다른 회사에 옮겨도 어색함이 없지만, 기능조직으로 뿔뿔히 흩어져잇는 기획자/디자이너/개발자/PO를 다른 회사로 함께 옮긴다고 했을 때는 병목이 무척 많이 생길 수 있답니다. 모듈화가 어려운거죠.\n\n그래서 응집도를 어떻게 높일 수 있을까!? 에 대한 고민을 해보시면 폴더구조에 대한 문제도 자연스럽게 풀이되리라 생각합니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/56"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "정도은",
    "feedback": "오 과제를 아주 알차게 진행해주셨네요!\n여러가지 시도도 많이 하신것도 보이고 그 과정에서 저도 인사이트를 얻을 수 있었네요.  다른 분들도 많이 참고가 될 수 있는 자료가 되지 않을까 싶습니다 :+1\n과제 부분에 있어서도 크게 피드백을 드릴게 없네요 ㅎㅎ 관련해서 테스트도 작성해주셨고요. 테스트에 대한 방식이나 작성방식은 개선이 필요한 부분도 있지만 지금 단계에서는 충분하지 않을까! 싶습니다 ㅎㅎ\n\n다만, 이미 아시는것처럼 아직 코드 내에 있는 복잡한 로직들이나 분리가 가능한 부분도 조금은 남아있어 보여요. 클래스 이름을 정하는 로직이라거나, 조건에 맞는 텍스트를 보여주는 부분도 분리가 가능할 것 같구요 ㅎㅎ\n지금 refactor 가이드라고 되어있는 룰도 추후에 코드를 생성하는데 사용할 수 있도록 만들 수 있을 것 같아서 이 부분도 수정해서 재사용하시면 좋을 것 같습니다.\n\n> 추천하시는 ESLint, Prettier 설정, 권장하는 컨벤션이 있으신지 궁금합니다.\n\n따로 추천드리고 싶은 규칙은 대신 방향은 있는 것 같아요 ㅎㅎ\n느슨한 방향에서 빡빡한 규칙을 생성하는 방향으로 나아가는게 좋을것 같아요. 너무 처음부터 지키기 어려운 규칙을 적용하고 규칙을 풀어나가는 방향은 좋은 접근 법은 아닌것 같더라구요. 지금 단계에서 프로젝트에 필요한 명확한 규칙을 적용하고 점점더 안티패턴을 작성하지 않는 방향으로 필요한 부분들을 채워나가는 방향으로 운영하는게 좋아보여요.\n\n> 레거시 코드를 리팩토링할 때 어떤 순서로 접근하는 것을 추천하시나요? 제가 적용한 우선순위(사용되지 않는 변수 정리 → 매직 넘버 제거 → 함수 분리 → 모듈화)가 적절한지 혹은 더 체계적이고 안전한 접근법이 있는지 조언을 구하고 싶습니다.\n\n코드, 그리고 모듈간에 영향범위가 적은 부분부터 수정하려고 하는 것 같아요. 말씀해주신 우선순위는 사실 그런 관점에서 좋은 접근이죠 ㅎㅎ 중요한건 이번 과제를 진행해주시면서 하셨던 것처럼 작은단위로 작업을 나눠 진행하고 반복하는것 같아요. 이부분만 유념하시면 어떤 관점이든 순서든 상관없을 것 같아요!\n\n고생하셨고 다음주도 화이팅입니다~",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/35"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "정민기",
    "feedback": "고생하셨습니다 민기님!\n아쉽게 테스트가 통과하지 않아 기본 과제는 불합격 처리 했습니다.\n과제는 잘 진행해주셨는데요! 이미 알고계신것처럼 조금 더 개선할 여지는 있어보여요. 체크리스트에 남아있지 않은 부분들을 채워나가면서 좀 더 개선해보면 좋을것 같습니다 ㅎㅎ\n\n질문 주신 부분 답변 드려보면요.\n\n> 서비스 관점에서의 개선\n\n우선 지금은 서비스 자체가 단순화 되어있는 구조이기도 하고 그러다보니 서비스 레이어에서 담당하는 일이 많아진 거 같아요. 그러다 보니 비즈니스 로직이나 네트워크 통신, 도메인 규칙 등등이 담기게 될 것 같은데요. 이런 부분을 세분화하고 더 나아가는 형태로 고민해보지 않았을까 싶네요. \n\n우선 질문 주신 첫 번째 질문인 도메인 관련 함수들을 서비스 내에 둬야 하는게 맞냐 라는 건 맞아보입니다. 그리고 너무 많은 책임을 지는 것 같아보이면 별도의 레이어로 나누는 식으로 개선해야 할 것 같아요.\n\n그리고 유틸 함수에 있어서도 지금 보여지는건 UI적인 곳에 보여지는 값들을 위치시키는 내용이니 formatter같은 이름으로 UI에 가깝게 두는 형태면 좋지 않을까 싶은 개인적인 의견이 있습니다 ㅎㅎ\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/8"
    }
  },
  {
    "passed": true,
    "name": "정유열",
    "feedback": "유열님 고생하셨습니다 ㅎㅎ\n회고에서 느껴지는 고생의 흔적이 있네요.\n더러운 패턴들에 대해서 명확하게 정리하고 그 부분에 대해 개선을 하는 방향 접근법 매우 좋았습니다 :+1\n각 패턴들이 왜 위험한지 왜 개선이 되어야 하는지 정리한 부분이 특히 좋았어요 ㅎㅎ\n\n다만, 리뷰에서 남겨주신 것처럼 저라면 코드, 그리고 모듈간에 영향범위가 적은 부분부터 수정하려고 하는 것 같아요.  지금의 과제에서는 명확하게 검증할 수 있는 시나리오가 없기 때문에 변경 후 검증하는 단계에서 사실 시간을 많이 보내야 할 수 밖에 없거든요. 그런 맥락에서 컴포넌트 분리는 꽤나 영향을 많이 줄 수 있는 작업이기에 다시한다는 관점에서 고민하신게 합리적인 해결책이지 않나 싶네요. 중요한건 이번 과제를 진행해주시면서 하셨던 것처럼 작은단위로 작업을 나눠 진행하고 반복하는것 같아요. 이부분만 유념하시면 어떤 관점이든 순서든 상관없을 것 같아요!\n\n고생하셨고 다음 주차도 화이팅입니다!!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/11"
    }
  },
  {
    "passed": false,
    "name": "조영민",
    "feedback": "수고했어요 영민, 이번 과제는 레거시 코드를 점진적으로 개선하면서 기존 기능을 완전히 유지하는 것이 핵심 목표였어요. 본인이 생각하기에 리팩토링을 다 완수하지 못해 아쉬웠겠지만 도메인 단위로 코드를 나누고 함수명과 변수명에 고민을 많이 하신 것, 그리고 커밋을 작은 단위로 나누려고 노력한 부분들이 보여요. 잘했습니다.\n\n초반 커밋들을 보면 변수명 명확화, 상품목록 전역 선언, 상품 재고 총합 계산 함수 추가 등 하나하나씩 차근차근 개선해나가려고 했던것 같아요. 그런데 최종 결과물을 보이 할인률쪽의 구현이 누락되어 있네요. 리팩토링은 기존 기능을 그대로 유지하면서 내부 구조만 개선하는 것인데, 새로운 코드를 작성하는 순간 기능 누락의 위험이 생기거든요. 그런 측면에서 불합격을 드릴게요. 리팩토링의 가장 큰 핵심은 기존 로직을 변경하지 않는다니까요. 당연히 누락이 되어서도 안되겠죠.\n\n회고에서도 \"단계별로 리팩토링하는게 어느 순간부터 새로운 코드를 작성하고 있는 것 같다\"고 했는데 꼭 기억해주면 좋겠습니다. 리팩토링을 하다보면 다시 하나씩 작성하고 싶다는 유혹에 빠지기 쉬운데 절대로 그렇게 하면 안됩니다. 반드시 기존 코드를 그대로 유지하면서 아주 작은 단위로 변경하는 방식을 추천해요. \n\n합격, 불합격은 항해에서 하라고 하니까 하는 거지만, 저는 중요한 건 결국 학습이라고 생각해요. 이번에 학습을 했으니 5주차, 6주차 과제에서는 기존 코드를 유지하면서 리팩토링을 하는 방법으로 해보길 바래요. 기대할게요.\n\n화이팅입니다\n",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/45"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "주산들",
    "feedback": "수고하셨습니다! ㅋ \n\n\"수제(직접만들다) 리팩토링에 도전한 나 ~~(악악!!!!!😰)~~ \" ㅋㅋㅋㅋ\n실제로 AI에게 모든 것을 맡기면 생산성이 그렇게 까지 높아지지 않는다는 조사 보고서가 나왔죠. 결국 AI가 만든 것들 중에서 좋은 것 좋지 않은 것을 구분하고 판단하고 재지시하고 하는 일들도 다 시간을 써야 하는 일이니까요.\n\n\"...나는 갈아엎지 않고 꾸준히 진행하고 있으니까 뭔가 잘 진행하고 있는 것 같았고 별의별 생각이 다 들었다.\" 라는 건 중요한 인사이트라고 생각해요. 사실 AI가 나오기전에 리팩토링 과제에서 제일 중요하게 강조했던것은 테스트 코드가 없다고 생각하고 내가 수정한 코드가 절대적으로 기존의 로직을 변경하지 않을거라는 확신을 가진채로 조금씩 수정하는 기술이 중요하다고 했거든요\n\n모든 학문들이 그러하듯 원칙은 변하지 않고 그 원칙 위해서 새로운 개념이나 패러다임이 나오는 만큼 정석대로 해보는건 중요하죠. 수고했습니다.\n\n\"...테오님께 내 코드를 짧게나마 보여드리고 피드백을 받았는데 정말 충격적이었다.\n내 코드는 아주 자연스럽게 DOM에서 Data와 상태를 추출해서 가공해 사용하고 있었다.\"\n\n라는 걸 알게 된 것도 AI를 쓰지 않고 본인이 해봤기 때문에 시행착오를 통해서 알게 되었고 그게 이론을 공부하는게 아니라 실습이라는 과제를 통해서 체득으로 얻게 되는 지혜라고 생각해요. 왜 나쁜 방법은 나쁜 결과를 가져오는지를 해보지 않고서는 '그런가 보다'하고 넘어가지 알 길이 없을테니까요.\n\n\"근데 확실히 과제를 하면서 늘었다고 생각된 부분들은 있다.\n...다소 미련한 도전이었을지도 모르겠으나 나름의 보람과 수확은 있지 않았나 하는 생각이 든다.\" \n미련한 거 아니에요. 한번도 가지 않은 길은 한번은 가야 합니다. 잘했어요!\n\nQ) 테오가 생각했을 때 “AI를 잘 활용해달라” 라는 건 어떤 방식에서의 활용을 기대하시고 한 조언이었나요?\n제가 생각했을 때\n1 많이 질문하고 많은 피드백 받기\n2 다양한 AI를 사용해보며 물어보기\n3 바이브 코딩 체험하기?\n4 좋은 프롬포트를 만들어서 먹이고 성과가 나오는 것을 보기\n\n산들이 말해준 모든 내용들이 있지만 AI를 잘 활용한다라는건 활용법 그 자체라기 보다는 AI를 잘 쓰기 위해서는 결국 내가 원하고자 하는 것을 잘 설명할 수 있을 정도의 지식과 구체적인 표현력이 뒷받침되어야 한다는 것을 느꼈으면 좋겠다고 생각했어요. 내가 모르는데 AI를 구슬려서 해내게 하는 능력도 (생각해보니 중요하네요) 중요하겠지만 내가 알고 있고 원하는 방향대로 만들도록 시켜내기 위해서 결국 기본을 잘해야 하는 구나로 귀결되길 바랬어요.\n\n산들의 수제타코야끼를 굽는 과정을 보니 잘 한것 같네요! 수고 많았습니다. 5주차도 화이팅입니다\n",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/10"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "최용훈",
    "feedback": "안녕하세요 용훈님! 4주차 과제 잘 진행해주셨네요 ㅎㅎ 다만 심화과제까지 할 여유는 없었군요 ㅠㅠ\n\n---\n\n> 주어진 시간 동안 기존 기능을 유지하며 함수를 쪼개보려 노력했습니다. 다만 함수를 분리하는 단위에 대해 의문이 생깁니다. 너무 잘게 쪼개다보면 재사용될 여지가 없는 함수가 발생하고, 큰 단위로 쪼개봐도 재사용이 불가능한 기능을 합니다. 이럴 때 어떤 기준으로 나눠야하는지와 제 코드 내에서 적절히 분리된 함수, 더 분리하는게 바람직한 함수에 대한 피드백을 얻고싶습니다.\n\n함수를 꼭 재사용 때문에 분리하는건 아니라고 생각해요. 저는 재사용보단 \"역할\"과 \"목적\"이 더 중요하다고 생각한답니다!\n자세한 내용은 https://junilhwang.github.io/TIL/clean-code/%EC%A1%B0%EA%B0%81%EB%AA%A8%EC%9D%8C/%EC%B6%94%EC%83%81%ED%99%94%EB%A5%BC-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/ 이 글을 참고해주세요!\n\n\n> 같은 리스트를 순회하는 함수에서 반환 타입이 두개일 떄, 한 함수에서 한번 순회하여 두 타입의 값을 반환하는 것이 좋을까요? 두 함수로 나눠 두번 순회하는 것이 좋을까요?\n\n이에 대한 답변은 멘토링 때 했던걸로 기억해요 ㅎㅎ\n멘토링 노트를 참고해주세요!\n\nhttps://www.notion.so/teamsparta/4-4-7-2302dc3ef51480cb98f8e59ce930d434?source=copy_link#2402dc3ef51480c0949eff9b116273b9\n\n> 함수의 독립성을 유지하기 위해 param으로 값을 받고싶지만, 외부 변수, 함수를 참조하는게 편한 경우가 있을 떄, 어떤 기준으로 합리적인지 판단할 수 있을까요?\n\n음.. 구체적인 예시가 있으면 좋을 것 같은데요, 문장만 봤을 땐 \"어떤 상황이 편한걸까?\"에 대한 의문이 있어요! 보통 훅으로 사용할 때, 훅 내부의 함수가 말씀해주신 모습이긴 합니다 ㅎㅎ\n\n> 최대한 가독성 있는 함수 단위는 어떤 정도의 분리가 이뤄져야할까요? 하나하나의 기능을 모두 함수로 나누면, 그것도 오히려 가독성을 해치는 행위가 아닐까하는 생각이 듭니다.\n\n가독성이 좋다는게 뭘까? 에 대한 고민부터 해보시면 좋답니다!\n저는 가독성이 개인 편차가 있다고 생각해요. 저처럼 맨날맨날 다른 사람의 코드를 보는 사람은, 어떤 코드를 보든 이제 고만고만하게 느껴져요. 내 기준에서 읽기 어려운게 아니라 다른사람이 보면 읽기 어려운 것 같은데? 처럼 판단하는거죠 ㅎㅎ\n\n가령, 함수가 너무 깊게 만들어지면 작성자가 아니면 이해하기 어려운게 맞아요.\n하지만 이 코드를 익숙하게 보는 팀원들이라면 이야기가 다르죠. 오히려 깊이있게 추상화된게 코드를 공유하는 사람들끼리는 이해하기 수월할 수도 있답니다.\n\n뭐랄까.. 우리는 리액트를 쓰면서 useState 라는 함수를 볼 때 이게 어떤 일을 하는지 이해하고 있죠.\n하지만 useState 내부가 정확히 어떻게 동작하는지는 이해하는게 굉장히 어려울 수 있어요.\n\n추상화를 잘 해놓은거죠.\n\n가독성이 좋다는 것. 추상화가 잘 되어있다는 것은 이처럼 input에 대한 output을 예측할 수 있는가에 따라 다르다고 생각해요.\n\n사실 명확하게 \"여기까지 분리해야돼!\" 라고 이야기 하기 어려운 부분인거죠 ㅎㅎ\n다만 함수를 \"합성\"하는 방식으로 만들다보면 깊이를 얕게 유지할 수 있답니다!\n\n마찬가지로 https://junilhwang.github.io/TIL/clean-code/%EC%A1%B0%EA%B0%81%EB%AA%A8%EC%9D%8C/%EC%B6%94%EC%83%81%ED%99%94%EB%A5%BC-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/ 이 글의 내용을 참고해보시면 좋을 것 같아요!\n\nlevel2의 함수를 level3에서 조합하여 사용하는거죠.\n\n",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/3"
    }
  },
  {
    "passed": true,
    "name": "최재환",
    "feedback": "재환님 수고많으셨습니다~\n\n구독, 펍섭등 이벤트 기반의 구조는 장점이 정말 많은 아키텍처가 될 수도 있지만 말씀하신대로  흐름을 파악하기 힘든 단점도 있습니다.\n차라리 state.js 요녀석을 펍섭 기반의 상태관리도구로 더 확장해서 액션을 주입하는 형태로 구현했으면 어떨까 싶어요. \n마치 리덕스의 리듀서 , 액션처럼 뭔가 stateManager에  addAction() 해서 콜백을 전달하고 stateManager는 콜백에 필요한 state 메타적인 함수를 전달하는 것이죵..\n그래서 calculator의 코드들은 stateManager의 확장 기능들이 되는 형태를 생각해볼 수도 있을 것 같고욥.\n초기화도 render가 해주는게 아니라 stateManger가 필요한 정보를 받아서 stateManger.init()하면 내부에서 초기화하는 것이죵.\n\n그러면 view단도 조금 개선이 필요한데 흠. 이야기하자면 많이 길어질 것 같네요.  일단 지금구조에서만 보면\nupdateItemCount, updateCartSummary 이런 함수들이  직접적으로 구독하는 형태가 되면 어떨까 싶어요.\n좀더 상태를 구분해서 직접 관심있는 주제나 데이터 이름으로 구독을 할 수 있으면 성능적으로 개선도 가능할 것 같고요..\n컴포넌트별로 렌더함수를 별도로 구현해서 컴포넌트단위로 구독을 걸어도 좋을 것 같은데 그러면 더무 큰변화가 될 것 같아요.\nstate 에 proxy를 걸어서 누가 \"나를\" 사용하는가를 감지해고 데이터 별로 실행되는 컴포넌트 렌더러를 분리하면 조금더 프레임웍 수준으로 끌어올릴 수도 있을 것 같아요.\n기본적으로 vue가 이렇게 반응형시스템을 구현하죵...\n\n수고많으셨습니다 대환님!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/52"
    }
  },
  {
    "passed": true,
    "name": "한아름",
    "feedback": "수고했습니다! 이번 과제는 레거시 코드를 React 기반의 현대적인 아키텍처로 고도화하는 것이 목표였어요. 회고를 보아하니 시간이 부족해서 원하는 바를 다 하지 못한 부분이 정말로 아쉬웠나봐요. 뭔가 본인이 아쉬운 바가 많아서 그런지 체크포인트들도 비워둔 곳이 많네요ㅎㅎ\n\n그렇지만 결과적으로 잘했습니다. 더티코드가 어쩄든 React위에서 돌아가고 있고 리팩토링이 되었고 적절히 코드 분리도 되었고 테스트도 잘 통과하네요.\n\n아쉽다고 느껴진다는 감각은 좋은 겁니다. 의욕이 있고 내가 목표하고자 하는 이상이 충분히 높다는 것이지요. 물로 내가 만든 이상이 너무 높아서 그 기준치에 도달하지 못한다고 해도 지금까지 내가 한 과정이나 결과물을에 대해서 가치평가를 낮춰서는 안되겠지요. 충분히 잘 했어요.\n\n이러한 아쉬움들 5주차 과제에 충분히 다 녹여내보길 바래요. ㅎ\n\nQ) 이렇게 계산된 파생 상태를 전역 상태로 관리하는게 괜찮은 선택인가요?? 실무에서도 이번 과제처럼 한 번에 페이지에 보여질 값들이 많이 바뀌어야할 때 이 모든 값들을 전역 상태로 관리하는지 궁금합니다!\n\n=> 파생 상태를 전역상태로 관리하는 건 여러가지 측면에서 좋지 않습니다. 당장은 필요하지 않을 데이터를 미리 만들어 두는 것보다는 최대한 lazy하게 구성하는 편이 성능면에서도 좋으니까요. 그래서 지연평가라는 방식으로 파생 상태는 함수로 만들어 주고 원본 데이터들의 조합으로 필요할때에만 만들어두었다가 캐싱이나 메모제이션을 통해서 성능을 확보하는 방식을 쓰고 있습니다. 이미 React에서도 그러한 방법을 쓰고 있죠. 정말로 사용자 동작으로만 바뀌는 상태를 최소화하고 나머지는 useMemo등을 통해서 함수 호출이나 계산을 통해 파생상태를 관리하는 방식이 정배랍니다.\n\n수고많았습니다. 5주차 과제도 화이팅입니다!!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/60"
    }
  },
  {
    "passed": true,
    "name": "허정석",
    "feedback": "안녕하세요 정석님!\n정석님이 해주신 과제를 보자면 참 뭐랄까... 항상 감동을 받는 것 같아요 ㅎㅎ\n잘 성장하고 있는게 느껴져서 좋습니다!\n\n---\n\n> 심화과제로 리액트 + 타입스크립트를 적용해봤습니다.\n리액트를 사용을 하지 않는 저에게는 지금 프로젝트 구조가 (src/advanced/**/*) 익숙치 않습니다.\n현재는 도메인 중심 설계(Domain-Driven Design) 로 분류를 해놨는데 이 방식이 보편화가 된 방식인지 궁금합니다. 혹은 코치님이 선호하는 구조가 있는지, A 같은 성향의 프로젝트엔 A` 구조 같은 공식이 있는지도 궁금합니다.\n\n제가 방금 디스코드 채널에도 올렸는데요,\nhttps://discord.com/channels/1288769861589270590/1369931146049359912/1401067166190665748\n\ndomain driven으로 만들어주신 것도 좋은 방법이라고 생각합니다.\n다만 저는 설계를 그렇게까지 중요하게 생각하진 않아요 ㅎㅎ\n\n중요한건 요구사항이고, 이 요구사항에 얼마나 잘 대응할 수 있는가가 중요한거죠.\n\n가령, 지금 만들어주신 구조에서 \"할인율 규칙이 50개 정도 추가 된다면!?\" 이라는 가정이 붙었을 때 코드가 어떻게 변화할지, 잘 대응할 수 있을지 고민해보시면 좋답니다!\n\n선호하는 구조도 딱히 없네요..\n다만 응집도가 높은 형태라면 어떤 형태든 상관없다고 생각해요.\n\n응집도를 높게 만드려면 어떻게 해야 좋을지에 대한 본질적인 고민이 필요한거죠 ㅎㅎ\n\n내 코드의 응집도가 높은지 알 수 있는 방법은 일부 코드를 \"모듈화\" 혹은 \"라이브러리로 만들어서 배포\"한다고 가정했을 때 깔끔하게 떼어낼 수 있는까!? 라고 생각해요.\n\n가령, 장바구니 모듈을 만들어서 다른 프로젝트에 붙여본다고 생각하면 편하답니다!\n\n결론은\n\n- 요구사항이 제일 중요하다\n- 응집도를 높일 수 있는 구조면 뭐든 좋다.\n\n이렇게 볼 수 있겠네요!",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/41"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "현지수",
    "feedback": "지수님 고생하셨습니다. \n작성하신 문서를 읽는데도 시간이 굉장히 오래걸렸는데요. 꼼꼼하게 잘 작성해주신걸 보니 과제를 어떤 방향으로 진행할 수 있었는지 명확하게 이해할 수 있었습니다.  시각화한 다이어그램도 좋았어요 :+1\n과제는 전반적으로 매우 잘 작성해주셨어요! 크게 피드백 드릴만한 내용이 없는 것 같습니다. \n\n궁금하셨던 내용 답변드려보고 마무리 해볼게요.\n\n> 도메인 중심 설계 + MVC 패턴의 적절성\n\n좋은 접근법이였어요! 비즈니스 로직들을 미리 나눠둔 덕분에 리액트로 마이그레이션 할 때 별도 분리를 진행하면서 코드를 재작성하지 않아도 되었던것으로 생각이 됩니다. :+1\n\n> 2. React 상태 관리\n\n단일 진실 공급원 관점에서는 한 곳에서 관리를 하면 일관성이 보장된다는 점도 있고 상태 변화를 한 곳에서 추적할 수 있기 때문에 함께 업데이트 되어야 하는 값들이 자연스럽게 처리될 수 있긴 한 것 같아요. \n지금의 단계에서는 상품의 양이나 성능 이슈가 발생할 만큼은 걱정하지 않아도 괜찮은 수준인 것 같고, 최적화는 문제가 발생하는 그 시점에 고민을 하면 되기 때문에 갠적으로는 분리를 하면 오히려 복잡도만 높아질수도 있을 것 같네요!\n\n> 전체적인 개선 방향\n\n걱정하실 필요없이 잘 작성해주셨어요. useReducer같은 것들을 사용해서 명확하게 상태를 관리해주시고 관심사의 분리나 훅을 구성하는 부분들도 너무 잘 해주셨습니다. 더 나아간다면 앞선 주차때 했던 메모이제이션이나 에러 바운더리, suspense, 합성 패턴 같은것들이나... 포탈같은 것들을 활용해보는것?들 정도이지 않을까 싶네요!\n\n이번 주 과제 너무 잘해주셨고 다음주도 이번주처럼 잘 하시길 바랍니다!\n",
    "assignment": {
      "name": "STEP08 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-1/pull/46"
    }
  },
  {
    "passed": true,
    "name": "강병준",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/11"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "권지호",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/10"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/39"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/23"
    }
  },
  {
    "passed": true,
    "name": "김소희",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/52"
    }
  },
  {
    "passed": true,
    "name": "김수민",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/47"
    }
  },
  {
    "passed": true,
    "name": "김수현",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/26"
    }
  },
  {
    "passed": false,
    "name": "김연수",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김유현",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/31"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/42"
    }
  },
  {
    "passed": true,
    "name": "김효진",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/14"
    }
  },
  {
    "passed": true,
    "name": "김휘린",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/38"
    }
  },
  {
    "passed": true,
    "name": "박상수",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/18"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/9"
    }
  },
  {
    "passed": false,
    "name": "박의근",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/54"
    }
  },
  {
    "passed": true,
    "name": "박준형",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/5"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박창준",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/40"
    }
  },
  {
    "passed": true,
    "name": "신홍준",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/1"
    }
  },
  {
    "passed": true,
    "name": "신희원",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/36"
    }
  },
  {
    "passed": true,
    "name": "양성진",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/13"
    }
  },
  {
    "passed": false,
    "name": "양창훈",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/22"
    }
  },
  {
    "passed": true,
    "name": "여진석",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/2"
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/53"
    }
  },
  {
    "passed": true,
    "name": "오하늘",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/15"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/6"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "윤영서",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/4"
    }
  },
  {
    "passed": true,
    "name": "이가은",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/24"
    }
  },
  {
    "passed": true,
    "name": "이민재",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/25"
    }
  },
  {
    "passed": true,
    "name": "이유진",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/17"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이은지",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/44"
    }
  },
  {
    "passed": true,
    "name": "이의찬",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/46"
    }
  },
  {
    "passed": true,
    "name": "이정우",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/51"
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/32"
    }
  },
  {
    "passed": true,
    "name": "이지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/8"
    }
  },
  {
    "passed": false,
    "name": "이진희",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/33"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/20"
    }
  },
  {
    "passed": false,
    "name": "임규원",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/37"
    }
  },
  {
    "passed": true,
    "name": "임두현",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/50"
    }
  },
  {
    "passed": false,
    "name": "장루빈",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/30"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "장희진",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/27"
    }
  },
  {
    "passed": true,
    "name": "정건휘",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/48"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "정도은",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/3"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "정민기",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/7"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "정유열",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/12"
    }
  },
  {
    "passed": true,
    "name": "조영민",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/34"
    }
  },
  {
    "passed": true,
    "name": "주산들",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/21"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "최용훈",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/16"
    }
  },
  {
    "passed": true,
    "name": "최재환",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/29"
    }
  },
  {
    "passed": true,
    "name": "한아름",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/41"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "허정석",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/28"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "현지수",
    "feedback": "",
    "assignment": {
      "name": "STEP09 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/35"
    }
  },
  {
    "passed": true,
    "name": "강병준",
    "feedback": "안녕하세요 병준님! 5주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> Section 단위로 파일을 나누는 기준이 depth(폴더 깊이) 기준이 되어야 할까, 아니면 추상화 수준(레이어 구조)을 기준으로 나누는 게 더 적절할까? 예를 들어 depth 1 수준에서 파일을 나누려다 보니 가독성이 떨어져서 Section 단위로 나누는 것이 나아 보였는데, 이렇게 되면 추상화 수준이 섞여서 일관성이 무너지는 것 같아 고민입니다. 이럴 때 추상화 수준은 depth를 기준으로 봐야 할까요, 아니면 도메인 레이어 구조(shared, entities, widgets, pages 등)를 기준으로 봐야 할까요?\n\n병준님께서 말씀하시는 Section의 의미를 정확히 이해하기가 어렵네요..!\n아마 폴더를 말씀하시는거겠죠?\n\n추상화 수준에 포커스를 맞춰서 판단해보자면 저는 레이어구조라고 생각해요!\n그런데 일단 Section이 뭘 의미하는지에서부터 제가 어떻게 답변드려야 좋을지 헷갈리네요 ㅠㅠ\n이건 다시 문의 채널에 남겨주세요!\n\n> 페이지 내부에 남아있는 로직 들을 훅으로 분리하고자 할 때, 이 훅들은 어떤 네이밍과 역할 기준으로 분리하는 것이 적절할까요?\n\n고민이 된다면 그냥 다 분리해버리세요 ㅎㅎ\n일단 useCartPage 로 분리하는거죠.\n그 다음에 useCartPage에서 쓰이는 코드를 보고 역할을 추론하여 네이밍 하는거죠\n\n이름을 먼저 생각하는게 아니라, \"이 코드가 무슨 일을 하고 있지?\"를 토대로 추론해야 한다고 생각해요.\n\n지금 과제를 수행해주신 내용을 기준으로 보면 잘 분리해주셔서 더 이상 분리하지 않아도 좋을 것 같긴해요!\n\n> 저는 상태 변경은 Store에, 비즈니스 로직은 Service 계층에 분리하는 구조를 따르고 있는데, 이런 구조가 적절한지 고민됩니다.\n\n적절하다고 생각해요!\t그럼에도 고민이 된다면 반대로 적절하지 않을 수 있는 이유 혹은 코드 조각을 찾아보시면 어떨까요? \n\n필요에 따라 여러 개의 계층이 더 생길 수도 있고, store의 로직도 순수함수로 분리하는 등의 과정이 필요할 수 있답니다 ㅎㅎ\n\n가령 상태관리 라이브러리를 교체하는 상황을 생각해보시면 좋을 것 같아요!\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/11"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "권지호",
    "feedback": "안녕하세요 지호! 수고했습니다. 아주 잘했습니다. 회고의 내용은 그렇지.. 음 그래! 하면서 감탄하면 잘 읽었습니다. 아주 잘쓰는군요. 멋집니다.\n\nQ) 모듈 단위 싱글톤 훅(Jotai) 설계에 대한 피드백\n=> 너무 잘했습니다. 결합도와 응집도 관련해서 모든 코드는 책임이 있고 자리가 있습니다. atom의 자리가 정해진 건 아닙니다. atom을 몇개 쓰지 않고 전역적인 테마나 설정 관리로 쓴다면 그냥 atom끼리 모아두는게 더 좋을수 도 있습니다.\n\n=> 좋은 자리라는건 쓰이는 곳에 가장 가까이 두는 것입니다. 같이 쓰면 공통화를 하는것도 결국 공통된 곳에 두는게 모두에게 가깝기 때문이죠. productsAtom이 쓰이는 곳은 useProduct  밖에 없으니 이 둘을 한데 두는 것은 아주 잘 결정한 선택입니다.\n\nQ) 적절한 리팩토링의 타이밍\n\n=> 더티코드를 클린하게 하고 결합도를 낮추는 리팩토링, 즉 이 코드를 변경해도 다른 코드에 영향이 없는데 더 나아지는 형태의 리팩토링은 보일때마다 하세요. 이름이 좀 이상한 것 줄바꿈이 없는것 불필요한 인라인 코드, 순수함수로 빼도 괜찮은 코드, 컴포넌트 분리 등...\n\n=> 이번 과제를 해보면서 느꼈겠지만 확신을 가지고 이렇게 바꿔도 테스트 코드는 통과하겠지 하는것과 아.. 이렇게 하면 테스트 되나? 하면서 돌려보던 그 느낌이 다른걸 본인도 알거에요. 그런 코드들은 보일때마다 하세요. 단 커밋을 할때에는 응집도 있게 커밋해야겠죠?\n\n=> 그리고 구조변경이나 응집도를 바꾸는 리팩토링의 경우에는 모두의 합의도 필요하기에 방향성과 합의점을 먼저 만들어가는게 좋습니다. 특히나 어떻게하는가?에 대한 합의보다도 더 큰 상위의 합의를 먼저하는거에요. 가령 이번에는 React19로 올리는게 목적이다 라고 합의를 하면 그걸 하기 위한 리팩토링은 OK 그게 아닌 것들은 좀 우선순위도 미뤄볼수도 있겠죠. 그게 아니라 단순 방법을 가지고 논의하기 시작하면 어려워요.\n\n=> 앞에서 사전작업을 잘해서 충분히 결합도가 낮은 코드라면 대규모 리팩토링도 그렇게 어렵지 않게되요. 그러니 평소에 클린하지 못하다 그런 코드가 보일때마다 야금야금 정리정돈 잊지 않기를 바래요! 평소에는 정리정돈 그러다가 날잡고 대청소, 아주 아주 신중하게 리모델링! 무슨 말인지 알겠죠?\n\n\nQ) 앞서 언급했던 저의 판단 과정이나 리팩토링 코드의 방향은 적절할까요?\n=> 판단 과정은 아주 훌륭해요. 그리고 atom을 useProduct에 둔 것처럼 자리를 한번 더 생각해보길 바래요. 컴포넌트 props를 다루거나 이벤트 핸들러 등을 다루는데 있어서 혹은 hook을 배치하는데 있어서 이 자리가 최선인가? 하는 생각을 해보길 바래요. 그러면 조~금 더 좋은 코드의 방향성을 가진 코드가 될 것 같아요!\n\n총평은 지금의 방향성이 아주 좋았는데 아직 도착지는 다 못간 느낌입니다. 여전히 더 좋아질 구석이 있는 코드입니다.\n\n수고했습니다. 6주차 과제도 화이팅이에요!\n\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/10"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "ㅋㅋㅋ민지님 고생하셨어요. 약간 뇌를 빼고 하신것 같다고 하셨지만 잘 마무리 하신것 같아요. 큰 것부터 시작해서 작은 흐름으로 진행을 한건 아마 익숙한 부분에서 시작해서 점점 중요한 로직들로 접근해나가셨던 것 같은데 이렇게 할 경우 영향 범위가 크니까 검증을 잘 하면서 조심해서 진행해야 했을 것 같네요! 다음에 이런 큰 개선이 있을때는 작은 단위부터 반복적이게 진행해보면 좋지 않을까 싶었습니다.\n\n질문 주신 부분 답변 남겨보면요!\n\n> cart와 product가 혼재되어 있습니다\n\n일단 코드와 상관 없이 이런 두 도메인 로직이 섞이는 경우에는 사실 명확한 기준을 만들기 어려운 부분이기도 한데요. 이럴때는 핵심 비즈니스 로직의 소유가 누구인지!를 기준으로 나누는 것 같아요. 지금의 경우에는 주된 사용 목적이 카트에 있는 것 같아서요. 근데 사실 명확하지는 않죠. 아무튼 이런 기준으로 모두가 합의할 수 있는 수준에 맞춰 작성하는게 가장 합리적이지 않을까 싶습니다.\n\n다시 코드를 기반으로 살펴보면 지금의 코드는 사실 모델에 대한 순수한 로직이라고 보기보다는 비즈니스 로직이 합쳐진 것이라고 볼 수 있을 것 같아요. 이럴때는 service나 helpers같은 이름으로 분류를 해서 관리하고는 하는데요. 그런곳에 위치시키면 이런 코드들이 모여있구나라고 알 수 있어서 훨씬 합리적이고 쉽게 배치할 수 있지 않나 싶네요.\n\n>  저 함수가 도메인 함수로 봐야할까요? 아니면 유틸 함수로 봐야할까요.\n\n이 함수는 유틸함수로 봐야할 것 같은데요.\n도메인 함수는 비즈니스 영역에 대한 규칙, 로직을 명확하게 담고 있어야하죠. 예를들어서 실제 도메인이 cart라면 cart에 담긴 내용을 제거한다라거나 하는 함수들이 비즈니스 로직이 될 것이고 지금처럼 특정 도메인에 종속되지 않고 다양한 상황에서 재사용 가능하다면 범용적인 헬퍼, 유틸리티 함수라고 볼 수 있을 것 같아요. 파라미터 이름을 stock으로 해서 그렇지 stock을 다른 이름으로 변경한다면 여러곳에서 사용할 수 있죠 사실 ㅎㅎ 이런 기준으로 보면 좋을것 같아요!\n\n> 이렇게 많은 양이고 익숙하지 않은 코드인데 시간은 리밋이 있다 이럴 때 어떤 식으로 코드를 작성해야 코드를 갈아엎지 않고 할 수 있을까요?\n\n사실 이런 상황이 일반적이지는 않고, 자주 경험해볼만한 상황은 아닌데요. 그럼에도 전체적인 코드를 개선해야 하는 상황이고 많은 양을 해야 한다면 작은 범위부터 명확한 검증을 수반해서 해야 한다고 생각해요. 만약 이 서비스를 운영중인 앱이라고 봤을 때 영향을 받을 수 있는 모듈, 기능 자체가 많기 때문에 굉장히 크고 꼼꼼한 검증이 함께 되어야 할 거에요. (하지만, 기능은 변하지 않았죠.) 그러니 굉장히 조심히 작은 범위부터 수정을 진행하고 점점 범위를 넓히면서 진행을 해야 하지 않을까 싶어요.\n\n그럼에도 만약 시간 제한이 너무 강하게 있고..반드시 해내야 하는 개선이라면 명확한 목표만 두고 체크리스트를 만들어 둔 다음 빠르게 하고 검증에 시간을 훨씬 많이 쓰지 않았을까 싶네요. 어떤 상황이든 코드를 갈아엎는 리팩토링은 좋은 방식은 아닌것 같아요.\n\n고생하셨고 다음주도 화이팅입니다!!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/39"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "ㅎㅎㅎ 아쉬움이 남는 주차셨군요 도현님\n지금 모두가 함께 과제를 하는 시간에 함께 몰두하는 경험이 가장 이상적이지만, 시간이 없다면 혼자 다시 되짚어보면서 수강생들과 이야기를 나눠보면 되니 꼭 다시 해보는걸 목표로 하시죠. 아직 전반적으로 개선이 추가로 필요한 부분은 남아있는 것 같아요! 꼭 더 집중해서 해보는걸로 하죠~\n\n질문 주신게 많아서 바로 답변을 해보겠습니다 ㅎㅎ\n\n> 표현식, 선언식 함수\n\n표현식과 선언식, 그리고 화살표 함수와 일반함수 표기법의 차이가 함께 있는데요. 관련해서 설명을 드리기보다는 https://codingeverybody.kr/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98%EC%9D%98-%EC%9D%B4%ED%95%B4%EC%99%80-%EC%82%AC%EC%9A%A9%EB%B2%95/ 이 글을 보시면 좋을것 같구요. \n\n리액트 내부에서는 사실 크게 차이가 없을 수 있는데요. 크게 차이가 없는 경우에는 통일된 규칙만 갖고 작성하면 될 것 같아요.\n\n> 함수 네이밍 (handleAddCart vs addCart)\n\n개인적으로 네이밍을 할 때는 역할을 잘 드러내도록 이름을 짓는게 중요하다고 생각하는데, 핸들러 즉 특정 이벤트나 상황이 발생했을 때 그것을 처리하는 함수라고 볼 수 있다면 handle을 붙이는게 나쁜건 아닌것 같아요. 다만, 영어로 읽었을때나 문법상으로 아름다운 명칭은 아니기때문에 handleClickAddCartButton 같은 형태로 명확하게 어떤 핸들러인지 드러낸다면 괜춘지 않을까 아니면 addCart를 바로 쓰는 형태로 하는것도 나쁘지 않을것 같구요!\n\n> 목록 컴포넌트 설계 방식\n\n여기서 기준을 한번 제안 드려볼테니 나눠보시는 게 좋을것 같아요.\n1. 가독성이 어느게 좋은지? 재사용성이 좋은 컴포넌트 작성 방식은?\n2. 명시적으로 제어할 수 있는 패턴은 어떤건지? (만약 외부 컴포넌트였다면?)\n3. 확장성은 어떤 컴포넌트가 좋은지?\n4. 성능에 있어서 이슈가 발생할 수 있는 컴포넌트는?\n5. 제어의 역전(IoC)이 가능한지?\n6. 테스트가 용이한지?\n\n일단은 요정도로 표를 만들어서 한번 비교해보시면 좋을것 같아요!\n\n> ViewModel을 class로 관리하는 방식\n\n굉장히 많이 사용하는 방식이죠 ㅎㅎ 특히 BE측에서 많이 사용하는 방식인데 좋은 방식이라고 생각해요.\n\n> Header 분기 처리\n\n합성 컴포넌트 패턴같이 디자인 패턴을 활용해보면 좋을것 같아요!\n조건을 모두 프로퍼티로 전달받아 제어를 하다보면 가독성이 안좋아지고 조건이 너무 복잡해지는 문제가 발생하니까요! \n공통적인 규칙을 따르지 않는다면 별도 컴포넌트로 만들어버려도 괜찮구요\n\n> useCart에서 Toast 로직 처리 위치\n\n책임 분리 관점에서는 잘 하셨습니다! 다만, \"누가 알아야 하는 정보?\" 관점에서 고민을 하는게 좋을 것 같은데요. toast 표시 여부나 메세지가 상황별로 달라져야 한다면 호출을 하는 방향으로도 한번 고민해볼수는 있을것 같아요.\n\n> 베럴 파일(Barrel File)에 대한 의견\n\n음 저는 선호하지 않는 편인데요. 하지만, 종종 필요한 경우에는 아래 문서에 나온 기준처럼 문제가 발생할 여지는 없는지 얻을수 있는 이점은 뭔지 명확하게 하고 사용하는 편인것 같아요. 아마 다음주쯤에 FSD를 하면서 배럴 파일 같은것들을 사용하게 될텐데 이 때 와일드 카드 형태로 export를 하는게 아니라 지정을 하게 되면 인터페이스 관점에서 공개하는 정보를 명확하게 할 수 있다는 장점이 생기거든요.\n \nhttps://github.com/yeonjuan/dev-blog/blob/master/JavaScript/speeding-up-the-javascript-ecosystem-the-barrel-file-debacle.md\n요 글도 함께 읽어보면 좋겠네요!\n\n> 과제와는 직접적인 관련은 없지만 궁금한 점이 있습니다! \n\n~배 %보다는 실질적으로 시간이 얼마나 줄었는지 살펴보는건 필요한것 같아요. 사실 ms가 6ms -> 1ms되었으면 매우 빠르겠지만, 매우 적은 변화라 인간이 인지하기 힘들고 사실 제일 중요한건 라이브러리 광고하는 당사자들이 벤치마킹하는 방식이 자기들 유리한식으로 되어있어서 문제가 된적이 많았었거든요. \n\n그럼에도 우리는 매우 작은 그 ms, 런타임에서 발생할 수 있는 일련의 작은 로딩들을 줄이는 그 기술들을 선택하기는 해야할거에요. 따로 감각이나 지식을 추구하기보다는 경쟁 라이브러리들, 그리고 내가 지금 사용하고 있는게 어느정도였는데 얼마나 빨라졌구나 어떻게 빨라졌고 어떻게 측정이 되었구나만 보면 괜찮지 않을까 싶어요!\n\n고생하셨고 다음주도 화이팅입니다~",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/23"
    }
  },
  {
    "passed": true,
    "name": "김소희",
    "feedback": "고생하셨습니다 소희님 ㅎㅎ 밤새서 진행하셨나봐요 ㅠㅠ\n전반적으로 과제의 목표대로 잘 작성해주셨네요!\n회고에 남겨주신 것 처럼 테스트 코드가 깨지지 않는 선에서 한단계씩 차근차근 나아가는게 리팩토링의 핵심인 것 같아요. 그 관점에 맞춰서 잘 진행해주셨던 것 같습니다 ㅎㅎ\n그리고 리팩토링은 점진적으로 진행이 되어야 하고 아쉬운점에서 말씀해주신것처럼 채로 거르는것 같이 여러번 과정을 거치면서 나아가야 하는 것 같아요. 그 개선 시점에는 개선에 대한 관점만 가지고 개선하는걸로요. 잘 하셨고 여유가 있으실 때 꼭 아쉬우셨던 점 하시면 좋겠네요 ㅎㅎ\n\n질문 답변 드려보면요.\n\n> useProducts 훅이 addNotification 함수를 props처럼 주입 받는 방식과구현했습니다.\n\n제 개인적으로는 후자가 더 좋은 선택인 것 같아요. jotai 철학상으로도 필요한 곳에서 필요한 아톰을 호출하는 형태로 구현하기 위해 특화된 훅이나 접근 방식을 제공했던 것으로 알려져있는데요. useProducts가 매우 범용적이게 사용할 수 있고 주입받는 noti에 대한 아톰이 다양한 형태의 타입인 noti라면 주입받는게 적절할 것 같아요. 만약 여러 타입인 경우에는 이렇게 분리를 하게 되면 테스트에 대한 용이성도 생기고 인터페이스를 통일 시키는 중간 계층도 하나 생겨서 확장성도 좋아질 거구요. 근데 지금은 그런 케이스는 아니지 않을까..! 싶습니다.\n\n> Atom을 products, cart, ui 등 도메인별로 분리했는데, 어느 정도까지 분리하는 것이 적절한지에 대한 기준이 궁금합니다.\n\n지금도 잘 정리해주셨어요. 다만 폼 상태나 이런것들은 지역상태로 유지하면서 컴포넌트를 시작하지만, 너무 엄격하게 해당 훅이나 컴포넌트 로컬에서 상태를 관리하려고 강조하기보다는 여러 컴포넌트에서 사용해서 드릴링이 발생하는 경우 또는 폼에 대한 특별관리가 필요하거나.. 편의성 관점에서 고민해봐도 될 것 같아요! 사실 리덕스를 쓰던 과거에는 이런것들을 분리하는것 자체가 비용이였는데 지금은 써보신것처럼 구성을 하고 관리하는 것 자체가 어렵진 않으니까요.\n\n고생하셨고 다음주도 화이팅입니다~~ ",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/52"
    }
  },
  {
    "passed": true,
    "name": "김수민",
    "feedback": "ㅋㅋㅋ수민님 안녕하세요.. \n셀프회고를 보니 이번 주 바쁜일이 있으셨다구요..ㅠㅠ\n주말이 찾아왔으니 다음 주 과제에 대해 깊게 고민하기 전에 그래도 어느정도 회고를 하고 진행하면 좋을것 같아요 ㅎㅎ\nAI를 사용해주셨다고 했는데, 사실은 그 과정에서 결과를 보고 개선해 가는 과정을 일정부분 겪으셨다면 그런 부분도 경험으로 남겨봐도 좋을것 같구요\n\n아무튼 이렇게 과제를 마무리하는건 아쉬운것 같으니 결과도 꼭 살펴보시고(개선할 게 많아보여요!) 정리하시면 좋을것 같습니다.\n\n다음주는 꼭 잘 마무리해주세요!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/47"
    }
  },
  {
    "passed": true,
    "name": "김수현",
    "feedback": "수고했어요 수현. 조금은 쓴 소리가 될 수 있을텐데 필요하다고 생각하니까 채점에 대한 답변을 대신할게요.\n\n\"일단 과제의 통과가 목적이기 때문에 어찌됐든 진행이 되면 넘어갔습니다. (회사에서 deadline 맞추듯이 과제도 똑같이 수행) 이런식으로 하는게 맞는지 고민이 되고, 다음 주차 과제에서는 또 똑같이 이렇게 진행을 해야할지 의문이 듭니다.\"\n\n인간은 본능적으로 위험감지신호가 있어요. 본인이 의문이 들었다는거 자체가 이미 본인도 이게 내심 좋은 방향은 아니란걸 알고 있을거에요. 그리고 이건 개인적인 견해로도 잘못된게 맞다 생각합니다.\n\n그렇다면 과제의 통과보다 학습이 더 중요한가? 라고 물으면 과제의 통과가 더 중요합니다. 왜냐하면 '과제를 통과하지 못했다.' 라는 명백한 증거가 있는데 '나는 혼자서 학습을 했기에 과제를 통과하진 못해지만 나는 공부가 되었어!' 라고 스스로 생각을 하기란 대단히 어렵습니다. 실제로 그게 사실일지라도 현실을 부정한다는건 상당한 자기기만에 가까운 자기 확신이 필요하니까요.\n\n그렇지만 지금의 학습방법은 좋지 않습니다. 실제로 코드를 보았는데에도 거의 비판없이 AI스타일의 코드가 붙여져 있어요. 그런데 정작 AI를 썼다는 그 코드의 퀄리티가 월등하게 좋지 않아요. 심지어 지금 작성해준 회고도 에너지를 들여 잘 작성해졌다고 보기는 어렵네요.\n\nAI는 고점을 높인다기보다는 저점을 높이는 장치입니다. AI의 특성상 사람들이 가장 표준적으로 많이 사용하는 것들 학습해서 대답을 제공해요. 물론 그 컨텐츠 중에서는 학습자료, 논문, 지식등 대단한 지식베이스가 있지만 여전히 AI가 만든 코드는 절대적으로 좋은 수준은 아닙니다.\n\n우리가 지향해야 하는건 아직은 부족한 AI 눈과 손이 되어줄 몸이 아니라, AI의 결과가 평균이상이긴해도 결국 모든 사람이 출발하게 되는 가장 저점이라고 생각하고 그 이상을 어떻게 하면 할 수 있을지를 계속 고민해야 되요.\n\n같은 AI를 사용했지만 사람마다 결과가 달라요. 심지어 회고도 코드도 다릅니다. 그리고 그중에서는 수현이가 작성한 코드보다 좋은 것들이 더 많아요.\n\n혼자서 더 많은 고민을 하라는게 아니에요. AI가 만들어준 결과를 시작으로 뭘 더 잘해야하는지를 다른 사람들의 결과물들을 살펴보고 고민하고 더 나은 결과를 물어보고 해서 지금보다 완성도를 더 올려보세요. 첫번째 말해주는 답이 정답이 아니라 이게 가장 평균적인 결과물이라는 생각으로 더 엔트로피를 높일 생각으로 AI와 함께 질문하고 고찰하고 성찰해보기를 바래요.\n\nAI와 함께 하는 현실을 피할 수는 없을 거에요. 그 답을 알아가는 것도 항해플러스 과정에서 발견해나가기를 바랍니다. 어쩄든 다같이 AI를 써도 나보다 더 결과가 좋은 사람들은 지금 내가 하는것과 뭐가 다를까? 라고 한번 생각으로 해법을 찾아보기를 바래요.\n\n화이팅입니다!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/26"
    }
  },
  {
    "passed": false,
    "name": "김연수",
    "feedback": "",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김유현",
    "feedback": "안녕하세요 유현님! 5주차 과제 잘 진행해주셨네요 ㅎㅎ\n다만 클린코드 챕터의 경우 코드를 작성하는 것도 물론 중요하지만 내가 왜 이렇게 작성했고 왜 이렇게 생각했는지에 대한 과정이 더 중요해서요!\n나중에라도 회고해보시면 좋겠어요!\n\n고생하셨습니다~!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/31"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "지혜님 안녕하세요!\n전반적으로 잘 정리해주셨습니다 ㅎㅎ\n리팩토링의 핵심처럼 기능이 올바르게 동작하는 것, 테스트를 기반해서 점진적으로 코드를 개선하고 접근하는 방식으로 하셨다니 좋은 경험이셨을것 같아요.\n코드는 전반적으로 잘 정리해주셨는데요!\n다만, 지혜님이 의견을 남겨주신 것처럼 atom에 대한 부분에 대한 답변 드려보면 일단 제 기준에서는 엄~청 복잡하지는 않은 것 같아서 하나로 관리해도 전혀 무리는 없을 것 같아요. 왜 한군데서 처리를 했는지 이해도 되구요.\n다만, 기반이 되는 규칙을 하나 만들고 유연하게 적용하면 좋을것 같아요.\n기반이 되는 규칙으로는 도메인 별로 분리하도록 하고 (그렇게 하면 도메인 로직을 찾기도 편하고 관련 기능끼리 모여서 응집도도 높아질거에요) 각 파일내에서 파생 상태를 만들어서 관리하거나, 합쳐서 관리하는 형태로 분리하면 좋지 않을까! 싶습니다.\n\n고생하셨고 다음주 과제도 화이팅입니다!!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/42"
    }
  },
  {
    "passed": true,
    "name": "김효진",
    "feedback": "수고했어요 효진! \"그런데 일단 냅다 분리하고 보니까 이 사단이 나버렸습니다…wow…\" 의 결과물을 경험하는 게 취지였으니 ㅋ 잘했습니다. UI가 아닌 컴포넌트를 다루게 되면 필연적으로 데이터를 다루는 값들과 함수들이 복잡해지는 문제가 발생하죠\n\n이번 과제의 경우 사실 폴더구조보다는 얼마나 더 세분하게 나눠보고 필요한 props과 그렇지 않은 props를 구분해서 전역상태관리를 잘 활용해보자는 데 있어습니다. \"저는 살면서 이렇게 단촐한 코드를 처음 봤습니다. (거의.. 처음..?)\" 라는 것처럼요.\n\n실제 코드를 보면 모든 코드가 그러하진 않않네요. 여전히 컴포넌트에서는 props를 사용하고 있는 컴포넌트들이 많이 보여요. 컴포넌트의 재사용은 중요한 개념이지만 데이터 컴포넌트는 재사용이 거의 안된다는 사실을 기억하면서 무엇은 재사용하면 좋은지 무엇은 클린함을 추구하는게 좋은지 균형을 생각해보길 바래요.\n\n이제 마지막 남은 과제에서는 이 모든 것들의 아쉬움을 한번 제대로 다 적용해볼 수 있을거라고 생각해요. 기대할게요. 화이팅입니다!\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/14"
    }
  },
  {
    "passed": true,
    "name": "김휘린",
    "feedback": "안녕하세요 휘린님! 5주차 과제 너무 잘 해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n---\n\n> 코치님께서 이 과제를 진행하셨다면 어느정도까지 분리하여 쓰실지, 현실적으로 \"여기까지 분리하면 충분하다!\" 는 기준이나 실전 팁이 있으신지 너무 궁금합니다..!!\n\n저는 아마 추상화 수준을 계속 생각할 것 같아요 ㅎㅎ\n\nhttps://junilhwang.github.io/TIL/clean-code/%EC%A1%B0%EA%B0%81%EB%AA%A8%EC%9D%8C/%EC%B6%94%EC%83%81%ED%99%94%EB%A5%BC-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/\n\n이 글의 내용을 일단 참고해주시면 좋겠어요!\n\n글에서 다루지 않는 부분에 대해 조금 더 설명드리자면,\n\n1. 일단 컴포넌트 내부의 도메인을 다루는 로직을 hook으로 분리합니다.\n2. hook에서 순수함수를 분리합니다.\n3. 그리고 추상화 수준이 정렬되었는지 확인하면서 이를 정렬시키는 방식으로 계속 분리해나갑니다.\n\n저는 3번이 제일 중요하다고 생각해요!\n\n지금 휘린님께서는 명확하게 어떤 계층으로 분리할지 정리해놓은 상황이기 때문에 이에 대한 일관성만 잘 유지할 수 있으면 충분할 것 같아요 ㅎㅎ\n\n사실 이런 기준을 정할 때 \"팀에서 합의된 것\"의 우선순위가 제일 높아서요 ㅋㅋ\n제가 가지고 있는 기준은 저희 팀에서 정리된 기준에 가깝답니다.",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/38"
    }
  },
  {
    "passed": true,
    "name": "박상수",
    "feedback": "수고했습니다! 회고를 보니 어마어마한 props들을 보면서 과제에서 뭘 말하고자 했는지 잘 이해해준것 같네요. 잘 했습니다.\n\n첫번째: 재활용되는 UI를 컴포넌트로 쪼개고\n두번째: 다루는 데이터가 각각 다른 UI를 컴포넌트로 쪼겠습니다\n\n라는 인사이트는 좋은 인사이트죠. 컴포넌트들을 어떻게 세분화하면 좋은지에 대해서도 자신만의 기준을 많이 만들어 보길 원해요.\n\nuseCart(addNotification) 처럼 hook에다가 의존성을 주입해주는 패턴도 인상적이네요. 이렇게 하면 props drilling을 최소화 하면서 필요한 의존성을 외부에서 주입받아 독립적으로 만들수도 있죠. 좋습니다.\n\n도메인과 도메인이 엮이는 case들이 있죠. 가령 지금처럼 알림과 검증과 카드의 데이터가 바뀌는 경우입니다. 이 들의 도메인 로직을 결합해주는 책임은 2군데가 있습니다. 하나는 컴포넌트이고 하나는 기능 custom hook이죠. 그리고 기능의 경우에는 지금처럼 필요하면 의존성 주입을 받을 수도 있구요.\n\n내가 가지는 도구들이 이렇게 많아진다는 건 좋은거죠. 여러가지 방법들을 이해하고 가장 적합한 방법을 잘 선택하기를 바랍니다.\n\n수고많았습니다!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/18"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "수고하셨습니다. 소연님!\n\nQ.  상품, 장바구니, 쿠폰 등의 데이터를 localStorage에 저장하고 관리하기 위해 useSyncExternalStore를 사용해보았습니다. 이번 항해를 통해 처음 알게 된 훅이라 직접 적용해보았는데, 이러한 경우에 useSyncExternalStore를 사용하는 것이 적절한 선택이었는지 궁금합니다. 혹시 더 적합한 방식이 있다면 조언 부탁드립니다.\n\nA. useSyncExternalStore를 활용해서 로컬스토리지를 연동한 것은 좋아 보입니다. 이렇게 하면 렌더링시 문제점도 많이 개선될 수 있을 것 같아요. 현재 상황에서는 적절한 방법이었다고 생각합니다. 물론 이 훅을 이용하지 않아도 정상 동작은 하게 만들 수 있겠지만 지금 코드는 좀 더 나아보입니다 :) 멋집니다. 소연님 :)\n\nQ.현재 상태관리 라이브러리(Jotai)는 알림(Notification) 상태만 관리하는 데 사용하였고, 나머지 상태는 각 컴포넌트 내부 혹은 별도의 훅을 통해 관리했습니다. 또 다른 상태들도 atom으로 관리했어야 했을지 고민이 되었습니다. 다만, 상태관리 라이브러리가 단순히 props drilling을 해결하기 위한 수단만은 아니라고 생각하고 있어서 어디까지 상태관리 라이브러리에서 관리하면 괜찮을지 의견 궁금합니다..!\n\nA. 넵 맞아요 단순히 상태관리도구는 프롭드릴링을 해결하려고 사용한다기보다는 상태들을 다루는 로직이나 비즈니스 로직을 분리해 재사용할 수 있게 만드는 역할도 큽니다. 사실 사용하기 나름이에요. 그래서 상태관리도구를 억지로 쓴다기보다는 필요할때 쓴다가 적절할 것 같아요. 일부 데이터를 다루는 로직의 재사용을 위해서, 혹은 프롭드릴링을 위해서 등 필요할 때 고려하셔도 될 것 같아요. 요즘은 React Query같은 도구로 인해 프랍드릴링도 캐싱기반의 패칭과 재가공으로 공유하기 때문에 역할이 조금  더 줄었어요.\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/9"
    }
  },
  {
    "passed": false,
    "name": "박의근",
    "feedback": "안녕하세요 의근님..!\n아무래도 시간이 부족했었던 것 같군요 ㅎㅎ\n그치만 의근님께서 하시고자 하는게 있는걸 멘토링시간에 알았기 때문에 크게 걱정은 안 되네요!!\n\n그래도 다음주 과제는 잘 수행하길 부탁드립니다 ㅋㅋ 화이팅입니다!!!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/54"
    }
  },
  {
    "passed": true,
    "name": "박준형",
    "feedback": "수고했어요 준형~ \"* 가장 고민이 많았던 부분이 props drilling 문제였습니다.\" Props Drilling vs 함수 인터페이스 명시성 결국 props로 전달하는 방식을 선택했는데, 이게 정말 올바른 선택이었는지 계속 고민했습니다.\" 준형의 회고에서 많은 고민을 해봤다는게 느껴지네요.\n\n이번 과제의 여려가지 취지 중의 하나가 이 균형감각에 대한 이해였습니다. 극단적으로 가면 props drilling의 단점이 너무 부각되고 반대로 props를 없지 전역으로만 가면 명시성을 잃고 테스트가 어려워지고 재사용성이 떨어지죠.\n\n\"이 두 가치 사이에서 어떤 것을 우선시해야 하는지 계속 고민했습니다.\" 준형의 나름의 중간 결론이 궁금하네요. 둘 중의 하나가 아니라 어떤 경우에 각 장점이 더 부각되는가가 중요합니다. 어떤 코드는 재사용과 명시성을 살리는게 더 좋고 어떤 코드는 클린함을 살리는게 더 나은가?\n\n6주차 과제 한번 더 남았죠. 이제는 이 모든 결론을 총동원하고 다른 사람의 코드들을 살펴보면서 어떤 전략이 좋은지를 생각해보고 시도해보길 바래요! 화이팅입니다.\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/5"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박창준",
    "feedback": "창준님 이번 과제도 매우 알차게 해주셨네요.\n시간을 많이 쓰지 않으셨음에도 불구하고 명확한 기준으로, 게다가 명확한 관점을 테스트하는 부분에 있어서 잘 시도하신것 같아서 좋았습니다 ㅎㅎ\n잘하셨어요. 회고에 작성해주신 부분도 보면서 저도 공부를 하게 되었던 것 같습니다. 고차 함수로 에러를 처리하는것도 좋았고 각 레이어별로 에러처리하는 것도 좋았는데, 이런것들을 동일한 관점에서 에러바운더리에서 하는것도 좋을것 같아요 ㅎㅎ\n\nQ1. 코치님은 zustand와 jotai 중 어떤 전역 상태 관리 라이브러리를 선호하시나요? 그리고 최근에는 서버 상태와 클라이언트 상태를 분리하여 관리하는 아키텍처가 선호되는데, 클라이언트 전역 상태로는 주로 어떤 상태들을 관리하는 것이 좋을까요?\n\n저는 둘 다 사용해야 하는 사례에 따라 선택하는 편인데, 사실 크게 중요했던적은 없었던 것 같아요 ㅎㅎ 둘의 핵심차이는 사실 철학차이이고 상태를 정교하게 관리하는 것이 필요하냐 안하냐의 차이인것 같아요. \n하지만, 말씀주신것처럼 요즘의 서버상태와 UI와 관련된, 예를 들어 모달이나 toast를 노출하거나 프롭드릴링이 과하게 발생하는 등 가벼운 상태만 분리하고 가벼운 상태만 전역 상태로 관리하려는 추세에서는 둘의 구성이 크게 차이가 없고 무리가 되는 부분이 없기 때문에 무난하게 선택해도 상관없을 것 같아요.\n\nQ2. 함수형 프로그래밍에 대해서 공부해보고싶어요. 코치님은 함수형 프로그래밍을 공부하신 적이 있다면 어떤식으로 공부하셨는지 책이나 방법을 추천해주실 수 있나요?\n\n저는 갠적으로 엄청 깊~~게 했던건 아니고 짧게 했던 것 같은데요.\n지금에 있어서 유효한 방식인지는 모르겠지만..\n일단 시작은 '쏙쏙 들어오는 함수형 코딩'이 설득 관점에서 큰도움이 되고(이미 설득은 되신거 같지만)\n실무적인 관점에서 적용하는 방식에 대해 많이 찾아보고 싶어서 유인동님이 생성하셨던 컨텐츠를 많이 봤던 것 같아요. 책이랑 유인동님 강의도 나온건 다 봤던 것 같은데 꽤 오래된것 같아서 지금도 유효할지는 한번 체크해봐야겠네요.\n관련해서 아시는분이 함수랑산악회 같은 활동도 진행하시면서 관련 공부를 계속하시는 것 같은데 관심있으시면 연락해드릴게요 ㅎㅎ\n추가로 영어로 되어있는 글도 당시에 꽤 많이 읽고 번역도 했던 것 같은데 결국 철학에 맞춰서 많이 사용해보는게 핵심인것 같고 어려운 개념도 많이 있는것 같아서 꾸준히 학습해야 하는거 같더라구요. 그리고 모든걸 함수형으로 작성하는게 아니라 중용해서 쓰는 자세가 중요한것 같아요!\n\n아무튼 나중에 공부하신다면...저도 방법을 좀 알려주세요~",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/40"
    }
  },
  {
    "passed": true,
    "name": "신홍준",
    "feedback": "수고했어요! 홍준 \n\n\"놀랍게도 이번 과제를 하면서 느낀 점은,,, 재밌었습니다.\n'애니 봐야지~', '게임 한 판 해야지~' 보다 '빨리 과제 해야지~' 라는 생각이 들었습니다.\n이유를 떠올려 보자면 이전 과제들과 달리 주체적으로 작업했고, 그에 따른 결과물도 스스로 만족스러웠기 때문이라고 생각합니다.\"\n\n출제자로써 너무나 만족스러운 내용이네요ㅎ 코드를 정리정돈하면서 이해도가 선명해져가는 기분은 뭔가 만들어가는 코딩에 비해 또 새로운 즐거움이죠. 그렇게 직접 해보면서 능동적인 도움을 구해가며 AI와 함께 코딩을 해보는 경험도 좋아보여요. 아주 아주 잘했습니다. 도움이 되었다니 기쁘네요!\n\n\nQ)\n아래와 같이 포맷 함수나 계산 함수를 utils 파일로 분리하긴 했는데 적절하다고 생각하진 않습니다. 당장 인자 값도 product와 같은 엔티티를 쓰고 있으며, utils로만 묶기엔 여러 역할의 함수가 있다고 생각합니다.\n\n다만 나눈다면 어떻게 나눠야 할까? 라는 생각이 듭니다. 각 도메인마다 util 파일이 존재해야 하는 건지, 그렇다면 그건 util 이라고 부르는 건 적절한지 모르겠습니다.\n\n=> 과제의 의도는 도메인에 쓰이는 순수함수와 도메인과 무관한 유틸함수의 경계를 구분하기를 바랬습니다. 도메인을 중심으로 코드를 정리하면 자연스레 비즈니스 로직과 그렇지 않은 로직을 구분할 수 있거든요. 순수함수 vs 부수효과, 도메인 vs 비도메인은 다른 관점이니까요.\n\n=> 모든 도메인에 모든 유틸이 있어야 할 필요는 없습니다. 그리고 같은 유틸스러운 코드라 하더라도 도메인이 엮이고 안 엮이고의 차이를 느껴보기를 바랬습니다. 굳이 나눈다면 도메인을 기준으로 나누는게 좋습니다. 도메인이 포함되지 않은 코드여야 라이브러리로써 다른 데서도 재사용이 가능하니까요.\n\n\n2\nForm 컴포넌트의 코드 수를 줄일 수 있는 방법이 있을까요? 아무래도 입력할 부분이 많고 그만큼 jsx 코드 길이도, 핸들러 수도 많아 Form 컴포넌트 만큼은 코드 라인 수가 길어지더라구요.\n\n=> 그래서 react-hook-form과 같은 form 전용 훅을 사용하게 되죠. 홍준과 같은 고민을 이미 많은 사람들이 해봤을 거에요. 다양한 form을 다루는 hook 라이브러리들을 살펴보면서 이런식으로도 해볼 수 있구나 하는걸 느껴보면 좋겠어요.\n\nps. 과제 채점 빼먹어서 미안해요!! ^^;\n\n\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/1"
    }
  },
  {
    "passed": true,
    "name": "신희원",
    "feedback": "안녕하세요 희원님!\n5주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다.\n희원님의 1주일이 세세하게 느껴지는 것 같아요 ㅋㅋ\n\n> 🔍 localStorage와 React State 동기화 딜레마\n\n이건 3주차 과제의 useStorage도 한 번 참고해주시면 좋겠어요!\nstorage의 변경을 storage를 사용하고 있는 컴포넌트에게 전파하는 과정이 필요하답니다 ㅎㅎ\n\n> Q1. 제가 위에 배워가는 과정에 작성한 내용이 맞는 내용인지 궁금합니다! (혹시나 틀린 개념이 있거나 더 추가보완해서 설명해주실 것이 있다면 말씀 부탁드립니다.)\n\n작성해주신 내용은 정확하다고 생각해요! 제가 위에 언급한 것 처럼, setState와 useEffect 말고도 useSyncExternalStore 같은걸 활용하는 방법이 있답니다 ㅎㅎ\n\nhttps://github.com/hanghae-plus/front_6th_chapter1-3/pull/13\n\n특히 영서님의 PR에 자세하게 나와있답니다!\n\n> Q2. 과제 관련한 질문은 아니지만, 현재 항해를 5주차 진행했는데요. 남은 기간동안 취업을 위해 무엇을 하면 좋고, 남은 항해과정을 어떻게 나아가면 좋을지... (교육을 더 잘 흡수하기 위한 꿀팁같은게 있을지..) 궁금합니다!\n\n일단 10주차까지 학습을 꾸준히 하는게 제일 중요하겠죠!?\n끝난 후에는 여태까지 했던 과제를 한 번 더 풀이해보세요 ㅎㅎ\n그리고 이전보다 더 깊게 여유를 가지고 고민을 해보는 과정이 필요합니다.\n\n특히 다른 사람이 작성한 코드에 대해 많이 살펴봐주시면 좋겠어요.\n솔루션에 있는 코드도, 과제가 제공하는 환경도, 하나하나 다 소개해드리진 못했지만 알아가면 좋겠다고 생각한 내용을 최대한 꾹꾹 눌러서 담았답니다!\n\n어쨌든, 취업까지 도달하기 위해 가장 중요한건\n1. 꾸준히 하는 것.\n2. 꾸준히 하는 모습을 알아봐줄 사람을 곁에 두는 것.\n3. 이력서를 작성하는 것.\n\n그리고 1~3보다 더 중요하게 생각하는 한 가지가... 나에 대해 알아가는 것 이라고 생각해요 ㅎㅎ\n\n내가 무엇을 좋아하는지, 무엇을 하고싶은지, 어떤 조직에 어울리는지 등!\n\nhttps://www.yes24.com/product/goods/51092531\n\n표현적 글쓰기 라는 책인데요, 커리어를 위한 활동보다 나 자신에 대해 알아가는 활동이 더 중요하다는 것을 다루고 있답니다!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/36"
    }
  },
  {
    "passed": true,
    "name": "양성진",
    "feedback": "안녕하세요 성진님! 5주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> Jotai atom에 이렇게 복잡한 비즈니스 로직을 넣는 게 괜찮은건가요? 아니면 별도 service 가 있어야 하나요? 우선 큰 틀안에서 하나에 넣고 관리를 했는데... 뭔가 상태와 로직을 따로 분리해야할까 고민을 했었습니다.\n\nservice라기보단, atom의 로직을 별도의 순수함수로 분리해서 다루면 어떨까 싶어요 ㅎㅎ\n\ncomponent -> hook -> atom -> function\n\n더 극단적으로 생각해보자면... jotai대신 zustand나 redux로 바꾼다고 했을 때 어떻게 해야 최소한의 비용, 최소한의 수정으로 교체가 가능할지 고민해보시면 좋답니다 ㅎㅎ\n\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/13"
    }
  },
  {
    "passed": false,
    "name": "양창훈",
    "feedback": "안녕하세요 창훈님! 5주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다.\n다만 테스트 코드가 실패하고 있네요 ㅠㅠ \n과제 회고에도 언급해주셨지만, 아마 useProducts() 를 양쪽에서 만들어서 사용하고 있어서 발생하는 문제일 수 있어요.\n전역상태를 사용하지 않고 문제를 해결하는게 기본과제이고 jotai라는 상태관리 라이브러리로 이 때의 불편함을 해소하는게 심화과제였어요..!\n\n여튼, 기본과제에서의 방법은 최상위 레이어(App)에서 다 props로 내려보내주는 모습을 상상해보시면 좋아요..!\n\n---\n\n다음주 과제는 끝까지 완수하기를 기원합니다! 화이팅!!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/22"
    }
  },
  {
    "passed": true,
    "name": "여진석",
    "feedback": "수고했어요 진석. 진석이는 이번 과제에서 개발자들이 뭔가 배우고 있고 한창일때 많이 실수하는 함정에 빠진것 같아요. 이번 챕터의 핵심은 분명 클린코드와 리팩토링이었고 결합도를 낮추면서 이전보다 더 나은 코드를 점진적으로 만들어가는 것인데 뭔가 재설계나 확장이나 방향등 조금은 다른 곳에 관심이 꽃힌 것 같네요.\n\n한번 실무에서 리팩토링을 나에게 맡겼는데 본인이 진행했던 방법들을 다른 사람에게 보여준다고 생각해보세요. 기존에 업무를 하던 사람에게는 완전히 다 헤집어 놓은 꼴이 됩니다. 게다가 갑자기 더해진 개념도 많아요. URLSearch나 zod나 전에 없던 검색 필터링 요구사항이 추가된다거나 하는식으로요.\n\n클린코드란 완벽히 뭔가를 하는 그런게 아니에요. 지금보다 더 나은 코드와 이해가능하고 일관성있는 코드를 제공하고 싶은거에요. 이번 과제의 취지와 방향성은 거대한 컴포넌트를 사람이 이해하기 좋은 수준으로 적절히 잘라내고 그 과정에서 벌어지는 props drill 문제를 해결하면서 코드를 정돈하는데 있어요.\n\n지금 진석이가 작성한 코드 중 ProductAccordion이라는 이름이 있는데 이 컴포넌트에서 상품 편집 시작, 추가, 취소 제출, 삭제의 책임을 가지고 있어요. 분명이 컴포넌트이름은  ProductAccordion으로 뭔가 상품펼접이라는 다분히 UI성 이름인데 말이죠. \n\n의도하고자 했던 기존의 로직을 유지하면서 코드를 정돈하는 과제는 많이 진행되지 않았네요. ProductForm등에서 쓰이는 인라인 핸들러등도 그대로 있고 submit에서 검증은 하고 있는데 submit 이후 책임은 외부로 위임하고 있어요.\n\n\"실무에서는 완벽히 클린코드를 사용하기는 어렵다고 생각합니다.\" 에서 완벽히는 결과가 아니라 방향성이에요. 소프트웨어 공학에서 말하는 더 일관되며 가독성이 높으면서, 더 결합도가 낮아지고 응집도가 높아지는 방향으로의 코드를 만들어 가고 있는데 과정이 클린코드를 사용하고 있는거지요.\n\n이러한 관점에서 다시 한번 확인해보면서 특히나 함께 일하는 프로젝트를 내가 리팩토링을 한다는 개념으로 접근해보세요. 반대로 함께 일하는 프로젝트의 리팩토링을 누군가가 이렇게 해온다면 어떤 느낌일까라는 식으로 한번 과제를 다시 살펴보기를 바래요.\n\n이 또한 학습이 될거라고 생각합니다. 수고하셨습니다 :)\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/2"
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "안녕하세요 찬규님! 5주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 배럴파일 사용하면서 고민했던 점: 순환 의존성 문제와의 씨름 처음에는 모든 도메인에서 배럴파일을 무분별하게 사용하다가 순환 의존성 문제를 마주했습니다.\n\n맞아요. 배럴파일을 사용할 때 이런 문제를 마주할 수 있답니다 ㅎㅎ\n\nhttps://www.npmjs.com/package/madge\n\n이런 라이브러리를 사용하면 아예 순환의존성을 검사할 수 있답니다!\n\n> 현재의 타입별 분류가 맞는 접근일까요? 아니면 notification처럼 관련성이 높은 기능들은 어느 정도 묶어두는 게 나을까요?\n\nshared/ui/notification\n\n이런 폴더를 하나 만들어서 다 몰아넣으면 어떨까 싶어요 ㅎㅎ \n\n아니면 아예 components/Notification 에 몰아넣는다거나?\n\n결국 공용 컴포넌트로 쓰이는거니까요!\n\n> \"공통 기능\"의 경계를 어떻게 정의해야 할까요? Toast, Modal 같은 것들도 notification과 비슷한 딜레마에 빠질 것 같아요.\n\n저라면 아마\n\ncomponents/Toast/types.ts\ncomponents/Toast/hooks/use....ts\ncomponents/Toast/utils/...\ncomponents/Toast/ToastProvider\ncomponents/Toast/Toast\n\n이런식으로 컴포넌트 영역에 분리시켜놓을 것 같아요!\n그 다음에 componund 방식으로 묶어서 사용하는거죠\n\n---\n\n이번주 멘토링 시간이 스쳐지나가네요. 꼭 현재 상황 잘 해결했으면 좋겠어요. 응원합니다 찬규님!! 화이팅!!\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/53"
    }
  },
  {
    "passed": true,
    "name": "오하늘",
    "feedback": "고생하셨습니다 하늘님 ㅎㅎ\n이번 과제를 진행하면서 배우셨던 많은 내용들을 글로도 작성해주시고 다른 분들께 공유도 해주신 점 너무 멋지네요.\n공통 컴포넌트를 확장성 있는 컴포넌트로 구성하기 위해 공통 컴포넌트를 작성하신 경험도 나눠주신것도 좋고 AI 개입을 줄이고 직접 작성해보신 것도 오히려 과제의 퀄리티를 높이는데 좋은 영향이 있었던 것 같네요 ㅎㅎ\n\n질문 주신 것 답변 하고 마무리 해볼게요 \n\n> 제가 컴포넌트를 크게 쪼갰을까요?\n\n절대적인 코드라인 수 기준을 만드는건 개인적으로는 선호하지 않는 것 같아요. 여기서 저희가 말하는 일반적으로 강조하는 기준들이 등장하는데요. 가독성, 재사용성, 유지보수성 뭐 이런것들이요! 이런것들을 지키기 위해서는 단일 책임원칙을 지켜서 하나의 컴포넌트에서 하나의 책임을 명확하게 갖도록 하는게 이상적이죠. 지금의 컴포넌트에서는 Input들에 들어가는 여러 로직들이 많이 복잡한데(가공을 해서 넣는다라거나..) 이런 부분들을 분리해서 관리해보고 그리고 컴포넌트 관점에서 공통적으로 분리할 수 있는, 재사용 할 수 있는 컴포넌트는 없는지 고민해봐도 좋을것 같아요 ㅎㅎ \n\n> Jotai vs Zustand\n\n저는 둘 다 사용해야 하는 사례에 따라 선택하는 편인데, 사실 크게 중요했던적은 없었던 것 같아요 ㅎㅎ 둘의 핵심차이는 사실 철학차이이고 상태를 정교하게 관리하는 것이 필요하냐 안하냐의 차이인것 같아요. \n하지만, 요즘의 서버상태와 UI상태를 분리하고 가벼운 상태만 전역 상태로 관리하려는 추세에서는 둘의 구성이 크게 차이가 없고 무리가 되는 부분이 없기 때문에 무난하게 선택해도 상관없을 것 같아요.\n다만, 위에서 언급한것처럼 둘의 핵심차이는 철학 차이이니까 해당 부분을 공부해보는건 필요할것 같아요!\n\n고생하셨고 다음주도 화이팅입니다~",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/15"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "수고하셨습니다. 윤우님!\n\nQ. hint 쪽에 selectedCoupon이 useCart에 위치한다고 되어있는데 저는 useCoupon이 더 엔티티에 적합하지 않을까 생각해서 이동했습니다! selectedCoupon의 위치가 cart인 이유가 궁금합니다!\n\nA. 제생각에 테오님의 의도는 useCoupon은 말그대로 쿠폰 자체를 관리하고, 카트는 그 쿠폰중에 무엇이 적용되고 있는지를 나타내려고 했던 것 같습니다~ 사실 뭐가 어떤 답이 있다기보다는 각자의 의도대로 만들어도 될 것 같은데요. 저도 이렇게 구성할 것 같아요~\n\nQ. hooks에 Context를 이용해 각각의 엔티티로 나누어두었습니다. 근데 엔티티끼리 연관이 있다보니 훅내부에서 훅을 부르는 의존성이 생기는데 괜찮을까요? 예시로는 훅 내부에 useNotificationActions을 불러 toast 처리를 한다던가, cart쪽에서 coupon 내용이 필요해 부른다던가.. 만약 괜찮지 않다면 더 나은 방법이 있을까요??\n\nA. 괜찮습니다 :) 훅에서 훅 의존성 가져도 됩니다. 방안은 어차피 훅을 재사용하느냐 훅안에서 사용하는 함수들을 분리해서 재사용하느냐의 차이인 것 같아야. 다르게 말하면 훅으로 추상화된 것을 사용하느냐, 원재료를 재사용하느냐의 차이입니다. 이건 답이 있다기보다는 윤우님의 레이어를 어떤 의도를 가지고 구성했느냐가 중요할 것 같습니다~\n\nQ. 단순히 productId를 이용해 Cart item을 가져오는 함수입니다. 내부적으로 사용하는건 find 메서드뿐인데 여러 액션함수에서 사용됩니다! 이런것도 엔티티 함수로 분리하는게 좋을까요?\n\nA. 일단 단순하지만 getCartItemByProductId로 한 번 추상화해서 사용한다는 것 자체가 많은 장점이 있다고 생각해요 일단 함수명을 통해 읽기가 수월해지고요. 나중에 일 부 기능이 변경될때 한 번에 수정할 수 있다는 장점도 있고요 :) \n\nQ. 검증에 관련된 순수함수들을 좀 분리해볼까 생각했었는데요 아래와 같은 함수도 \"재고\"에 관련된 검증함수니까 엔티티함수로 빼야하는걸까요 아니면 순수함수인 validators 일까요?\n\nA. 순수함수라는 것이 사이드이펙트 없는 순수함수를 말씀하시는 걸까요?  엔터티에서도 순수함수를 만들 수 있을 것 같은데요.. 제가 질문의 의도를 잘 이해하지 못한 것 같습니다.  ",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/6"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "윤영서",
    "feedback": "크.. 멋쟁이 영서님. 5주차도 너무 고생했어요!! 여러가지 개인적인 일도 많이 겹쳤을텐데 그럼에도 불구하고 너무 잘 해주셨네요 ㅎㅎ 지난주에도 했던 말인데, 존경합니다.\n\n> CartItem에서 Product라는 도메인이 들어와있는것을 피하기 위해 이를 평탄화된 타입으로 가져가게 되었다고 위에서도 언급을 했는데, 사실 Cart라는것은 클라이언트에서 생성되는 데이터 타입(상품과 할인은 어떻게 잘 조합한)이고, 만약 좀 더 확장한다면 해당 장바구니의 내용에 어떤 상품인지, 어떤 쿠폰을 적용시켰는지에 대한 정보가 들어갈 수 있다고 생각하는데요. 그렇게 확장이 된다면 Cart의 타입에는 비롯 상품의 타입뿐아니라 쿠폰 타입 기타 등등이 들어갈 수 있을 것 같습니다. 그렇다면, Cart는 사실상 클라이언트에서 조합을 해서 만들어내는 객체니 이를 features로 분리하는 것이 맞았을까요? 계속 고민이 되는 것은, Cart가 어떻게보면 존재할 수 있는 객체라고 생각했기때문입니다. 만약 Cart에 저장할 수 있는 데이터가 확장이 된다고 하면... Cart는 어떤 폴더에 놓이는게 좋은 선택일까요?\n\n저는 그냥 현재 상황을 유지해도 좋다고 생각해요 ㅎㅎ\n완전히 독립적으로 쓰이는게 사실 논리적으로 불가능에 가깝기도 하고,\ncart가 다른걸 의존하는게 부자연스러운건 아니라서요.\n\n대신 use-case 라는 폴더를 하나 만들어서 관리할 것 같아요.\nuse-case는 각각의 entities에 대한 개별 로직이라기보단, 전체 entities의 소통을 총괄하는 역할인거죠.\n\n가령, 사용자 시나리오를 토대로 생각해보자면\n\n\"사용자가 A라는 제품을 장바구니에 추가한다\" 를 useCase로 만들고, 여기서 쓰이는 모든 로직과 개체를 가져다 조합하여 사용하는 그런 방식입니다.\n\nuseCartUseCase 가 있고, 이 UseCase에서 cart, product, coupon 등을 조합하는거죠.\n\n그래서\n\nfeatures/\n  cart/\n  \tentities/\n\tuse-case/\n    useCartUseCase\n\n요로코롬 사용할 수도 있고\n\n혹은\nfeatures/\n  \tcart/\n\t\tentities/\n\t\tuse-case/\n\t\t\tuseCartUseCase\n\t\thooks/\n\t\t  useCart\n\n요로코롬 쓰일 수도 있다고 생각해요\n\n> 계속 고민이 되었던 부분은 거의 비슷한 방향이었는데요. 만약 apply-coupon, delete-coupon과 같은 기능을 '쿠폰 관리'에 초점을 맞추어 manage-coupon과 같이 분리하게 된다면...너무 manage-coupon에 많은 책임이 들어가는것이 아닐까?하는생각이 들었습니다. crud에 맞춰 분리를해야할지 아니면 알잘딱깔센하게 분리해야할지...\n\n이것도 위와 동일하다고 생각해요. useCouponUseCase 같은걸 만들어서 사용하는거죠!\n\n---\n\n이번주도 고생하셨어요!! 남은 기간도 화이팅입니다~!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/4"
    }
  },
  {
    "passed": true,
    "name": "이가은",
    "feedback": "아주 잘했어요 가은. 뭐랄까 아직 다 완성을 안해서 결과는 아쉬운 점이 보이지만 나쁜 습관없이 했기 때문에 이대로 끝까지 했을때의 결과가 기대되는 그런 모양새입니다. 본인이 하나씩 생각하면서 해서 그런걸수도 있고 너무 개념적으로 deep하게 접근해서 오버엔지니어링의 함정에 빠지지 않았네요.\n\n순수함수는 모든 인자를 명시적으로 외부에 위임을 하기 때문에 테스트가 쉬워지고 독립성을 유지합니다. 하지만 이렇게 만들었다가는 컴포넌트나 상태를 관리하는데 props의 지옥을 맛보죠. 인자가 1-2여야지 이렇게 많아서는 관리가 어렵습니다. 그래서 인자를 생략하거나 내부에서만 접근할 수 있는 상태를 만들어서 DX를 향상하죠.\n\n어찌보면 이 둘이 양립하는게 어려워 보일 수 있습니다. 둘의 지향점과 컨셉은 완전히 다르니까요. 하지만 코드는 하나의 관점만 가지고 작성하는게 아니니까 어떤 관점의 코드가 더 잘 어울리는지는 맥락에 따라 다릅니다. 우리는 여러개의 도구와 관점을 가지고 적재적소에 쓰는 법이 중요합니다. 숟가락과 젓가락의 쓰임이 다른 것 처럼 말이죠.\n\n끝까지는 해봤으면 좋았겠다 싶네요. 그러면 뭔가 더 확실히 알았을지도 모르겠습니다. 코멘트에 적어둔 뭔가 해볼 수 있을 것 같은데? 라고 느꼈는데 완벽한 뭔가를 떠올리려고 하지 말고 지금보다 더 나아지는 방향으로는 개선을 해보면 좋을거에요. 일단 핸들러라도 밖으로 꺼내보는건 어떘을까요? 그리고 굳이 지금의 코드에서 문제가 없다면 과한 분리는 오히려 복잡도를 높일 뿐이에요.\n\n\"... 해결이 안될거라 판단되어 보류하였습니다.\" 라는 건 좋은 판단입니다. 그렇지만 \"...처음에는 단순히 이벤트 헨들러로 분리할까 했지만 ...\" 이라고 생각한것도 실행한것도 좋았을 것 같아요. 완벽이 아니라 지금보다 더 나아지는게 중요하니까요.\n\n수고했습니다. 아쉬움과 인사이트는 6주차 과제에서 꼭 결자해지 해보기를 바래요! 수고하셨습니다.\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/24"
    }
  },
  {
    "passed": true,
    "name": "이민재",
    "feedback": "수고했어요! 이번 과제는 결합도를 낮추는 방법을 이해하고 코드에서 제어하기 쉬운 순수함수를 분리하고 대형 컴포넌트들을 관리가능한 수준의 크기로 분리를 해보는 과제였습니다. 시행착오의 과정에서는 폴더구조에 대한 고민이 많았었군요. 잘했습니다.\n\n왜 이렇게 폴더구조를 만드는가? 생각을 해보면 결국 코드에 하나의 책임만 두는게 이해하기가 더 쉽다는 것을 느낄수있고 단일 책임이라는 것을 무슨 기준으로 분리해낼까 고민하다보면서 순수함수, 엔티티, 파생 데이터, UI 로직 유틸등의 체계가 생겨났지요. \n\n하지만 결국 분리를 하더라도 하나의 서비스가 되기 위해서는 서로에게 필요한 의존성등을 정돈하고 단방향의 데이터 흐름을 유지하도록 만들어야 하는데 지금의 코드에서는 분리한 체계가 일관성이 없어서 결합도가 완전히 낮아지는 방향이 되지는 못했습니다.\n\n추상화의 수준을 어떻게 맞출수 있을지? 무엇은 props로 빼어서 재사용과 유연함을 보강하고 무엇은 내재화해서 함께 관리하는게 좋을지라는 측면을 한번 잘 고민해보시면 좋겠네요.\n\nQ) 프로젝트 초기에 아키텍처를 설계하시거나, 프로젝트 규모에 따라서 다시 재설계를 하실때 어떤 순서로 접근하시는지 궁금합니다! 만약에 프로젝트 규모에 따라서 재설계를 한다면 점진적으로 개선하는 전략이 있으신지 궁금합니다!\n\n=> 가급적 코드에서 관리하기 어렵지 않은 부분과 관리하기 어려운 부분들을 분리하는게 중요합니다. 관리가 어려운 부분은 상태이고 상태란 현재의 값이 보관되고 수정이 되는 과정에서 값의 변경이 계속 있기 때문에 어려워지는 것이죠.\n\n반면 계산이나 데이터 UI 등은 상태가 아니기에 관리하고 테스트하기에 수월한 코드입니다. 이러한 코드들을 분리해두면 거대한 프로젝트라도 실제 복잡도를 관리해야하는 코드의 양이 줄어드는 것이죠. \n\n이렇게 분리를 잘 해두고나면 개발하는 과정에서 자주 쓰이는 것들끼리 서로 관련있는 것들끼리 조금씩 모아가는 과정을 만들게됩니다. 이렇게 컨벤션이 잡히게 되면 다음번에는 알아서 그 컨벤션에 따라 관리를 하다가 새로운 레이어나 모듈의 영역이 발견이 되게 되면 또 분리를 진행하는 식으로 진행하게 됩니다.\n\n\nQ) Feature 컴포넌트(ProductList, CartSidebar)의 적절한 책임범위는 어디까지일까요?? UI만 담당해야 할까요?? 아니면 해당 도메인의 비즈니스 로직까지 포함해도 될까요??\n\n=> features는 하나의 기능이 되기 위해 필요한 모든 범위를 말합니다. 가령 zep에서는 화상회의, 채팅, 캐릭터, 지도등의 큰 기능들이 있죠. 화상회의를 하기 위해서는 라이브러리, UI, 행동, 데이터 모두가 필요합니다. 하지만 이는 features로 분리해두면 관리하기가 훨씬 좋겠죠. 아마 캐릭터이동이라는 기능과 겹치는 부분이 별로 없을테니까요.\n\n=> 그렇다고 feature가 이렇게 커야하는건 아니구요. 적절한 책임 범위란 이들을 레이어나 역할로 펼쳐두는 것 보다 모아두는게 더 낫다고 판단되는 경우입니다. 절대적인 기준은 없고 프로젝트의 논리와 사람들이 프로젝트에 대해서 어떠한 추상적인 표현들을 쓰는가에 따른 멘탈 모델이므로 그에 따라 적절히 사용하면 됩니다.\n\n=> 잘 했는지 여부는 굳이 features로 나눴더니 더 불편해졌다면 잘 못된 방식이고 이로 인해 생각하기가 더 편해졌다면 좋은 방식이라는걸로 기억해주세요.\n\n수고하셨습니다. 6주차 과제도 화이팅입니다.\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/25"
    }
  },
  {
    "passed": true,
    "name": "이유진",
    "feedback": "유진님 고생하셨습니다~\n회고를 읽어보니까 과제를 진행하시면서 단순히 개선만 하는게 아니라 어떤 기준으로 어떻게 코드를 분리해야 하는지 고민을 깊게 하신 것 같아서 좋네요!\n전반적으로 과제는 잘 진행해주셨는데요. 질문주셨던 부분에서 notification에 대해 상태를 공유해야 하는 부분에 대해서 고민이 많으셨던 것 같은데요.\n말씀해주신대로 이상적인 상황에 있어서는 사실 각 커스텀 훅에 인자로 넘겨주고 의존성을 갖게 하면 좋지 않은 관점은 있는것 같아요.\n가장 아름답게 각각의 로직을 분리하고 합쳐서 사용하는 방식으로는 이벤트 드리븐 아키텍쳐를 쓰거나.. 고차 훅 패턴 같은것들을 써서 분리를 할 수는 있을 것 같은데요. 지금의 구조에서는 해당 동작이 단순하고 분리의 비용이 더 클 수 있어서, 그리고 전역 상태 라이브러리를 사용할 수 있으니 훅에서 주입을 받아 사용하기 보다는 해당 상태에 접근해서 개선을 하면 충분하지 않을까 싶네요!\n\n고생하셨고 다음주도 화이팅입니다!~~",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/17"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이은지",
    "feedback": "안녕하세요 은지님!\n5주차 과제 너무 잘 진행해주셨네요!!\n여태까지는 결과 위주의 글을 작성했다고 말씀해주셨는데,\n과정이 정말 디테일하게 담겨있어서 깜짝 놀랐답니다 ㅎㅎ\n기승전결이 다 녹아있다고 느껴졌어요.\n\n> 제가 선택한 컴포넌트 분리 수준이 적절한지 궁금합니다. 더 세분화해야 하는 부분이나, 반대로 과도하게 분리한 부분이 있을까요?\n\n무척 분리를 잘 해주셨어요 ㅎㅎ\n여기서에서 조금 더 나아가보자면, Primitive Component 를 추출하는 과정이 필요할 수도 있다고 생각해요. 다만 필수는 아닙니다!\n\n가령, Input, Button 처럼 제일 하위에서 쓰일 수 있는 컴포넌트랄까!?\n지금 icon이 이런 역할을 수행하고 있네요!\n\n> 아이콘 추가될 때마다 type과 객체에 추가해줘야 하는 것이 불편합니다. 더 효율적으로 아이콘 컴포넌틀를 관리할 수 있는 설계 구조가 없을지 추천해주세요!\n\n`svgr` 이라는 키워드로 찾아보시면 좋답니다 ㅎㅎ\n가령, vite에서는 https://www.npmjs.com/package/vite-plugin-svgr 을 사용해볼 수 있어요.\nsvg 파일을 아예 컴포넌트로 관리할 수 있도록 해주는거죠.\n\n혹은 디자인 시스템들이 어떻게 구현되어있는지 참고해보면 좋답니다!\n\nhttps://www.chakra-ui.com/docs/components/icon-button\nhttps://www.chakra-ui.com/docs/components/icon#custom-svg\n\n> 제가 시도했던 에러 기반 알림 시스템이 실무에서도 시도해볼 만한 패턴인지, 혹은 다른 더 나은 전역 알림 처리 방법이 있는지 궁금합니다.\n\n굉장히 체계적으로 설계를 잘 해주셨어요!\n제가 이해한 부분은, throw를 통해 NotficiationBoundary 에 메세지를 쌓아가는 방식이라고 이해했어요.\n다만, 조금 아쉬운 부분은 success를 처리하는 부분도 throw로 처리하고 있다는점!?\n\n그래서 context를 조금 엮어서 사용해주면 어떨까 싶어요!\nthrow를 통해 쌓아가기보단, 아예 context api를 통해 상위 계층으로 메세지를 보내서 알림을 쌓아가는 방식으로 해결할 수 있지 않을까 싶네요 ㅎㅎ\n\n결국 \"에러를 에러처럼 사용 하는 것\" 이 제일 중요하다고 생각해요!\n\n\n\n\n\n\n\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/44"
    }
  },
  {
    "passed": true,
    "name": "이의찬",
    "feedback": "안녕하세요 의찬님!\n\n회고가 전체적으로 인상적이네요 ㅎㅎ\n\n로직을 분할했다가 다시 합치는 과정도, 다른 사람들의 코드를 참고하는 과정도, AI를 통해 난이도를 조절하는 과정도.\n의찬님의 모든 고민이 잘 느껴져서 좋았어요\n\n> 함수 분리 기준: 코치님은 어떤 기준으로 함수를 분리하시나요?\n\n저는 재사용을 하기 위함도 있지만, 추상화 수준을 정렬하기 위해 분리하는 경우가 많은 것 같아요 ㅎㅎ\n\n가령\n\n```tsx\narray.find();\nfilterXXX();\n```\n\n이런 형태로 되어있을 때, array.find()는 날것의 코드로 표현이 되어있고, filterXXX()는 한 단계 더 추상화가 되어있습니다.\n이럴 때 아예 findXXX, filterXXX 처럼 추상화를 정렬시키기 위해 분리시키는거죠 ㅎㅎ\n\nhttps://junilhwang.github.io/TIL/clean-code/%EC%A1%B0%EA%B0%81%EB%AA%A8%EC%9D%8C/%EC%B6%94%EC%83%81%ED%99%94%EB%A5%BC-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/\n\n그래서 이런 글도 작성했답니다!\n\n> Jotai 적용 범위: productForm과 couponForm에도 Jotai를 적용했는데, 객체로 묶어서 props로 전달하는 것이 더 나았을까요?\n\n이왕 사용하는김에 적극적으로 사용하는 모습이 좋다고 생각해요 ㅎㅎ\n다만, 공용화해서 사용해야 한다는 전제가 있다면 props로 넘겨주는게 좋을 것 같습니다.\n\n> 액션 함수 처리 방식: 클로저 vs 명시적 매개변수 전달 중 어떤 방법을 선호하시나요?\n\n흠... 이건 어떤 의미인지 이해하기가 어렵네요 ㅎㅎ\n구체적인 코드가 필요할 것 같아요.\n이건 따로 디스코드에 문의 남겨주시면 답변드리도록 하겠습니다!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/46"
    }
  },
  {
    "passed": true,
    "name": "이정우",
    "feedback": "수고했어요 정우, 잘했습니다! \n\nQ) atoms등이 한 곳에 모여있는 것들과 아닌 것들에는 장단점이 있습니다. atom이 한 곳에 모여있으면 전체적으로 어떤 데이터들이 사용되는지를 코드에서 한눈에 파악할 수 있습니다. 만약 atom읙 개수가 많지않고 전체적인 코드에서 큰 비중이 없다면 한 곳에 모아두는 것도 좋은 선택입니다.\n\n지금의 경우에는 도메인을 전연상태관리로 나눈것이기에 각 atom들이 서로 연관성이 있게 쓰이지 않습니다. 생각해보면 atom이 쓰이는 곳은 useAtom이 유일한데 그 곳이 useCart useProduct에서만 사용되고 있으니 그 쓰임이 가장 가까운데 두는데 좋다는 원칙에 따라 자연스럽게 도메인 별로 모듈화 되는 방향으로 놓이게 됩니다.\n\nQ) 할인 계산 로직을 cartModel 레이어까지 더 분리한다면 테스트 용이성이 높아질지 궁금합니다.\n\n=> 네 순수함수로 분리를 하는 만큼 확실하게 얻을 수 있는 이득입니다. 대신 잘게 쪼갤수록 props가 늘어나고 모듈화를 하기가 어렵다는 단점이 있습니다. 이런건 직접 해보면서 느끼는 게 제일 좋죠! 간단한 궁금증이 생길때에는 AI를 통해 코드를 구현시켜보고 직접 몸으로 느껴보면 큰 도움이 됩니다. 코딩은 이론보다도 감각적인 부분이 있거든요. 수고하셨습니다. 6주차 화이팅입니다!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/51"
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "안녕하세요 지현, 수고했습니다! 이번 과제는 컴포넌트를 도메인 관점으로 분리하고 props drilling 문제를 해결하면서 함수형 프로그래밍의 순수함수 개념을 체득하는 것이 목표였어요. 지현이 작성한 회고를 보니 정말 많은 고민과 시행착오를 거치면서 과제의 핵심을 제대로 파악하고 경험했다는 게 느껴지네요.\n\n특히 \"프롭드릴링의 끔찍함\"을 직접 경험하고 사이다 오백만병을 찾고 싶었다는 표현이 정말 와닿았어요. 저도 과제 솔루션 다시 만들면서... 내가 왜 이걸 느껴보라고 했을까 하면서 답답함을 느꼈답니다. \n\n그리고 흐름을 따라갈 수 있다는 관점에서는 프롭드릴링 좋다는 생각을 했었고, 컴포넌트 관리나 복잡성을 줄이기 위함에서는 jotai가 월등히 좋은 것을 체감했다는 측면에서 과제의 취지는 다 해줬다고 생각했는데...\n\n정작 코드를 보니 아직 불필요한 props사용등이 많아 보였어요. 생각해보면 props도 interface를 가지게 되는데 interface는 많거나 복잡한 것이 곧 프로젝트의 복잡도를 나타내거든요. 가급적이면 이러한 props interface를 줄이거나 통일하거나 일관성있게 만들 수 있는 방향으로 고민을 해보면 좋겠어요.\n\n프롭드릴링이 좋은 것과 전역상태관리의 장점을 둘 다 취해서 mix하는 방향은 어떤 방향일까를 6주차 과제에 잘 녹여보길 바래요.\n\nQ) models과 service의 역할 구분에 대해서\n=> 지현이 고민한 대로 models는 데이터 중심의 순수한 계산(매핑, 포맷팅, 단순 변환)을 담당하고, service는 비즈니스 로직과 모델 함수들의 조합을 담당하는 게 맞습니다. 쉽게 말해 models는 \"무엇\"을 다루고 services는 \"어떻게\"를 다룬다고 생각하면 돼요. 예를 들어 cart model에서는 아이템 찾기, 수량 가져오기 같은 단순 작업을, cart service에서는 재고 확인하고 할인 적용하고 에러 처리하는 등의 비즈니스 규칙을 담당하는 거죠.\n\nQ) 커스텀 훅이 커진 것에 대해서\n=> DDD 방식으로 도메인에 응집시키다 보니 훅이 커진 건 맞습니다. 하지만 \"한 곳에서 많은 일을 한다\"와 \"도메인 응집도가 높다\"는 다른 개념이에요. 일부는 컴포넌트에서만 동자갛는 로직이라 훅에 포함되지 않을수도 있고 어떤 로직은 다른 기능들을 복합적으로 사용해야하기에 외부에서 조립하도록 만들어야 했을 수도 있어요.\n\n=> 커스텀 훅이 모든 기능을 다 아우러야 한다기 보다는 추상화 이면으로 숨겨도 괜찮을 것들 - 너무나 당연히 예측이 가능 동작 - 들을 숨긴다라고 생각해보면서 그 접점을 잘 찾아가 보기를 바래요.\n\n=> 과제는 그렇지 못하지만 실전에서는 코딩하면서 이 안의 내용들이 궁금해 한다거나 디버깅을 하는 과정에서 왔다 갔다를 많이 하는 걸 경험하게 되면 좋은 구조가 아니구나 이렇게 판단하는 징조로 활용해보세요.\n\n6주차 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/32"
    }
  },
  {
    "passed": true,
    "name": "이지훈",
    "feedback": "안녕하세요 지훈님!\n역시 믿고 보는 지훈님의 과제네요 ㅎㅎ\n\n> 순수 함수에서 다른 순수 함수(a)의 계산 결과가 필요할 때, a의 계산 결과를 인자로 받는 것이 좋을까요? 아님 함수 내부에서 a 함수를 호출하는 것이 좋을까요? 함수 내부에서 a 를 호출하는 것이 더 간단한 방법처럼 보이는데, a 가 아닌 다른 함수를 호출해야 하는 상황이 발생했을 때 함수 내부의 코드를 수정해야 하는 부분이 좋지 않은 패턴처럼 느껴지기도 하는 것 같습니다.\n\n특별한 경우가 아니라면 a의 계산 결과를 인자로 받는게 좋지 않을까!? 라는 생각이 들어요 ㅎㅎ\n혹은, 두 가지를 모두 처리하는 모습이어도 무방할 수 있답니다.\n\n가령 Number 함수의 경우\n\nNumber(\"1\")\nNumber(1)\nNumber(new Number(1))\n\n이런식으로 여러가지 형태를 받아서 처리할 수 있어요.\na를 전달할 때 a를 만들어내기 위한 인자를 전달하거나 a 자체를 전달하는 등 두 가지 일을 모두 수행할 수 있는 함수를 만드는거죠 ㅎㅎ\n어떻게보면 단일책임 원칙에 위배된다고 느껴지기도 하는데,\n\n책임을\n  - 변환하는 함수\n  - 계산하는 함수\n  - 결합하는 함수\n\n이런식으로 분산해서 사용할 수 있을 것 같아요!\n\n> 컴포넌트 이름 짖는 것이 어렵게 느껴집니다. 컴포넌트를 쪼개다 보면 비슷한 이름을 가진 컴포넌트들을 만드는 경우가 있는 것 같은데, 의미를 잘 전달하는 방법이 있을까요?\n\n흠.. 말씀해주신 내용만 봤을 때는 어떤 사례인지 가늠이 잘 안 되네요 ㅎㅎ;\n보통 컴파운트 패턴으로 많이 쓰는 것 같아요!\n\nhttps://www.radix-ui.com/primitives/docs/components/alert-dialog\n\n```tsx\nimport { AlertDialog } from \"radix-ui\";\n\nexport default () => (\n\t<AlertDialog.Root>\n\t\t<AlertDialog.Trigger />\n\t\t<AlertDialog.Portal>\n\t\t\t<AlertDialog.Overlay />\n\t\t\t<AlertDialog.Content>\n\t\t\t\t<AlertDialog.Title />\n\t\t\t\t<AlertDialog.Description />\n\t\t\t\t<AlertDialog.Cancel />\n\t\t\t\t<AlertDialog.Action />\n\t\t\t</AlertDialog.Content>\n\t\t</AlertDialog.Portal>\n\t</AlertDialog.Root>\n);\n```\n\n요로코롬!?\n\n---\n\n마지막 질문의 경우 구체적인 예시를 문의 채널에 남겨주시면 답변하도록 하겠씁니다!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/8"
    }
  },
  {
    "passed": false,
    "name": "이진희",
    "feedback": "진희님 체크박스를 체크를 하지 않으셨어요 ㅜㅜ \n이번 과제는 스스로 체크하면서 의도한 대로 과제를 수행했는지가 중요합니다~\n진행하신 부분이 있지만, 어쩔수 없이 불합드립니다!\n수고많으셨습니다. 진희님",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/33"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "안녕하세요 태영, 수고했습니다! 이번 과제는 React의 Custom Hook 개념을 이해하고 함수형 프로그래밍의 순수함수 개념을 체득하면서 적절한 계층 분리를 경험하는 것이 목표였어요.\n\n\"순서가 중요하다!!!!\"라는 깨달음 좋습니다. 실제로 리팩토링에서 가장 많이 실수하는 부분이 바로 순서죠. icons를 먼저 분리하지 않고 진행했다가 svg 코드들을 다시 찾아 헤맨 경험 - 이런 시행착오가 진짜 학습이죠. 리팩토링을 할때에는 작은 것 부터 그냥 하면 100% 나아지는 게 확실한 소소한 것들을 하는게 중요합니다. 구조보다도 분리가 가능한 클린한 코드로 야금야금 만들어두는거죠. svg를 icon으로 만든다거나 좋지 않은 이름을 바꾼다거나 inline 핸들러를 옮긴다거나 코드의 순서를 정돈한다거나 주석을 다는 일처럼 말이죠.\n\n또 models > hooks > components의 단방향 데이터 흐름이라는 의미를 몸으로 느낌을 이해한듯 해서 좋네요. 데이터의 흐름을 이해하면 그 흐름은 그대로이면서 세부 계층이 더 쪼개어지는 거라 model의 타입 - 원본데이터 - 파생 데이터 등으로 쪼개어지고 hook도 그렇고 component도 세부적인 단계로 쪼개어질 수 있다는걸 느낄 수 있을거에요!\n\nQ) 실무에서 대규모 리팩토링을 진행할 때의 순서와 전략\n=> 큰 방향과 목표에 대해서 공감대를 항상 갖추고 컨벤션을 갖추려하지만 이걸 작정하고 대대적으로 수정하거나 하지는 않아요. 규모가 클수록 기존의 동작이 문제없을거라는 재검증을 하는데 엄청난 에너지가 들기 떄문에 - 다시 다 확인해야하는 것인 만큼 - 그래도 평소에 조금씩 분리가능한 구조 즉 결합도를 낮춰두는 구조를 유지하는게 중요합니다.\n\n=> 해보면 알겠지만 결합도가 충분히 낮은 좋은 구조를 가지고 있으면 그 뒤에 어떻게 재배치를 하거나 이전하는것이 어렵지 않을 뿐더라 문제가 생기는 경우도 굉장히 낮거든요. 그렇기 때문에 소소하게 조금씩 더러운 곳을 치워나가는 습관이 제일 중요합니다.\n\n=> 그렇게 코드가 갖춰져 있다면 규모에 맞춰 응집도를 더 좋게 할 수 있는 적절한 구조들에서 대해서 열심히 고민하고 상의해보면서 실험등을 통해 합의를 하게 되겠죠. 테스트 코드도 작성하고 커버리지도 확인하면서 말이죠.\n\nQ) 팀원들과의 협업 방법\n\n=> 리팩토링 전에 팀 전체가 목표와 방향성을 공유하는 게 핵심이에요. 우선 당연히 해야하는 것들에 대해서도 합의가 있으면 좋아요. svg는 IconOOO 형태로 옮겨둔다라거나 하면 안되는 안티코드들.\n\n그런데 폴더구조라건다 새로운 기술 스택의 도입등은 모두에게 영향을 미치는 만큼 충분한 합의가 필요합니다. 어떻게 구체적으로 할지를 정하는게 아니라 더 큰 합의. 왜 하려고 하는지 원하고자 하는게 무엇인지 결정은 어떻게 할 것인지 이런것들의 합의를 충분히 하면 고민이 생겼을때 그 합의했던 내용을 바탕으로 결정을 할 수 있답니다.\n\n수고하셨습니다. 6주차 과제도 화이팅입니다",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/20"
    }
  },
  {
    "passed": false,
    "name": "임규원",
    "feedback": "안녕하세요 규원, 수고하셨습니다! 이번 과제는 React의 hook과 함수형 프로그래밍을 깊이 이해하고, 액션과 순수함수를 체계적으로 분리하는 것이 목표였습니다. 제시간에 완성하지 못한 점은 아쉽지만, AI 없이 직접 코드를 파악하려고 노력하신 학습 태도는 응원합니다.\n\nmodels/cart.ts에서 비즈니스 로직을 순수 함수로 분리한 방향은 좋았습니다. 하지만 useCart 훅에서 addNotification을 직접 의존하는 문제나, 여러 TODO로 남겨진 훅들이 미완성인 부분은 꼭 한번 개발해보기를 바래요.\n\n학습을 통한 성장경험은 주관적이나 그걸 체감하기 위해서는 그에 합당한 증거가 있어야 된다고 해요. 완성하지 못했지만 학습을 했으니 됐어라는 생각은 스스로가 받아들이기 힘든만큼 꼭 완성을 잘 해보기를 바래요.\n\n다른 사람들의 도움도 많이 많이 구해봐요! 도움을 구하는 것도 실력이니까요 :) 6주차 화이팅입니다.",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/37"
    }
  },
  {
    "passed": true,
    "name": "임두현",
    "feedback": "두현~ 수고했습니다! 이번 과제는 React의 hook과 함수형 프로그래밍을 깊이 이해하고, 액션과 순수함수를 분리하면서 엔티티와 UI를 체계적으로 구분하는 것이 목표였습니다. 작성한 회고를 보니 진짜 본인의 성찰과 인사이트를 많이 느낀것 같아서 뿌듯하네요\n\n\"'프론트엔드 개발에서 지나치게 함수형 코딩에 과몰입하는 것은 부작용이 있다'라는 경계를 가지고 있었습니다.\" 맞아요. 실제로 그렇죠. 그렇지만 무엇이 부작용을 가져오는지 무엇을 이점이 가져오는지는 겪어봐야만 알 수 있는 법이죠. 이번 과제만으로는 다 이해하기는 어렵겠지만 많은 시행착오등을 겪어보기를 바래요.\n\nprops drilling에 대한 고민도 흥미롭게 읽었습니다. \"프롤 드릴링 지지협회의 일원\" 이라니 훌륭합니다! 삭제의 복잡성과 테스트 가능성이라는 실무적 관점에서 대해서 새로운 시야가 생겼다는 점이 인상깊네요. 프롤 드릴링 지지협회의 일원으로써 좋은 props drilli만 많이 남겨주길 바래요! \n\n핸들러 함수 전략에서 비즈니스 로직은 Hook으로, UI 핸들러는 컴포넌트에 두는 방식으로 구분한 것도 좋은 선택이었습니다. UI 이벤트 처리는 확실히 UI 컴포넌트의 책임이죠. 도메인 컴포넌트의 책임은 사용자의 액션에서도 도메인 로직을 처리하기 위한 데이터를 뽑아다가 전달하는 역할인만큼 지금의 접근법은 상당히 균형잡혀 보여요.\n\n질문하신 검색창 로직의 안티패턴에 대해 답변드리자면, AI에게 시키다 보니 그런 주석을 만들어 주었고 제가 삭제를 하지 못했었는데 유틸로 분리할 수 있는 훅 (debounce)와 검색의 기능이 한데 묶여 인라인으로 들어가있는 정도의 안티패턴이었어요. 우리는 이제 각자의 자리와 책임을 아니까 같이 있으면 안되는 책임과 자리를 가진 패턴이라서 안티패턴이라 명명했습니다.\n\nDecorator 패턴에 관심을 가지신 것도 좋습니다. 이 패턴은 기존 객체를 수정하지 않고 새로운 기능을 추가할 때 유용한데, React의 HOC나 커스텀 훅 조합에서도 비슷한 개념을 활용할 수 있어요. 앞으로 더 큰 규모의 프로젝트에서 이런 패턴들을 적용해보면서 실무적 감각을 키워나가시길 바랍니다.\n\n수고하셨습니다. 다음 주차도 화이팅입니다!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/50"
    }
  },
  {
    "passed": false,
    "name": "장루빈",
    "feedback": "안녕하세요 루빈, PR 내용이 없어서 해당 과제는 채점 요건이 충족되지 않아서 불합격처리 했어요. 혹시라도 나중에 추가적으로 진행을 하게 되면 알려주세요.\n\n6주차 과제 화이팅입니다!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/30"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "장희진",
    "feedback": "안녕하세요 희진! 수고했습니다. 이번 과제는 React 코드의 구조적 분리와 함수형 프로그래밍 원칙을 이해하고 적용해보는 것이 핵심이었습니다. 특히 엔티티를 다루는 코드와 UI를 다루는 코드의 분리, 순수함수의 활용 등 현대적인 프론트엔드 개발의 중요한 패턴들을 경험했기를 바래요 :)\n\n회고를 보니 디자인 패턴을 의도적으로 적용하려는 노력이 인상적입니다. 특히 Props Drilling을 경험하고 이를 개선하기 위해 컨테이너-프레젠터 패턴과 Jotai를 활용한 상태 관리 구조를 구현하신 과정이 정말 좋은 학습 경험이었을 것 같아요. 옵저버 패턴과 파사드 패턴을 자연스럽게 적용하신 부분도 훌륭합니다.\n\n코드를 살펴보니 상태와 로직을 커스텀 훅으로 캡슐화하여 컴포넌트를 깔끔하게 유지하신 부분이 돋보입니다. 특히 useAdminProducts, useCart 같은 훅을 통해 비즈니스 로직을 분리하고, 컴포넌트는 UI 렌더링에만 집중하도록 한 점은 매우 좋은 접근법입니다.\n\n순수함수의 의존성 주입에 대한 고민도 흥미롭네요. calculateItemTotal 함수에 getMaxDiscount를 인자로 주입하여 순수성을 확보하려고 했던 시도가 인상적이었습니다. 사실 순수함수 + 순수함수 = 순수함수이기에 내부적으로 순수함수를 사용한다고 해도 의존성에 대한 문제는 발생하지 않아요. 다만 지금처럼 외부의존을 밖으로 빼내기도 용이하고 실제로 다른 전략을 써야한다면 OCP방식으로 필요한 부분만 빼내기도 용이한 방식이 되겠죠. 해당 과제의 경우 getMaxApplicableDiscount(item)만 되어 있는 경우에는 문제가 되는 코드였지만 이미 getMaxApplicableDiscount(item, cart) 형태로 순수하게 만들어두게 되면서 암묵적 문제는 해결이 된 상태랍니다. getMaxDiscount의 경우 전략적으로 선택을 해야하는 상황이 아니라면 내부에 두면 되고 필요할때 빼내어도 좋아요! 함수형 프로그래밍의 장점과 확장에 대한 체험을 제대로 했다고 생각이 드네요. 잘했씁니다.\n\n1 이번 과제에서 컨테이너-프레젠터, 파사드, 옵저버 패턴을 의도적으로 적용해보았습니다. 제가 이해하고 적용한 방식이 실제 의도와 잘 맞는지, 개선할 점은 없는지 궁금합니다!\n=> 잘했습니다. 디자인 패턴은 어떻게 하거나 적용하는게 아니라 말 그대로 패턴인거죠. 내가 일반적으로 더 좋은 코드의 형태로 구조를 바꾸게 되는 여러가지 패턴들이 있는게 하고보니 우리가 하고 있던 패턴들이었던거죠. 그런 측면에서 컨테이너-프레젠터, 파사드, 옵저버 패턴을 특정 구현 방법이 아닌 패턴이라는 측면에서 아주 잘 활용했다고 생각합니다. \n\n2 함수에서 의존 함수를 인자로 주입하는 방식이 한편으로는 오히려 복잡도를 높이는 건 아닌지 우려되기도 하는데요. 순수성을 확보하는 데 효과적인 패턴인지 궁금합니다!\n=> 위에서 설명한대로 순수함수 + 순수함수 = 순수함수이기 때문에 인자로 주입하지 않아도 됩니다. 인자로 주입을 한다는건 외부에서 전략을 바꿀 수 있도록 위임하는 것이죠. 마치 Array.map Array.filter와 같은 식으로요. \n\n=> 필요한 경우에는 어렵지 않게 외부의존을 담을 수 있다는게 장점이고 필요없다면 그냥 사용해도 무방합니다. 무조건적인 적용이 아니라 점진적확장의 형태로 처음에는 가장 단순한 형태로 시작해서 필요할때 필요한 만큼 복잡하게 만든다라는 식으로 적용하면 됩니다.\n\n아니면 이렇게도 할수 있습니다. 외부에서도 받을 수 있게 만들면서 기본 값은 적용하는 방식이죠. 이렇게 하면 순수함과 외부의존성 전략패턴과 간결함 모두 얻을 수 있습니다. \n\nexport const calculateItemTotal = (\n  item: CartItem,\n  cart: CartItem[],\n  getMaxDiscount = defaultGetMaxDiscount // 기본 구현 제공\n): number => {\n  const discount = getMaxDiscount(item, cart);\n  return Math.round(item.product.price * item.quantity * (1 - discount));\n};\n\n그렇다고 이 방법이 만능이니 다 이렇게 해야되냐? 하면 필요없다면 이 역시도 오버엔지니어링이죠. 필요할때 필요한만큼!\n\n아주 아주 잘했습니다. 6주차 과제에서 지금의 고민들을 많이 적용해보길 바래요!!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/27"
    }
  },
  {
    "passed": true,
    "name": "정건휘",
    "feedback": "안녕하세요 건휘님! 5주차 과제 잘 진행해주셨네요 ㅎㅎ\n다만 과제 회고가 현 과제에서 무척 중요한 부분이기 때문에 늦더라도, 꼭 과제 PR이 아니여도, 개인적으로 회고를 해보시면 좋겠어요!\n\n고생하셨습니다!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/48"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "정도은",
    "feedback": "수고하셨습니다. 도은님!\n\nQ. Basic 단계에서 custom hook으로 상태 관리를 구현했고 Advanced 단계에서 Jotai를 도입했습니다.\n기존 hook 로직을 재사용하고 싶어서 atom은 순수 상태만 관리하도록 작성했는데, 이 방식이 적절한지 궁금합니다...\n\nA. 저라면 도은님과 동일하게 구성했을 것 같습니다. 가급적 atom에 과한 로직을 두지 않고 훅에서 처리할 것 같아요. 오히려 atom에서 많은 로직을 처리하면 오히려 역할이 모호해지는 것 같아요.\n최대한 순수한 상태로 유지되는 아톰과 validateStockAvailability과 같은 판단 함수 그리고  UI처리하는 훅을 조합하는 형태로 가는 것이 역할을 잘 분리하는 것이 아닐까 싶습니다.\n\nQ. 컴포넌트에서 상태를 어떻게 전달할지 고민됩니다. 여러 컴포넌트에서 같은 hook을 직접 사용하고 있을때 props로 처리 vs 컴포넌트에서 hook 사용하기\n\nA. 여러가지 이유가 있을 수 있지만 일단 뎊스가 깊지않고 훅을 통한 컴포넌트간 재사용이 필요하지 않다면 저는 기본적으로 프롭으로 전달할 것 같습니다.  \n훅을 고려하는 것은 해당 훅으로 분리(추상화) 해야할 작업(코드)의 양, 재사용성등을 고려할 것 같아요.\n혹은 단순 데이터를 공유하는 용도는 스토어에서 데이터를 꺼낼때는 훅을 통해 레이어를 구성하자라고 팀에서 약속한 경우 그렇게 할 것 같아요.",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/3"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "정민기",
    "feedback": "수고하셨습니다. 민기님!\n\n일단 너무 어렵게 생각하실 필요가 없습니다.\n도메인 로직으로 나눈다는 것은\n예를들어\n장바구니면 장바구니 관련 코드들을 모은다 정도로 이해하시면 될 것 같아요.\n지금 cartService는 사실 카트의 데이터를 계산해서 특별한 데이터로 전환하는 코드들이 모여있잖아요.\n그냥 일단 다른것은 고민하지마시고\ncartService 요건 단순히 계산의 입장에서 코드를 모아두었는데,\n요것을 훅을 이용해서 재구성해서 조금 더 편하게 사용하게 만들려면 어떻게 할까를 한 번 고민해봐주시면 좋을 것 같아요!\n이것은 카트라는 엔터티 혹은 도메인에 대한 훅이 될 수 있을 것 같아요.\n그렇게 쿠폰도 있을 수 있고, 프로덕트도 있을 수 있겠죠? \n카트도 카트에 대한 로직을 훅으로 묶었듯, 쿠폰이라면 쿠폰에 대한 정보를 얻거나 수정하려면 사용하는 훅으로  묶는것이죠..\n이것을 도메인(엔터티) 로직으로 나눈다혹은 분리한다 라는 것이에요 :) \n일단 한 번 고민을 해봐주시고, 나중에 솔루션 코드를 한땀한땀 뜯어보시면 좋을 것 같아요!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/7"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "정유열",
    "feedback": "고생하셨습니다 유열님!\n이번주도 잘 정리해주셨네요. 회고를 보면 이번 과제에서 뭔가 고민을 굉장히 많이 하시고 그만큼 얻어가시는게 많았던 주차셨을 것 같아요.  '옷걸이 더미에서 옷걸이 하나만 들어올리려다 다 딸려오는 듯한' 은 저도 매우 공감을 많이 하는 비유였네요 ㅎㅎ사실 말씀해주셨던 주제들이 한 주 한다고, 그리고 명확한 규칙이 만들어지는 주제들은 아닌것 같아요. 상황에 따라 매번 고민해야 되는 주제들이니 프로젝트를 보는 좋은 관점 하나가 추가로 생겼다 라고 생각해주심 좋을것 같네요 ㅎㅎ\n\n질문 주신거 답변드려보면요!\n\n> cart와 coupon 엔티티를 나눌지 분리할지에 대한 고민을 적었습니다.\n\n유효한 전략이라고 생각합니다. 그리고 합치는 판단도 나쁘지 않았던 것 같아요. 유열님 생각에서는 \"쿠폰은 장바구니라는 맥락없이는 검증이 불가능하다\"라고 말슴해주셨는데, 굳이 분리하고 관리하는게 복잡도를 올리는 관점도 있을 수 있어요. 늘 정답에 해당하는 내용은 아니고 맥락에 맞춰볼때 좋은 선택이였다 라고 볼 수 있을 것 같습니다.\n\n> 어느 모델에 둬도 애매한것 같은 로직을 model/index.ts 파일에 shared 개념으로 위치시킨 것에 대한 내용을 적었습니다.\n\n아뇨! 혼합된 로직은 언제든지 생길수 있습니다. 자주 발생하는 시나리오에요. 지금의 방식처럼 모아서 관리하는 것도 방법일 수 있고, 모델이 아닌 비즈니스 로직관점에서 여러 로직을 함께 조합해서 사용해야 하는 경우에는 helper나 service같이 분리해서 관리하는것도 방법일 수 있어요.\n\n잘 정리해주셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/12"
    }
  },
  {
    "passed": true,
    "name": "조영민",
    "feedback": "안녕하세요 영민님, 수고하셨습니다! 이번 과제는 React의 구조적 분리와 함수형 프로그래밍을 이해하고 적용하는 것이 목표였는데, 정말 체계적으로 잘 수행하셨네요.\n\n모듈화와 책임 분리가 아주 잘 되어 있습니다. 특히 models, hooks, utils, pages, components 등으로 코드를 체계적으로 분리한 부분이 인상적입니다. 순수 함수를 활용하여 비즈니스 로직을 분리하고, 커스텀 훅을 통해 재사용성을 높인 점도 훌륭합니다.\n\nprops에 대한 판단으로 의도를 가진채로 Cart에는 그리는 역할만 하고 외부의 역할을 위임하고자 하는 방식을 택했군요. 실제로 컴포넌트를 설계를 할 경우에는 2가지의 방향성을 고려하게 됩니다. props를 통해 같은 동작에 대해서 다른 행동을 할 수 있도록 만들지? 대신 복잡해지겠죠. 반대로 기능을 내부로 감춰서 사용하기에 편리하게 만들지입니다.\n\nQ) 이처럼 cart 데이터를 보여주고 기능은 전달받은 핸들러를 통해 실행시키는 방법과, Cart 컴포넌트 내부에서 삭제, 증가, 감소를 구현해놓는 방법 중 어떤것이 더 좋은 설계인지 받고싶습니다.\n\n=> 의도를 가진채로 만들었다면 그 의도가 먹히는지를 판단하는게 제일 좋습니다. 특정한 방법이 좋다 나쁘다의 문제가 아니라 내가 어떤 문제를 풀고 싶고 그 문제에 적합도구를 맥락에 맞게 선택했느냐이니까요.\n\n\"...이렇게 구현하면 제거, 증가, 감소 버튼을 클릭했을 때 모달을 표시한다든지, 값을 1증감이 아닌 2증감으로 변경한다든지 이런 추가 작업이 발생할 때 Cart 컴포넌트는 수정할일이 없을거라고 생각했습니다.\" 라는 근거로 보아 해당 전략은 Cart의 책임은 오로지 그리는 것에만 있고 각 카트 동작들은 외부에서 위임하는 것으로 세웠습니다.\n\n하나씩 판별해봅시다. 지금 Cart 컴포넌트는 리스트를 그리는데 행동은 각각의 Item에 대한 행동입니다. 이 둘이 하나의 인터페이스에 묶여있다는 것은 좋지 않습니다. 컬렉션을 다루는 데이터와 개체를 다루는 행동이 섞여있으니까요. \n\n그리는 파트는 추상화 했으니 해당 Cart 컴포넌트는 지금처럼 목록을 그리는 것은 동일하나 삭제하거나 개수를 변경할때마다 다른 로직을 수행하는 작업이 두군데 이상 존재해야 합니다. 그렇지만 해당 기능에서 삭제시 다른 전략을 취한다거나 개수를 올리는 로직이 어떤 곳에서는 1개씩 어떤 곳에서는 2개씩으로 만들어져야한다는 요구사항은 없네요. 현재로써는 props를 외부의존을 해야하는 이유가 없습니다.\n\n\"...Cart 컴포넌트는 수정할일이 없을거라고 생각했습니다.\" 이렇게 책임을 만들고 싶었더라면 Cart 컴포넌트 중 버튼이 존재하지 않는 부분만 렌더링하도록 만들었어도 의도는 같았을거에요. \n\n\"...이처럼 cart 데이터를 보여주고 기능은 전달받은 핸들러를 통해 실행시키는 방법과, Cart 컴포넌트 내부에서 삭제, 증가, 감소를 구현해놓는 방법 중 어떤것이 더 좋은 설계인지 받고싶습니다.\" 필요에 맞게 쓰면 좋은 설계가 됩니다. 그리고 지금 영민이가 만든 설계는 지금 요구사항에서 필요가 없는 설계이므로 좋은 설계가 아니라고 답해줄게요.\n\n수고하셨습니다. 6주차에서도 이와 같은 고민을 많이해보고 정답까지 한번 찾아가보길 바래요! 특정 방법이 좋고 나쁘고가 아니라 상황에 맞는 쓰임이 중요하다는거 잘 써먹어보길 바랍니다 :)\n\n\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/34"
    }
  },
  {
    "passed": true,
    "name": "주산들",
    "feedback": "안녕하세요 산들님!\n5주차 과제 잘 진행해주셨네요!\nhook과 상태관리 라이브러리에 대한 효용성을 많이 느낀 것 같아서 다행이네요 ㅎㅎ\n테오님께서 무척 좋아하실 것 같아요!\n\n> 대체로 테오 코치님께서 초기에 제공해 주신 힌트를 보고 그것 기반으로 분리를 진행했는데요. 지금 컴포넌트들의 크기들이 적절히 잘 쪼개진 것인지 아니면 더 작은 단위로 분리할 필요성이 있을지 궁금합니다. (개인적으로 컴포넌트를 잘게 쪼개는 것을 별로 안좋아하는데.. 아집일까요... 왜 저는 너무 쪼개면 오히려 가독성이 안좋아질 것 같죠...ㅠㅠ 제가 혹시 지금 너무 큰 단위들로 잘라놨나요? ㅠㅠ 아집이면 팩폭 부탁드립니다...)\n\n이런건 산들님께서 효용성을 직접 느껴야한다고 생각해요 ㅎㅎ\n회고에서 훅과 상태관리 라이브러리의 이점에 대해 알아갔던 것 처럼, 지금 당장 산들님께서 컴포넌트를 분리해야 하는 이유 등에 대해 납득이 되지 않는다면, 납득할만한 사례를 찾아야할 것 같은데... 그게 지금은 글로 설명하기가 어려운 부분이 있네요 ㅠㅠ\n\n가독성이 안 좋다고 느끼는 이유에 대해 한 번 고민해보시면 좋겠어요!\n가독성이라는게 사실 주관적인거라서요 ㅋㅋ\n\n컴포넌트의 가독성을 어떻게 측정해볼 수 있을지도 같이 고민해보시면 좋답니다!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/21"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "최용훈",
    "feedback": "안녕하세요 용훈님! 5주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n심화과제가 미완성이라고 말씀해주셨는데, 일단 테스트도 통과하고 있고 어느정도 분리가 되어있어서 합격으로 남겨놓겠습니다!\n\n> 컴포넌트를 나누는 과정에서 Atomic에 너무 집중하다보면 너무 많이 쪼개진 컴포넌트들로 오히려 가독성이 떨어진다고 생각합니다. 컴포넌트를 나누는 기준이야 천차만별이지만 조금의 팁이 있을까요?\n\n처음부터 다 작게 작게 분리하기보단, 분리가 필요한 순간에 분리하는 방법이 있을 것 같아요 ㅎㅎ 반복적으로 보이는 컴포넌트를 분리한다거나?!\n\n혹은 책임의 소재를 분리하기 위해 분리하는 등의 방법이 있을 것 같네요.\n\n그리고 가독성이 떨어진다고 생각하시는 이유가 뭘까요!? 너무 Depth가 깊어져서 그런걸까요!?\n\n> 전역상태 관리 라이브러리를 단지 Props drilling 방지를 위해 사용하는 것에 대해 어떻게 생각하시나요?. 그렇다면 전역 상태로 보관해야할 상태와, 지역에 useState등으로 보관해야할 상태의 기준이 어떻게 될까요? \"props로 몇 depth 이상 내리면 차라리 전역변수로 관리한다.\" 이런 기준들은 조금 모호하다고 생각해서 들었던 의문입니다.\n\n저는 상태관리 라이브러리에서 중요한건 \"전역\" 이라는 키워드가 아니라 \"상태관리\" 라는 키워드라고 생각해요. props drilling만 해결하고 싶다면 context를 쓰는게 맞다고 생각합니다.\n\n상태관리 라이브러리는 복잡한 데이터의 변경과 흐름을 응집도 있게 관리하기 위함이라고 생각해요 ㅎㅎ\n\"전역\" 이라는 키워드는 이를 위한 장치라고 생각합니다.\n\n> 전역상태 라이브러리와 Context Api를 사용하는 기준이 각각 어떻게 될까요?\n\nContext API 는 보통 UI의 상태를 응집도 있게 관리하기 위해 사용하는 경우가 많습니다.\n\nhttps://www.radix-ui.com/themes/docs/components/dialog\n\n```tsx\n<Dialog.Root>\n\t<Dialog.Trigger>\n\t\t<Button>Edit profile</Button>\n\t</Dialog.Trigger>\n\n\t<Dialog.Content maxWidth=\"450px\">\n\t\t<Dialog.Title>Edit profile</Dialog.Title>\n\t\t<Dialog.Description size=\"2\" mb=\"4\">\n\t\t\tMake changes to your profile.\n\t\t</Dialog.Description>\n\n\t\t<Flex direction=\"column\" gap=\"3\">\n\t\t\t<label>\n\t\t\t\t<Text as=\"div\" size=\"2\" mb=\"1\" weight=\"bold\">\n\t\t\t\t\tName\n\t\t\t\t</Text>\n\t\t\t\t<TextField.Root\n\t\t\t\t\tdefaultValue=\"Freja Johnsen\"\n\t\t\t\t\tplaceholder=\"Enter your full name\"\n\t\t\t\t/>\n\t\t\t</label>\n\t\t\t<label>\n\t\t\t\t<Text as=\"div\" size=\"2\" mb=\"1\" weight=\"bold\">\n\t\t\t\t\tEmail\n\t\t\t\t</Text>\n\t\t\t\t<TextField.Root\n\t\t\t\t\tdefaultValue=\"freja@example.com\"\n\t\t\t\t\tplaceholder=\"Enter your email\"\n\t\t\t\t/>\n\t\t\t</label>\n\t\t</Flex>\n\n\t\t<Flex gap=\"3\" mt=\"4\" justify=\"end\">\n\t\t\t<Dialog.Close>\n\t\t\t\t<Button variant=\"soft\" color=\"gray\">\n\t\t\t\t\tCancel\n\t\t\t\t</Button>\n\t\t\t</Dialog.Close>\n\t\t\t<Dialog.Close>\n\t\t\t\t<Button>Save</Button>\n\t\t\t</Dialog.Close>\n\t\t</Flex>\n\t</Dialog.Content>\n</Dialog.Root>\n```\n\n잘 보면 state가 어디에도 없으나 정상적으로 동작해요. 이게 다 Context를 통해 추상화가 된거죠!\n\n상태관리를 사용하는 이유는 앞선 질문에 답변 했으니 참고 부탁드려요!\n\n> 규모가 작지 않은 프로젝트에서 기존 코드를 모두 리팩토링할 시간은 없는 경우, 새로 추가되는 코드들을 기존 코드와 맞는 패턴으로 추가해야할까요? 아니면 새로운 컨벤션으로 클린하게 짜보려 노력해야할까요?\n\n시급도에 따라 다르다고 생각해요. 정말 시급한 경우에는 기존 구조를 쫓아가는게 생산성을 더 높일 수 있는 방법일 것이고,\n그렇지 않은 경우에는 새로 추가하는 코드는 새로운 컨벤션으로 구성하고, 변경이 생길 때 마다 조금씩 조금씩 점진적인 개선을 하는 방법을 생각해볼 수 있을 것 같아요.\n\n대신 이 때 중요한건 테스트가 있어야 한다는 것! 기존 코드가 정상적으로 동작하는지 보장해야 하기 때문에, 테스트 없이는 리팩토링을 하는게 위험할 수 있어요..!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/16"
    }
  },
  {
    "passed": true,
    "name": "최재환",
    "feedback": "좋아요! 잘했습니다 재환! 비즈니스 로직 분리에서 계산이 가능한 상태는 순수함수로 분리해낸다는 전략 좋았습니다. 파생가능한 결과는 상태로 두는게 아니라 계산으로 만들어 두면 좋죠.\n\njotai를 통해서 useToast를 만들었군요. 좋습니다. 아무리 props를 통해서 순수하게 만든다고 해도 toast하나 쓰겠다고 props를 계속 가지고 가는건 괴로운 법이죠. 뭐든 극단적이고 한 가지 방법만 고수하는건 좋지 않죠. 순수하게만 만드려고 하면 이런 문제가 생깁니다.\n\n이벤트 핸들러의 경우의 인사이트가 좋네요. 코드의 중복을 제거하면서 재사용이 가능한 코드를 만들고 싶었을 거에요. 그렇지만 재사용이 목적이라면 정말 재사용을 할 수 있어야 해요. \n\n```\n// ProductForm.tsx\nconst handleTextChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n  const { name, value } = e.target;\n  setProductForm(prev => ({ ...prev, [name]: value }));\n};\n```\n\n위 코드에서 보면 이름은 handleTextChange인데 사용은 setProductForm이죠. 이렇게 DOM과 유틸과 도메인이 섞여있으면 재사용도 안되고 추상화도 애매한 코드가 됩니다.  setProductForm도 외부에서 받도록 하면 좋겠죠? ex) handleTextChange(\"name\", setProductForm) 그런데 숫자도 필요하고 검증이 필요하네요? 그러면 ex) handleChange(\"name\", setProductForm, (e) => Number(e.value), (value) => value > 1000) 이런식으로도 만들 수 있지만 이건 좋은 방법이 아니게 되죠.\n\n사실 이러한 시도들은 예전에도 많이 있었어요. 결국 알게된 해법은 validate는 도메인에서 handleChange는 form에서 할 수 있도록 해서 선언적으로 만드는 방식이 낫다라는거에요. react-hook-form과 zod가 가장 대표적이니 한번 살펴보시면 좋겠네요. \n\nQ) useCart 같은 **엔티티 Hook**과 useLocalStorage 같은 **라이브러리 Hook**을 분리했는데, useCart가 지금 꽤 많은 일을 하고 있습니다. 이게 엔티티를 다루는 Hook의 적절한 책임 범위일지 아니면 더 세분화해야 할지 의문입니다.\n\n=> 선택하기 나름입니다. 물론 가급적 가벼우면 좋겠죠. 대부분 화면에서 그려지는 파생데이터 - 포맷터, 조건, 필터 등 - 컴포넌트의 책임이 되는 편을 선호합니다. 왜냐하면 해당 컴포넌트가 없다면 쓰이지 않을 로직이니까요. 그런데 cartTotal이 다른 파생데이터의 원본 데이터이고 무거운 계산이라면 미리 만들어두면 좋습니다. 그렇다면 훅에 포함이 되는 편이 좋죠. 또는 cartTotal은 순수하나 타 의존도가 높고 인자가 복잡해서 import를 꼬게 만든다면 의도적으로 hook안으로 넣어서 간결하게 만들어 줄 수 있습니다.\n\n=> 사실 다 같은 맥락의 문제들입니다. 순수하면 결합도도 낮고 테스트하기에도 좋고 독립적이죠. 함수건 컴포넌트건 모듈이건 다 그렇습니다. 그렇지만 모든 걸 그렇게만 만들수도 없고 비효율적인 부분은 부분이 존재합니다. 대신 이걸 상태로 묶어버리면 관리가 필요해집니다. 상태란 값이 변하니까요. 그 선택이 더 나은 근거를 생각해보시기 바랍니다.\n\n\nQ) CartItemCard 같은 경우 완전한 Presenter는 아니고 약간의 로직을 가지고 있습니다. 하지만 굳이,, 이기도 하다고 생각합니다. 이럴 때는 적당한 타협을 해도 괜찮다 생각하는데 어떨까요?\n\n=> 전역상태관리 체계안에서의 컴포넌트의 책임은 프레젠터만 있지는 않아요. 버튼이 자신의 UI적 책임이 있듯 CartItemCard의 경우 Cart의 동작의 책임도 부여해주면 됩니다. 전역상태관리를 통해서 이제 모든 로직을 컨테이너로 몰지 않아도 되지 가장 가까운 곳에서 그 기능을 해주면 되는거에요. 그래서 컴포넌트에서 로직을 가지는건 이상하지 않아요.\n\n=> 컴포넌트에서 이벤트 핸들러의 책임이란 이벤트와 UI를 통해 얻을 수 있는 정보 (즉 event.value와 같은)나 해당 상황에서의 도메인과 관련없는 UI정보 처리들 (토스트) 등은 컴포넌트의 책임이랍니다. 이러한 정보를 도메인 훅으로 전달해서 도메인 훅은 UI와 상관없이 처리할 수 있도록 하게 해주는 것이죠.\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/29"
    }
  },
  {
    "passed": true,
    "name": "한아름",
    "feedback": "안녕하세요 아름님! 5주차 과제 잘 진행해주셨네요 ㅎㅎ 너무 고생하셨습니다!!\n\n> 과제 힌트로 제공된 리팩토링 구조를 거의 그대로 참고해서 구현을 진행했는데, 제 코드 구조나 로직 분리 방식이 의도한 방향성과 잘 맞게 구성되었는지, 그리고 models와 hooks의 경계나 역할 분리에 대해 더 나은 개선 방향이 있는지 궁금합니다! 제가 이해한 방식이 적절했는지, 혹시 더 나은 기준이 있는지도 알고 싶습니다.\n\n어느정도 적절하게 분리 되었다고 생각해요 ㅎㅎ\n여기서 조금 더 나아가자면, 본문에서 다뤄주신 코드를 토대로 이렇게 개선해볼 수 있답니다!\n\n```tsx\nconst { addNotification } = useNotification();\n\nconst { addToCart } = useCart({\n  onAdd: () => addNotification(MESSAGES.PRODUCT.ADDED_TO_CART, \"success\"),\n  onError: (message) => addNotification(message, \"error\")\n});\n```\n\n훅과 훅이 직접적으로 연결되는게 아니라, 이렇게 이벤트나 적절한 인터페이스를 통해 연결해주는거죠.\ngetRemainingStock 또한 어차피 addToCart 내에서 처리될 수 있기 때문에 응답값에서 제거했답니다!\n\n> useCart hook 내부에서 현재 장바구니 상태와 인자로 받은 쿠폰의 타입에 따라 쿠폰 적용이 가능한지에 대한 여부를 boolean 값으로 리턴하는 함수를 만들까 했는데, 이래도 결국 isCouponApplicable, setSelectedCoupon, addNotification 함수를 props로 전달하는 건 똑같지 않나 하는 생각에 만들진 않았습니다. (useCart 훅 내에 쿠폰의 상태를 판단하는 함수가 있는게 어울리지 않다고도 생각했습니다.) 현재 제 코드 상태에서 applyCoupon을 hook 내부에서 작성할 수 있는 방법이 있을까요??? 물론 힌트일 뿐이지만, 더 나은 방식이 있는지 알고 싶습니다!!\n\n이것도 위의 피드백과 동일할 것 같은데요, applyCoupon이 addNotification 같은 외부 함수를 직접적으로 사용하는게 아니라 이벤트를 통해 인터페이스를 정의해주면 될 것 같아요!\n\n```tsx\n  const { addNotification } = useNotification();\n  const { selectedCoupon, cartTotalPrice, apply, reset } = useCart({\n    onApply: () => addNotification(MESSAGES.COUPON.APPLIED, \"success\"),\n    onError: (message) = addNotification(message, \"error\");\n  });\n\n  const handleSelectCoupon = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    const coupon = coupons.find((c) => c.code === e.target.value);\n\n    if (coupon) apply(coupon);\n    else reset();\n  };\n```\n\n요로코롬!\n\n그리고 setSelectedCoupon 에서 null을 실행하는 대신에 reset 이라는 함수를 하나 만들어서 반환하는거죠 ㅎㅎ\n\n혹은 이 자체를 그냥 select 라는 함수로 표현할 수 도 있겠죠?\n\n```tsx\n  const { addNotification } = useNotification();\n  const { selectedCoupon, cartTotalPrice, select } = useCart({\n    onApply: () => addNotification(MESSAGES.COUPON.APPLIED, \"success\"),\n    onError: (message) = addNotification(message, \"error\");\n  });\n\n  const handleSelectCoupon = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    const coupon = coupons.find((c) => c.code === e.target.value);\n    select(coupon)\n  };\n```",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/41"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "허정석",
    "feedback": "안녕하세요 정석님!\n이번 과제도 너무 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 위 예시 구조의 application/cart/addItemToCart.ts처럼 “도메인/동사+목적어” 네이밍과 디렉터리 구조가 적절한지 또는 다른 컨벤션 예시가 궁금합니다.\n\n지금 모습도 적절하다고 느껴져요 ㅎㅎ\n저의 경우 별도의 파일로 분리하기보다 그냥 한 파일에 묶어서 cartUseCase.ts 처럼 표현할 것 같아요! \n\n```tsx\nconst cart = useCartUseCase();\nconst cart.add();\n```\n\n요로코롬!?\n\n아니면 CQRS Pattern 이라고 해서, 조회와 추가/수정/삭제 를 아예 분리하는 방법도 있답니다.\n```tsx\nconst cartData = useCartQuery();\nconst cartCommand = useCartCommands();\n\ncart.add();\n```\n\n이렇게 분리하는 이유는 \"렌더링\" 때문인데요, 커맨드는 데이터를 의존하지 않도록 만들 수 있기 때문에 커맨드를 아무데서나 사용해도 리렌더링의 여파가 없어요.\n\n그런데 데이터의 경우 변이되는 순간 렌더링이 전파되어야 하기 때문에, 이 데이터를 쓰는 곳을 명확하게 분리하는거죠.\n\n\n> “한 파일 = 한 행동” 원칙에서 복잡한 행동(검증·계산·여러 정책 조합)의 분기 처리는 어디까지 application/* 에 두는 게 좋을지 의견이 궁금합니다.\n\n어디까지라기보단... 한 파일 = 한 행동 이라는 규칙을 만들었다면 그냥 다 한 파일로 만들어서 분리해야한다고 생각해요 ㅎㅎ 그래야 일관성있지 않을까요? 여기에 조건들 두면 더 복잡해진다고 생각해요\n\n> “재사용 ≥ 2, 순수성, 화면 무관 설명 가능”이면 domain/policies/*로 승격한다는 기준이 충분할까요? 더 추가/수정할 항목이 있을까요?\n\n이정도면 충분하다고 생각해요!\n저는 \"다른 프레임워크에서 혹은 서버와 공유할 수 있음\" 이라는 조건을 하나 더 붙일 것 같아요 ㅎㅎ\n순수한 ECMAScript Spec 으로 작성이 되어있다면 충분히 가능하답니다!\n",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/28"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "현지수",
    "feedback": "FSD관점으로 분리하는 과제를 미리 경험해주셨군요 :+1\n각 레이어를 구분하고 레이어를 이렇게 분리했을 때 얻을 수 있는 장점들이 명확하게 있으셨으면 좋았겠네요!\n과제도 잘 정리해주셨는데, 본격적인 규칙이나 FSD에 관련된 구체적인 내용들은 다음 주에 더 깊게 이야기 해보면 좋을 것 같네요.\n\n질문 주신 부분 보면\n\n> 1. FSD(Feature-Sliced Design) 폴더 구조에 대한 피드백\n\n좋은 접근인것 같아요. 해당 폴더에 대한 명확한 규칙은 사실 정하기 나름이라고 알고 있어요. 실제로 그냥 product로 묶어서 한 곳에 로직을 묶을수도 있고, admin을 파일 명에 붙이거나 하는 형태로 구분할 수 있겠죠. (사실 저라면 따로 구분을 하지 않고 적었을 것 같은데 ㅎㅎ) 추후에 공통 로직 같은 것들을 명확하게 할 수 있다면 지금의 방식도 명확하고 좋은 것 같아요 ㅎㅎ\n\n> 2. Widgets 레이어 사용에 대한 검토\n\n\"여러 도메인을 조합한 복합 컴포넌트를 widgets 레이어에 두는 것이 FSD 설계 원칙에 맞나요?\"라는 질문에 있어서는 넵 입니다. 실제로 FSD설명을 보다보면 위젯에 대한 사용성이 약간 모호한 측면이 있는데, 해당 목적으로도 저희회사에서 많이 사용하는 편이에요! 결국 레이어간 간섭이 안되어야 하기 때문에 끌어올려서 조합해서 사용하고 페이지에 두기 애매한 경우 위젯에 두기 때문인데요. 그럼에도 대부분은 페이지에 위치시키는 경우가 적합한 경우가 많아 이 부분도 함께 생각해보시면 좋을것 같아요.\n\n결국 위젯에서 조합을 하면 다른 페이지에서도 재사용을 할 수 있다는 장점이 생기니 이 부분도 같이 고려해보면 좋지 않을까 싶습니다!\n\n고생하셨고 다음주차 과제는 쉬우실 것 같네요 ㅎㅎㅎ 화이팅입니다!",
    "assignment": {
      "name": "STEP10 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-2/pull/35"
    }
  },
  {
    "passed": false,
    "name": "강병준",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/42"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "권지호",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/9"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/32"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/17"
    }
  },
  {
    "passed": true,
    "name": "김소희",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/44"
    }
  },
  {
    "passed": false,
    "name": "김수민",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김수현",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/15"
    }
  },
  {
    "passed": false,
    "name": "김연수",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "김유현",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/33"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/35"
    }
  },
  {
    "passed": true,
    "name": "김효진",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/29"
    }
  },
  {
    "passed": true,
    "name": "김휘린",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/14"
    }
  },
  {
    "passed": true,
    "name": "박상수",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/50"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/7"
    }
  },
  {
    "passed": false,
    "name": "박의근",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/43"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박준형",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/8"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박창준",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/24"
    }
  },
  {
    "passed": true,
    "name": "신홍준",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/4"
    }
  },
  {
    "passed": true,
    "name": "신희원",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/40"
    }
  },
  {
    "passed": true,
    "name": "양성진",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/39"
    }
  },
  {
    "passed": false,
    "name": "양창훈",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/45"
    }
  },
  {
    "passed": true,
    "name": "여진석",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/2"
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/6"
    }
  },
  {
    "passed": true,
    "name": "오하늘",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/18"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/13"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "윤영서",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/20"
    }
  },
  {
    "passed": true,
    "name": "이가은",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/19"
    }
  },
  {
    "passed": true,
    "name": "이민재",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/12"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이유진",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/22"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이은지",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/48"
    }
  },
  {
    "passed": true,
    "name": "이의찬",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/38"
    }
  },
  {
    "passed": false,
    "name": "이정우",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/36"
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/41"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/3"
    }
  },
  {
    "passed": true,
    "name": "이진희",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/25"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/23"
    }
  },
  {
    "passed": true,
    "name": "임규원",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/47"
    }
  },
  {
    "passed": true,
    "name": "임두현",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/30"
    }
  },
  {
    "passed": false,
    "name": "장루빈",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/31"
    }
  },
  {
    "passed": true,
    "name": "장희진",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/21"
    }
  },
  {
    "passed": true,
    "name": "정건휘",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/46"
    }
  },
  {
    "passed": true,
    "name": "정도은",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/5"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "정민기",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/11"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "정유열",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/28"
    }
  },
  {
    "passed": true,
    "name": "조영민",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/10"
    }
  },
  {
    "passed": true,
    "name": "주산들",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/26"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "최용훈",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/1"
    }
  },
  {
    "passed": true,
    "name": "최재환",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/49"
    }
  },
  {
    "passed": true,
    "name": "한아름",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/37"
    }
  },
  {
    "passed": true,
    "name": "허정석",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/16"
    }
  },
  {
    "passed": true,
    "name": "현지수",
    "feedback": "",
    "assignment": {
      "name": "STEP11 클린 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/34"
    }
  },
  {
    "passed": false,
    "name": "강병준",
    "feedback": "병준님~ 시간이 부족하셨던 것 같습니다.\n솔루션가 나오면 솔루션 코드를 확인해보는 시간은 따로 가지면 좋을 것 같습니다.\n좋은 주말 되세요~",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/42"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "권지호",
    "feedback": "안녕하세요 지호님! 역시 믿고 보는 지호님의 과제네요 ㅎㅎ 너무 잘 해주셨어요!!!\n\n> 여전히 컴포넌트 인터페이스를 설계하는 것이 가장 어렵습니다. 특히 여러 컴포넌트가 공유해야 하지만 전역 상태로 관리하기에는 범위가 작은 상태들을 다룰 때 많은 고민을 했습니다. 예를 들어, A 컴포넌트의 상태가 형제 컴포넌트인 B에도 영향을 줘야 할 때, 공통 부모로 상태를 끌어올리는(lifting state up) 것이 최선인지, 아니면 다른 방법이 있는지 계속 탐색하게 됩니다.\n스스로의 명확한 기준 없이 '냅다 전역상태로 때려박는' 안티패턴을 피하면서, 어떻게 하면 상태의 범위를 적절하게 지역화하고 응집도를 높일 수 있을지가 저의 가장 큰 숙제입니다. 이 부분에 대해 조언해주실 말씀이 있으실까요? 코치님은 이럴때 어떤 포인트에서 아하!를 경험 하셨는지, 코치님의 기준은 무엇인지 궁금합니다!\n\n말씀해주신 내용이 도메인 상태와 관련이 있다면 전역상태로 만들어서 관리할 것 같아요! 그게 아니라 UI 상태와 관련 있다면 Context를 만들어서 관리하면 좋지 않을까!? 라는 생각이 들어요!\n\n컴포넌트를 재활용해야 하는 상황이 아니라면 대체로 Context를 통해 묶어주는게 좋다고 생각해요.\n\n혹은 useImperativeHandle 을 통해 ref로 연결하는 방법도 있을 것 같아요!\n이건 멘토링 때 이야기를 나눠봐도 좋을 것 같네요..!\n\n> 코치님에게 글쓰기란?\n\n저의 생각을 정리하는 시간이라고 생각해요 ㅎㅎ 뜬금없지만,\n군대에 있을 때 매일매일 일기를 썼었는데 일기를 쓰는 시간이 하루 중 제일 소중했었던 것 같아요.\n그 시간이 소중했던 이유가 뭘까 고민을 해보자면...\n그냥 생각이 되게 많았고 이걸 어딘가에 배설(?) 하고 싶었어요. 일기에 배설을 한거죠 ㅋㅋ\n\n지금도 마찬가지인데요, 생각이 많아질 때 이걸 결국 일기나 블로그에 쓰면서 생각을 정리하는 방식으로 활용하고 있답니다!\n\n> \"어디에 둬야 하지?\" 보다는 \"어떻게 해야 관련 있는 것 끼리 뭉쳐놓지?\" 에 대한 기준으로 판단하고, 판단 근거들 또한 명확해졌습니다. 결국 좋은 구조란 외부의 규칙을 맹목적으로 따르는 것이 아니라, 일관된 철학을 바탕으로 스스로 질서를 만들어나가는 과정이라는 것을 배울 수 있었습니다. 저의 디렉토리 구조 결정 방향성에 대한 코멘트 궁금합니다!!\n\n결정의 과정을 잘 드러내주셔서 다 납득했답니다! 여기에 저의 생각을 한스푼 더 얹어보자면...\n\n```\npackages/domain\n   posts\n     /entities\n     /feautres\n     /shared\n```\n\n저희 팀의 경우 이렇게 별도의 패키지로 분리한 다음에 도메인과 관련된 것들으 한 번에 묶어서 표현하는 방식으로 사용하고 있답니다 ㅎㅎ 이렇게 하면 더 응집도를 높이는 방식으로 관리할 수 있어요!\n\n다만... ui는 전부다 제외하고 로직만 관리해요 ㅋㅋ\n\n> 재사용성을 고려한 컴포넌트 설계 방향성이 적절했는지, 확장성을 잘 고려했는지 모르겠습니다! 코치님이 보셨을때 이 리팩토링의 인상은 어떤지 궁금합니다!\n\n흠 재사용성만 놓고 보면, 컴포넌트가 tanstack-query를 직접적으로 의존하고 있다보니 어떻게 재사용을 할 수 있을까? 에 대한 고민이 들었어요.\n\n이렇게 children을 적극적으로 활용해주면 어떨까 싶어요!\n\n```tsx\nexport function PostDialog({\n  className,\n  open,\n  title,\n  children,\n  onOpenChange,\n}) {\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className={className}>\n        <DialogHeader>\n          <DialogTitle>{title}</DialogTitle>\n        </DialogHeader>\n\n        {children}\n      </DialogContent>\n    </Dialog>\n  )\n}\n```\n\n그리고 PostDialog 하위에 각각의 컴포넌트를 표현하는 방식으로 만들면 좋을 것 같아요 ㅎㅎ\n\n더 정확히 표현하자면.. \"UI와 Logic을 완전히 분리하는 것\" 이라고 봐주시면 좋겠습니다!\n\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/9"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "\n수고했습니다. 지난 3주간 클린코드를 비롯한 소프트웨어 공학적으로 결합도 낮추기 응집도 높이기를 위한 이론과 프론트엔드에서의 적용등을 통해서 좋은 코드와 구조에 대한 다각도의 시야가 생겼기를 기대합니다.\n\n\"엔티티에 어떤 UI에 들어가야하는지 잘 이해가 안갔는데 readoly 한 UI는 들어갈 수 있다는걸 알게 되었습니다. 그래서 엔티티에 UI는 사실 하나도 들어가지 않았습니다. 사실상 개인적인 생각으로는 feature에서 따로 UI로 만들어도 생각없지 않나 라는 판단하였습니다. 그게 맞는지는 잘 모르겠지만 그런 생각이 들었습니다.\"\n\nFSD의 경우 계층, 슬라이스, 세그먼트라는 3가지의 관점을 조합해서 코드를 바라보자는 관점으로 이 관점으로 바라보니 엔티티 + UI라는 조합을 생각해보게 되는 것인데 꼭 그렇게 해야된다는 것은 없어요. 개발을 하다보면 계속 스스로의 판단을 하게 되는데 우선 직감을 느꼈다면 그 직감을 믿어보되 왜 그렇게 생각하게 되었는가에 대해서는 언어로 논리적으로 설명할 수 있을 만큼 충분히 파면서 근거를 만들어보는 시도를 해보기를 바래요. \n\nQ) 의존성 방향만 유지된다면 shared -> entities -> widgets -> features -> pages로 가도 될까요? FSD 원칙에 위반돼서 안되는 것일지 궁금합니다. 예를 들면 widgets에서 pagination을 구현해서 features의 ui에서 갖다 쓰는거죠.\n\n=> 본인의 생각이 그러하다면 그렇게 만들어도 무방합니다. 그런데 팀 프로젝트라면 그래서 우리는 FSD를 쓰겠다고 하면 사실상의 표준과 규약이 있기 때문에 그 약속을 합의하지 않으면 혼란이 가중될거에요. 나만 그렇게 생각한들 다른 사람들도 그렇게 생각하지 않으면 규칙이 되지 못하니까요. 일반적으로 널리 알려진 방법을 사용할때에는 남들도 대개 비슷하게 생각하는 컨벤션을 최대한 따라 진행하면서 함께 하는 사람과의 합의를 이끌어 낼 수 있다면 전혀 문제없다고 생각합니다.\n\nQ) 실무나 아니면 간혹 구글링으로 서칭을 해보면 간혹 의존성에 대한 역전하는 허용하는 사례들을 본 것 같은데, 이런 케이스의 경우 어떤 룰을 세워서 허용하는 게 좋을까요?\n\n=> 의존성을 역전이란 가령 옵저버 패턴의 경우 클릭 이벤트 처리는 원래 컴포넌트 내부에서 처리하는 로직이지만 컴포넌트에서 클릭 동작을 외부에 위임하면서 만들면서 컴포넌트가 클릭 동작을 가지고 있는게 아니라 컴포넌트를 가지고 있는 앱에서 클릭동작을 가질 수 있도록 하고 이를 주입하는 방식을 말합니다. Array.method나 TanstackQuery등도 마찬가지 이구요.\n\n=> OCP 원칙에 따라서 확장을 하는 것 상위로 위임하고 반복되는 구현의 세부사항은 하위로 숨기면서 의존성을 관리하는 방법을 항상 생각하면 좋겠습니다.\n\nQ) 큰 사이즈의 프로젝트에서 FSD를 사용한 케이스가 있을까요? 어떤 폴더 구조를 가지고 있는지 궁금합니다.\n\n=> 케이스에 대한 예시들은 인터넷에서도 찾아볼 수 있으나 회사의 코드들을 직접 보기는 힘든 것 같습니다. 일부 FSD를 도입했다 나아졌다는 사례등은 접할 수 있지만 대부분의 말미에는 FSD를 그대로 적용하지는 않았다는 식의 얘기들이 많은걸로 보아서 적절히 개념을 혼합해서 사용하는 형태가 되지 않을까 생각합니다. 에전에 아토믹 디자인 패턴이 그랬던것 처럼요. \n\nFSD를 그대로 쓰려고 하기보다는 현대적인 components, services, utils, hooks 등을 쓰더라도 코드를 계층적으로 모듈적으로 바라볼수 있는 계기가 되었기를 바래요. 나머지는 실무를 하면서 좋은 구조를 발견해나가시길 바래요.\n\n화이팅입니다! \n\n\n\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/32"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "수고했습니다. 지난 3주간 클린코드를 비롯한 소프트웨어 공학적으로 결합도 낮추기 응집도 높이기를 위한 이론과 프론트엔드에서의 적용등을 통해서 좋은 코드와 구조에 대한 다각도의 시야가 생겼기를 기대합니다.\n\n\"FSD를 유튜브, 블로그 등에서 듣기만 했고, 실제로 사용해본적은 없었는데 이번에 사용하면서 느꼈던 점은 아토믹 디자인 시스템을 만들었을 때와 비슷한 느낌이 받았습니다.\"\n\n\"하지만 공통적으로 느낀 단점은 원칙을 봤을 때는 각 레이어나, 단위 별로 정갈하게 정리된 서제처럼 모든 게 정확히 나누어질 것 같은데, 막상 실제로 도입해서 실무에서 경험을 하다보면 이 컴포넌트나 로직들을 어디다 둬야할지 애매모호한 부분들이 많았습니다. 뭔가 각 레이어나 단위 별로 한 다리씩 걸친 것 같고, 귀에 걸면 귀걸이 코에 걸면 코걸이 같은 느낌이 들었습니다. 그래서 이걸 의미있게 만들기 위해서는 동료 개발자들과 충분히 논의하고 롤을 정립해야되는데 이런 과정에서 굉장히 많은 시간이 소모되고, 끊임없는 고민과 선택 장애들이 이어져 피로감이 쌓이는 점은 단점으로 느껴졌습니다.\"\n\n맞습니다. 사실 FSD는 그동안 FE코드를 작성하다보니 어렴풋이 이런식으로 나눠지는것 같다는 아토믹 디자인 시스템과 같은 일종의 설명가능한 멘탈모델에 가깝습니다. component, hooks, services, utils, types의 기존 방식과 달리 모든 사람이 이 이론에 따라서 완벽하게 나눠서 만들어지는 형태는 아니기에 의의는 제공하지만 표준이 되지는 못하는 방식이죠.\n\n\"동료 개발자들과 충분히 논의하고 롤을 정립해야되는데 이런 과정에서 굉장히 많은 시간이 소모되고, 끊임없는 고민과 선택 장애들이 이어져 피로감이 쌓이는 점은 단점으로 느껴졌습니다.\"\n\n충분히 일리가 있는 말입니다. 반대로 말하면 좋은 규칙을 정하게 되면 앞으로 발생하는 고민과 선택에서 발생하는 피로감을 줄일 수 있다는 의미이기도 합니다. 규칙이 없다는게 좋은 규칙은 아니니까요. 그 규칙으로써 FSD가 모두가 납득하는 규칙은 아닐지언정 참고하기에 이만큼 세부적인 내용이 있는게 없기도 합니다. 그렇지만 이게 FSD를 써야만 하는 이유가 되지는 않는거죠.\n\n결합도는 낮게 응집도는 낮게 단일 책임을 가지고 가독성을 높인 일관성 있는 구조는 좋은 코드인건 분명 맞는데 그게 정확하게 뭐다 라고 정의하기에는 세상도 생각도 환경도 변합니다. 원칙과 트렌드에 맞게 더 나은 것들을 발견해가는 과정이겠죠. 그 과정 중에서 대다수가 합의하는 방식은 표준이 되어가고 아직 모르겠다 하는 것들은 논의등을 통해서 더 나은 것들을 발견해 나가는게 개발의 과정이라고 생각합니다. \n\n표준이 정답은 아니지만 표준이기에 배워야 하는게 있고, 논의가 되고 있는 것들에 대해서도 각 관점과 방향성이 어째서 제시되는가에 대해서도 함께 배워가면서 좋은 선택을 하려고 노력하는 방향으로 성장해가길 바랍니다. 수고많았습니다.\n\nQ) 리액트 쿼리의 캐싱 전략을 실제 서비스에서는 어떻게 가져가는지 궁금합니다. 저는 SI/에이전시에 회사에서 근무하다 보니, 고객 데이터를 기반으로 서비스를 확장해 나가는 경험을 해본적이 없습니다. 생각하기에는 어느 정도 규모가 있는 서비스라면 이러한 데이터를 활용해 다양한 캐싱 전략을 세울 것이라 생각하는데, 실제 현업에서는 어떻게 접근하는지 듣고 싶습니다.\n\n=> 리액트 쿼리의 캐싱 전략이 실제 서비스라고 뭐 특별히 더 달라지는 건 없습니다. 마찬가지로 도메인 기반의 쿼리키를 만들어 관리합니다. 다만 규모가 있는 서비스의 어려움은 깊이라기 보다는 그 규모 그 자체에 있죠. 지금의 과제처럼 만들어진 수많은 코드들을 최신 이론으로 변경하는 것은 쉬운 일이 아니고 과제가 5일짜리였는데 실제 서비스들 이 10배 100배 크다고 생각해보면 산술적인 계산으로도 100주면 1년이 걸리겠네요. 그 과정에서 놓치는것도 뺴먹는 것도 당장 하지 못하는 것들도 여러가지 현실적인 어려움들이 있죠. 그리고 그걸 어떻게 하면 좋을지를 고민하는 거라고 생각합니다.\n\n수고하셨습니다!\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/17"
    }
  },
  {
    "passed": false,
    "name": "김소희",
    "feedback": "수고했습니다. 지난 3주간 클린코드를 비롯한 소프트웨어 공학적으로 결합도 낮추기 응집도 높이기를 위한 이론과 프론트엔드에서의 적용등을 통해서 좋은 코드와 구조에 대한 다각도의 시야가 생겼기를 기대합니다.\n\n과제를 하다가 미처 다 완성을 못했나봐요. 아쉬웠겠네요. 그래도 FSD를 바탕으로 컴포넌트를 분리하고 각 코드의 계층을 고민하고 자기 자리를 만들어 보기 위해서 코드 작성을 꽤 많이 했네요. 꼭 이번주가 아니더라도 한번은 끝까지 완성을 해보기를 바래요.\n\n수고하셨습니다!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/44"
    }
  },
  {
    "passed": false,
    "name": "김수민",
    "feedback": "",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "김수현",
    "feedback": "안녕하세요 수현님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 다만 심화과제까지는 시간이 부족해서 진행하지 못한 것 같군요 ㅠㅠ\n\n> entities/comment/model/types.ts의 분리 기준\n\n사람마다 기준이 다르겠지만... 저는 분리하지 않아도 된다고 생각해요!\n해당 type은 react에 의존적이지도 않고 어디서든 쓰일 수 있기 때문에 일단 보존하면 어떨까요!?\n\n분리하고 싶은 이유가 있는지가 궁금하네요!\n\n---\n\n구체적인 내용에 대해 이야기를 나눠보고 싶다면 문의채널에 한 번 더 남겨주세요! 지금은 맥락이 많이 없어서 답변드릴 수 있는 내용이 많지 않네요 ㅠㅠ\n\n고생하셨습니다!!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/15"
    }
  },
  {
    "passed": false,
    "name": "김연수",
    "feedback": "",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "김유현",
    "feedback": "유현님 다른 의미로 고생을 하셨군요ㅠㅠㅠㅠ\n업무가 제일 중요한거니까..어쩔수 없었던 것 같네요.\n아무튼 과제는 언제든지 다시 할수는 있어도 함께 하시는 분들과 이야기 할 수 있는 시간은 생각보다 유효기간이 별로 안남았을 거에요. \n대강이라도 해보고 고민을 함께 나눠보시는 시간은 꼭 가지셨으면 좋겠네요.\n\n다음주는 화이팅입니다!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/33"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "수고했습니다. 지난 3주간 클린코드를 비롯한 소프트웨어 공학적으로 결합도 낮추기 응집도 높이기를 위한 이론과 프론트엔드에서의 적용등을 통해서 좋은 코드와 구조에 대한 다각도의 시야가 생겼기를 기대합니다.\n\n\"질문은 못하고 다른분들 코드나 토론하는거 들으면서 이렇게 생각하면서 짤 수 있구나를 많이 알게된 한 주였습니다.(항해 끝나면 꼭 나왔던 것들 정리하고 해보자 다짐도...)\"\n\n\"이번 과제를 통해 UI 기준(페이지별)으로만 구현하던 기존 방식에서 벗어나, FSD의 명확한 구분 기준을 어느 정도 적용할 수 있게 되었습니다. 완전한 적용은 아니지만, 이제 어느 정도 구분을 갖고 코드를 나눌 수 있는 기준을 갖게 된 것 같습니다.\"\n\n좋아요. 우리가 함께 토론하며 공부를 하고자 하는 것이 다른 사람의 관점을 우리가 옆에서 배울 수 있기 때문이죠. 다른 사람의 시야를 습득하는것은 아주 좋은 공부 방법입니다. 꼭 정리해보기 바래요!\n\n코드에 대한 구분이 생겼다는 것이 참 좋네요. FSD자체를 잘 하려고 하기 보다는 FSD를 통해서 고민했던 내용을 바탕으로 코드를 작성하거나 볼때 계층과 모듈을 한번 떠올려 볼 수 있게 되기를 바랍니다.\n\n\nFSD 구조의 적절성 - Post와 Comment 도메인 분리 : 현재 Post와 Comment를 별도 entities로 분리했는데, 실제로는 Post를 클릭하면 댓글을 불러오고, 댓글 추가 시 Post의 댓글 목록이 업데이트되는 밀접한 관계입니다. 이런 구조가 적절한지, 아니면 Post와 Comment를 하나의 도메인으로 통합하는 것이 더 나을지 리뷰받고 싶습니다.\n\n=> 서로 밀접한 관계이나 각자의 기능적 독립성이 있는 관계이므로 엔티티는 분리가 되는 것이 맞습니다. 엔티티는 interface를 기준으로 생각해보면 좋아요.\n\n\nQ) TanStack Query 쿼리 키 관리 전략 : 현재는 ['posts'], ['comments', postId] 와 같이 단순한 형태로 쿼리 키를 사용하고 있는데, 필터링이나 정렬이 추가될 경우 ['posts', { limit: 10, skip: 0, tag: 'react' }] 같은 복잡한 쿼리 키가 필요할 것 같습니다. 이런 경우를 대비한 쿼리 키 팩토리 함수나 구조화된 쿼리 키 패턴에 대한 조언을 구합니다.\n\n=> 네, 지금 접근하듯이 접근하면 됩니다. queryKey의 경우 REST api의 구조와 동일합니다. path는 배열로 searchQuery는 Object로 관리하면 됩니다. \n\n\nQ) 상태 관리 도구 조합 패턴 : Zustand와 TanStack Query를 함께 사용할 때, 특히 댓글 추가/수정 시 onSuccess에서 queryClient.setQueryData로 직접 캐시를 조작하는 현재 방식이 올바른 패턴인지, 그리고 더 나은 방법이 있는지 리뷰받고 싶습니다.\n\n=> 올바른 패턴이라기 보다는 서버의 응답을 기다리지 않고 화면의 데이터를 먼저 변경하고 적용하는 방식을 낙관적 업데이트라고 하죠. 이를 사용하기 위해서 Tanstack에서는 직접 캐시를 조작하는 방식으로 적용합니다. \n\n=> 낙관적 업데이트를 하면 사용자 경험이 확실히 좋아집니다. 로딩이 없는 것처럼 느낄 수 있죠. 그렇지만 그만큼 코드의 작성과 고민해야할 포인트가 늘어납니다. 사용성이 중요한 경우에는 꼭 해야하는 방식이고 그렇지 않은 경우에는 비용에 맞춰서 진행하면 됩니다.\n\n수고하셨습니다.",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/35"
    }
  },
  {
    "passed": true,
    "name": "김효진",
    "feedback": "효진님 고생하셨습니다~\n말씀해주신것처럼 이런 구조를 잡는데 있어서는 프로젝트를 관통하는 공통 규칙을 만들고 그것을 최대한 지켜서 작성하는게 가장 중요한 것 같아요.\n실제로 회사에서 적용을 할 때에도 팀원 각자가 생각하고 적용하는 범위가 다르게 될 때가 많거든요. 예를 들어서 탠스택 쿼리를 현재는 entity에 속해있는 경우가 있는데, 이 부분도 해석하는 사람마다 다르겠지만 단순히 해당 엔티티에 대한 페칭이 아닌 여러 액션을 담고 있는 부분이 있어 각 피처에서 다뤄야 한다는 얘기가 많은 것처럼요! 지금의 구조가 단순히 데이터를 조회하는 맥락이라면 엔티티의 위치도 좋지만 이렇게 되면 왔다갔다 하니까 규칙을 아예 만들어버리는 경우도 있구요 ㅎㅎ\n추가로 타입의 영역일 수 있지만, 현재 엔티티에서 엔티티를 import하는 경우도 있어서 위치를 잘 잡아야 할 것 같네요 ㅎㅎ 이런 것들을 미리 잡기 어려우니까 eslint 도구들을 잘 활용해봐도 좋을것 같아요.\n결국 레이어를 나누고 그 레이어간의 의존 방향을 강제하면서 확장성 있는 구조는 어디서 나오는지 등에 조금 더 집중해도 좋을것 같습니다.\n전반적으로 잘하셨어요!\n\n> props drilling을 써야하는 상황과 전역상태관리를 써야하는 상황이 구분될 수 있는 걸까요? 아니면 개발자가 선호하는 방향에 따라 정해지는 걸까요?\n\n절대적인 규칙은 없지만, 일반적으로 2-3뎁스 이상 들어가거나 함께 드릴링이 되는 갯수가 많은 경우 사용을 고민하게 되는 것 같아요. 다른 복잡한 규칙보다는 프로젝트 자체에서 드릴링되는 것을 운영하는 비용보다 전역 상태를 유지하는 비용이 적어진다고 판단하면 사용하는거라 생각해요ㅎㅎ \n\n고생하셨고 다음주 테스트도 화이팅입니다~~",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/29"
    }
  },
  {
    "passed": true,
    "name": "김휘린",
    "feedback": "수고했습니다. 지난 3주간 클린코드를 비롯한 소프트웨어 공학적으로 결합도 낮추기 응집도 높이기를 위한 이론과 프론트엔드에서의 적용등을 통해서 좋은 코드와 구조에 대한 다각도의 시야가 생겼기를 기대합니다.\n\n\"프론트에서도 entity기준으로 분리하면 코드 관리가 쉽다는 점을 느꼈다.\" \n\"하지만 UI가 포함될 때 부터 조금씩 막연하다.\"\n\n좋아요. 데이터, 화면, 행동이라는 3가지의 큰 축에서 엔티티를 기준으로 볼 수 있는 관점은 확실히 생긴것 같아요. UI는 데이터와 행동이 모두 포함되어 있는 조립파트이기에 책임과 계층이 복잡해서 분리하기가 어렵다 느껴지죠.\n\n이런 경우에는 최대한 데이터를 분리해내고 컴포넌트의 책임은 렌더링와 이벤트 핸들러에만 있다고 생각하고 나머지는 최대한 외부에 의존하려고 생각하면 좋습니다. (useEffect도 컴포넌트의 책임이죠.)\n\n지금은 뭐가 정답일까 고민하고 있기에 어렵게 느껴질 수 있지만 이제 시야과 관점이 생겼으니 개발에 적용하면서 실제로 도움이 되는 것 취하고 되려 불편함을 야기하는 것들은 버리면 됩니다. 그렇게 자신의 철학을 정립해나가는 것이죠! 수고하셨습니다.\n\n\nQ) 이렇게 도메인에 다른 도메인이 섞여있는 경우 다른 폴더와 공유하는 상태를 만들어도 괜찮을까요..?\n\n-> 네 상관없어요. 엔티티에는 관계라는 개념이 있고 1:N , N:N 등 엔티티간의 상호작용을 하거나 복합적인 도구가 되는건 관계없습니다. 계층을 의존성을 가지고 나누는건 맞지만 같은 계층의 경우라도 의존성이 생길 수 있었요.\n\n-> 의존성이 있더라도 결국 같은 계층이구나 라고 하는 미묘한 그 경계를 이애하보고 어쩄든 엔티티와 기능과 화면이 다른 경계에 속한다는 것을 기억하면서 자시만의 경계의 선명도를 잘 찾아가길 바래요 수고하셨습니다!\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/14"
    }
  },
  {
    "passed": false,
    "name": "박상수",
    "feedback": "안녕하세요 상수님!\n클린코드 마지막 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\ntanstack-query는 아직 적용이 안 되어서 심화과제는 불합격으로 남겨놓겠습니다..!\n\n특별한 질문은 없어서 궁금한점 있으면 문의채널에 남겨주세요! 감사합니다 ㅎㅎ",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/50"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "안녕하세요 소연님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> features 레이어는 '동작'을 담기 때문에 슬라이스의 폴더명도 동작으로 만들라는 내용을 봤는데요, 이럴경우 폴더가 엄청 많아지고 각 폴더에는 한두개의 파일밖에 없지 않나...? 라는 생각이드는데 아닐까요?\n이경우 제가 생각한 폴더명은 add-comment, delete-comment 이런 느낌일꺼 같은데 맞을까요?\n\n안녕하세요 소연님!\n\" features 레이어는 '동작'을 담기 때문에 슬라이스의 폴더명도 동작으로 만들라는 내용을 봤는데요\" 라는건 결국 소연님의 의견보단 그 글을 작성한 사람의 의견이라고 생각해요 ㅎㅎ 정답은 아닌거죠. 그 규칙이 마음에 들지 않는다면 소연님이 생각하는 규칙대로 만들어가면 된답니다!\n\n저의 경우 폴더 대신에 command 라는 이름으로 묶어서 사용할 것 같아요!\n파일 하나에 개별 훅들을 정의해서 사용한다거나!?\n\n다만 어떤식으로 정의하든 일관성이 제일 중요하다고 생각해요!\n어딘가에서는 폴더 + 개별 파일로 나누고, 어딘가에서는 하나의 파일로 선언하는 경우 일관성이 깨지고 불필요한 생각에 에너지를 사용하게 되는거죠.\n\n여튼 결론은, 소연님의 의견이 제일 중요하다는점! 누군가가 \"왜 이렇게 만들었어요?\" 라고 할 때 술술 나와야해요!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/7"
    }
  },
  {
    "passed": false,
    "name": "박의근",
    "feedback": "의근님~ 시간이 부족하셨던 것 같습니다.\n솔루션가 나오면 솔루션 코드를 확인해보는 시간은 따로 가지면 좋을 것 같습니다.\n좋은 주말 되세요~",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/43"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박준형",
    "feedback": "준형님 이번 주 과제도 잘하셨네요. \n뭔가 AI의 향이 느껴지는 회고 부분 부분도 있었는데 내용 전반적으로 잘 작성해주신 것 같아요 ㅎㅎ 작성해주신대로 모두 느끼고 이해하고 적용하셨다면 더할나위 없는 한주였을것 같네요.\n(개인적으로는 views로 보다는 pages로 그대로 작성하는게 더 의미상으로 맞아 보이네요 ㅎㅎ 각각 )\n탠스택 쿼리를 현재는 entity에 속해있는 경우가 있는데, 이 부분도 해석하는 사람마다 다르겠지만 단순히 해당 엔티티에 대한 페칭이 아닌 여러 액션을 담고 있는 부분이 있어 각 피처에서 다뤄야 한다는 얘기가 많이 있긴해요! 지금의 구조가 단순히 데이터를 조회하는 맥락이라면 엔티티의 위치도 좋지만 상태에 대한게 함께 전달이 되니 이렇게 되면 왔다갔다 하니까 규칙을 아예 만들어버리는 경우도 있구요 ㅎㅎ\n전반적으로 타입에 대한 것도 zod를 활용해서 별도로 많이 작성해주셨고 필요로 하는 여러 기능들도 부가적으로 잘 작성해주셨네요.\n\n> 캐시 무효화 책임: 엔티티 표준(쿼리 키 기반)으로 강제할까요, 아니면 피처가 상황별로 결정하도록 둘까요? 팀 합의가 가능한 단일 기준이 있나요?\n\n요런것들 때문에 엔티티에 쿼리가 들어가게 되면 여러 액션이 섞이게 되어 적절하지 않을 수 있다였는데요. 조회에 대한것만 entity에 있다면 표준적이게 쿼리키로 무효화를 하고 아니면 피처에서 별도로 처리하는 형태로 구현하는게 좋을 것 같아요. 아니면 키만 엔티티에 두고 feature에 애초에 쿼리를 두고 각각 사용에 맞춰 쓰는거죠.\n\n> 낙관적 업데이트/롤백: 실패 시 UI와 캐시를 어떻게 되돌릴까요? 동일 리소스에 대한 동시 업데이트 충돌은 어떤 규칙으로 중재하나요?\n\n요거도 위 질문과 이어지지 않을까 싶네요! l\n\n\n> 도메인 모델 변환: 서버 DTO 변화에 대비해 변환 레이어를 entities/model에 고정할까요? 언제 공유 타입으로 승격하고 언제 도메인에 남길지 기준이 있나요?\n\n이 질문도 약간은 이어지는 것 같은데요.\n모델에 위치시킨다는건 결국 그 모델에 대한 조회가 발생된다는 거에 해당이 될텐데, 실제로 조회를 했을 때 해당 정보만 내려오는게 아니라면 (또는 그것만 깔끔하게 발라내서 사용하는 딱떨어지는 형태가 아니라면) 모델에 두는게 적절하지 않을수도 있을것 같아요. 정보의 특성에 맞게 위치하게 두는게 좋지 않을까 싶습니다. 페이지에 가까우면 페이지에 두는것처럼요.\n아니면 쿼리의 select같은 것들을 활용해서 어댑터 처럼 사용하는 방식도 있을 것 같구요.\n공유 타입 승격에 대해 고민하게 되는것도 결국 자연스럽게 동일하게 사용되는 위치, 정보에 가깝게 두면 되지 않을까 싶습니다.\n\n고생하셨고 다음주 테스트도 기대되네요. 화이팅입니다!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/8"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박창준",
    "feedback": "수고했습니다. 지난 3주간 클린코드를 비롯한 소프트웨어 공학적으로 결합도 낮추기 응집도 높이기를 위한 이론과 프론트엔드에서의 적용등을 통해서 좋은 코드와 구조에 대한 다각도의 시야가 생겼기를 기대합니다.\n\n\"예를들어 post/create-post, post/update-post처럼 도메인(post) 아래에 관련 기능들을 배치하는 식으로 설계했고, 이렇게 하니 관련 기능이 한 곳에 모여 관리가 편리하고 기능별로 구조가 잘 분리되었습니다.\"\n\n\"우선 도메인 단위로 기능을 묶는 방식을 적용해보고 싶습니다. 실제로 과제를 해보면서 도메인 단위로 묶는게 굉장히 편리했는데 이렇게 하면 기능이 흩어지지 않고 관련 코드가 한 곳에 모여 있어서 유지보수가 편리할 것 같다고 생각했습니다. 또한 프로젝트 전반에서 공용으로 쓰이는 유틸이나 컴포넌트는 shared 폴더에 따로 모아 관리하면 중복을 줄이고 일관성을 높일 수 있을 것 같습니다.\"\n\n\"결국 읽기 좋은 코드는 커뮤니케이션을 코드로 대신하는거라고 생각합니다.\"\n\n오! 최종 폴더 구조가 너무 좋네요. 폴더 구조만 보아도 여기에 어떤 기능이 있고 어떤 구조와 코드가 들어가 있을지 상상이 될 수 있는 구조라서 너무 좋네요. 모르는 사람도 이 폴더 구조를 보면서 전체 프로젝트가 한번에 이해할 수 있게 만들어줄 거라 생각합니다. 잘 했어요!\n\n무조적적으로 쪼개는 게 능사는 아니고 실제로 자주 언급되는 추상화된 개념들과 실제 폴더구조의 구조적 개념이 일치하는가에 따라서 더 이해하기 좋다고 생각합니다. 해당 과제로 여러가지 많은 탐구를 해본 것 같아서 좋네요. 수고 많았습니다!\n\n\n\nQ1) 아까 회고에도 언급했던 FSD에 대한 적용 시점이 궁금합니다. 제가 고민했던 내용은 아래와 같아요\n1 초기부터 FSD를 도입하면 프로젝트 규모가 작을 때는 오버엔지니어링이 될 수 있음. 러닝커브, 팀원들 컨벤션 맞추고 하는것도 비용임. → 그래서 그냥 일단 빠르게 프로젝트를 시작하는게 더 좋을 수도 있다고 생각했습니다.\n2 반대로 프로젝트가 일정 수준 이상 커진 뒤에 도입하려 하면, 기존 구조에서의 전환 비용과 리스크가 크기 때문에 이 방향으로 리팩토링하기가 쉽지 않을것 같습니다.\n\n코치님이 생각하시기엔 초기부터 FSD를 도입하는게 좋을지, 반대로 점진적으로 리팩토링하면서 FSD를 적용하면 좋을지 궁금합니다.\n\n=> 저도 처음부터 다 폴더구조를 FSD로 만들지는 않습니다. 회고에서 기술해준대로 도메인을 기준으로 생각하고 정리하는건 좋은 관점이다보니 entities는 미리 준비하고 이후 components, hooks, api, pages 정도로 분리해서 조금씩 키워갑니다. 그러다가 어느정도 규모가 되었다고 판단되면 조금씩 이름을 바꿔가면서 재배치하게 되죠. 5주차 과제의 폴더 구조에서 6주차 과제의 폴더구조로 가는 그 어딘가쯤의 형태를 취하게 됩니다.\n\n=> 폴더구조는 도움이 되어야 하는 구조여야 하니까 처음에는 명확한 구분을 나중에는 기능과 도메인을 중심으로하는 구분 이렇게 만들고 있어요. 나름의 절충안을 잘 찾아보기를 바래요.\n\n\nQ2) 제가 설계한 폴더 구조에서 좀더 개선하거나 보완했으면 좋을것 같은 부분이 있을까요?\n\n=> 아주 잘했습니다. 폴더 구조자체로는 아쉬울게 없네요. 해당 과제로만 보면 본인도 작성하면서 느끼듯이 과할 수 있습니다. 지금의 구조를 기억하면서 실무에서 어디까지 하면 적정한가 하면서 실전감각을 익혀가 보기를 바래요!\n\n\nQ3) 이번 과제를 진행하면서 6기 동기들과도 굉장히 많은 토론(?)을 했는데, 각자 생각이 모두 달라서 하나의 기준을 정하기가 쉽지 않았습니다. 실제 현업에서도 팀원마다 의견이 다를 수 있을 것 같은데요. 이런 경우 보통 어떤 과정을 통해 합의를 이끌어내는지, 그리고 코치님이 경험하셨던 좋은 사례나 방법이 있다면 궁금합니다.\n\n=> 결정을 하는 경우에는 의견 대립이 생길 수 밖에 없지요. 정답이 없다는 얘기는 사실 뭘 선택해도 그렇게 까지 큰 상관이 없다는 얘기이기도 합니다. (물론 돌이킬 수 없는 선택이라면 신중해야겠죠?) \n\n=> 결정 혹은 합의에 있어 중요한건 그 전에 어떻게 결정을 하는지를 합의하는 것입니다. 리더가 정하기로 했으면 그 방법에 따르고 다수결이라면 다수결에 따르고 그러니까 논쟁거리가 아니라 그 방법 자체를 처음부터 합의를 해두고 나면 이후에는 충분한 논의를 하되 결정방식으로 우리가 합의한대로 진행하고 나머지는 그 방법을 믿어 준다는 형식으로 가면 좋을 수 있습니다.\n\n도움이 되었기를 바랍니다. 수고했습니다.\n\nBP 선정이유: 하나의 과제를 다채로운 시각으로 많은 도전을 해본것 같아서 다른 사람들에게도 참고가 될거라 생각해서 선정하였습니다.\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/24"
    }
  },
  {
    "passed": true,
    "name": "신홍준",
    "feedback": "안녕하세요 홍준님! 클린코드 마지막 과제 잘 진행해주셨네요 ㅎㅎ\n\n> FSD 너무 어렵습니다. 위 예시에 대한 해답도 궁금하지만, 이런 고민에 빠지지 않기 위해서 어떻게 코드를 작성해야 하는지도 궁금합니다.\n\n흠.. 말씀해주신 경우는 기본적으로 사용하는 디자인 시스템이 있다면 어느정도 해소되지 않을까!? 라는 생각이 들어요!\n가령 게시물 수정 기능은 feature인데, 버튼은 UI 표현이라서 별도로 분리하지 않아도 무방한거죠 ㅎㅎ\n이걸 디자인시스템을 통해 만든다면 고민을 하나 없애버릴 수 있겠죠!?\n\n말씀해주시 혼합 엔티티의 경우 entities가 맞다고 생각해요. 혼합이 되더라도 어쨌든 entities 라서요!\n다만 데이터의 구조가 혼합된것과 혼합해야 하는 로직을 만드는건 역할이 다를 수 있다고 생각해요.\nfeatures 혹은 widgets에서 이 역할을 수행해야 할 수 있겠죠!?\n\n이런 고민에 빠지지 않는건... 사실 어렵다고 생각해요 ㅋㅋ\n하나의 해답은 팀에서 죽이되든 밥이되든 정해진 규칙이 있고 이 규칙을 지켜가는거죠.\n\n모두가 납득하긴 어렵겠지만 어느정도 납득할 수 있는 공통 규칙이 이런 고민들을 해소해준다고 생각합니다.\n\n---\n\n고생하셨어요 홍준님!!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/4"
    }
  },
  {
    "passed": true,
    "name": "신희원",
    "feedback": "수고했습니다. 지난 3주간 클린코드를 비롯한 소프트웨어 공학적으로 결합도 낮추기 응집도 높이기를 위한 이론과 프론트엔드에서의 적용등을 통해서 좋은 코드와 구조에 대한 다각도의 시야가 생겼기를 기대합니다.\n\n\"복잡해 보이는 구조가 오히려 코드를 더 쉽게 관리할 수 있게 도와준다는 것을 알게 되었습니다.\"\n“엔티티는 정보, 피처는 행동”, “엔티티는 장보고, 피처는 맥주”\n\n좋네요! 복잡해 보이는 구조지만 구조가 복잡한게 아니라 원래 복잡한것들을 구분을 하다보니 복잡해지는 것이지요. 구조가 복잡해 보인다고 그대로 냅두는건 정답이 아니란걸 우리는 배웠잖아요!. 그 구조가 어째서 코드를 더 잘 관리하게 해주는지를 선명하게 느껴가는 시간이 되었기를 바래요. 수고하셨습니다!\n\nQ1. 현재 entities, features, widgets 구조로 작은 프로젝트는 잘 동작하지만, 기능이 많아질 때 어떻게 구조를 관리해야 할지 궁금합니다.\n\n=> 기능이 많아지고 복잡해지더라도 프론트엔드 라는 직군의 특성상 데이터, 화면, 행동이라는 3가지의 관점을 중심으로 하는 분류는 여전히 도움이 됩니다. FSD가 디자인 패턴과 같다고도 한 이유는 결국 사람들의 생각들을 구조화시키려다 보니 사실은 다들 유사한 관점들을 가지고 있는 것이니까요.\n\n=> 기능이 많아지더라도 접근은 동일합니다. 엔티티를 중심으로 데이터의 흐름을 만들고 화면을 계층별로 분리하고, 기능단위로 묶어서 관리한다. 다만 코드를 분리한다고 해도 여전히 조립이 필요하고 애매한 그레이 영역은 존재하기 마련입니다. 그것을 잘 풀어 나가는게 개발자의 역할이겠죠!\n\n Q2. 실제 대기업/스타트업에서 FSD를 적용하는 사례가 있나요? 어떤 규모 이상의 프로젝트에서 FSD를 쓰는 게 좋나요?\n\n=> FSD가 주목받은 몇 가지 요소 중 하나는 폴더구조라는 측면에서 표준화나 문서화를 시도한 방법이라는 점입니다. components, service, hooks, types 라는 전통적인 스타터킷은 프로젝트트 규모가 커지만 반드시 복잡성을 띄는 문제를 가져왔어요. 그렇지만 뾰족하게 이렇게 하면 좋겠다라는 표준같은건 없었어요. 저마다 생각이 다르고 폴더구조가 달랐죠. 폴더 구조에 대한 논의나 고민은 그전부터도 항상 만나면 하는 이야기중 하나였어요.\n\n=> FSD는 모든 프로젝트에 맞는 옷은 아니에요. 과제를 하면서도 느꼈지만 이건 여기에 둬야겠다 하고 누구나 공감하지는 못합니다. 그러다보니 시행착오가 있기 마련이고 그 시행착오들이 FSD에 대한 거부감을 느끼죠. FSD의 의의는 그 구조의 완결함보다는 서로 합의 해볼 수 있는 표준과 같은 역할을 해줄 수 있는게 있기에 누군가가 미리 배워올 수 있다는 점입니다.\n\n=> 대부분의 경우 FSD를 표준으로 하기 보다는 일부 마음에 드는 폴더나 방식등을 적당히 차용하고 있습니다. 과제를 하면서 FSD자체가 아니라 그걸 고민해보면서 계층과 모듈이라는 관점을 고민하면서 느낀 시야를 바탕으로 실제 프로젝트에 도움이 되는 구조를 한번 만들어 보세요. 그걸 잘 모르겠다면 FSD를 써보는건 어떨까요? 작은 규모에서 써보면서 오버같은 부분들을 발견하고 큰 프로젝트에서도 도움이 되거나 그렇지 않은 부분들을 직접 발견해보길 바래요!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/40"
    }
  },
  {
    "passed": true,
    "name": "양성진",
    "feedback": "성진님 고생하셨어요!\n회고를 보니까 이번주는 정말 고민이 많았던것 같은데요 ㅎㅎ\n전반적으로 잘 작성해주셨고 필요한 FSD규칙들에 대해서도 잘 정리해주신것 같아요.다만 규칙을 지키지 않고 엔티티에서 피처로 접근하거나, 피처에서 피처로 접근하는 경우가 있는 것 같네요! 이 레이어를 넘나드는 부분에 대해서는 정말 피치못할 상황이 아니라면 레이어를 끌어올려 처리하는게 좋을것 같아요.\n\n\n> 저는 이번에 fsd 아키텍쳐를 해보면서 너무 진입장벽이 높고 각각의 레이어들의 역할과 뭔가 feature나,widget내에서 어떤 컴퍼넌트는 어디로 들어가는지 이런 부분이 각자 토론도 하고 의견이 많이 갈렸고, 저도 이 과정에서 헷갈렸던 부분이 많았습니다. 그래서 오히려 이게 좋은 구조인가 라는 의구심도 가지게 되었습니다. fsd아키텍쳐에 대해서 코치님도 어떤 생각을 가지고 있는지 좀 궁금합니다.!!\n\n저희는 회사에서 이 규칙을 적용하고 있는데요. 사실 지금의 토론이 많이 갈리는 주제이겠지만 생각을 바꿔보면 저런 규칙이 없이 코드를 작성하다 보면 각자의 생각이 그냥 아무런 제약없이 녹여진다 라고 볼 수 있을 것 같아요. 그러다 보면 리뷰를 할 때 서로의 의견이 들어가다보니 반복적이게 논의를 해야 하는 경우도 많아지고 주제들이 프로젝트를 진행하면서 점점 산발적이게 생길것 같아요. 그럼 이 프로젝트를 운영하는 장기적 관점에서 이전에 논의했던것들은 자연스럽게 잊혀지고 결국 엉망진창 레거시 코드가 탄생하는 것 같아요. 하지만 FSD는 팀 내에서 미리 논의되어야 하는 주제거리를 던져 합의를 하게 하고 추후에 새로 들어오는 인원들은 별도의 논의 없이 이 규칙을 지키게 할 수 있게 되는거죠. 참여하고 있는 사람들도 '내 맘에는 안들지 몰라도' 적어도 프로젝트 자체가 잘 운영이되도록 코드가 작성되는것은 반박할 수 없을거에요. 그런 관점에서 접근을 한다면 나쁘지 않은 주제다!라고 생각할 수 있지 않을까요? ㅎㅎ(개발에 일가견 있는 분들끼리 저런거 하나하나 주제잡고 정하는건 늘 어렵고 빡센 일이니까요)\n\n고생하셨고 다음주차도 화이팅입니다!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/39"
    }
  },
  {
    "passed": false,
    "name": "양창훈",
    "feedback": "창훈님~ 시간이 부족하셨던 것 같습니다.\n솔루션가 나오면 솔루션 코드를 확인해보는 시간은 따로 가지면 좋을 것 같습니다.\n좋은 주말 되세요~",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/45"
    }
  },
  {
    "passed": true,
    "name": "여진석",
    "feedback": "(다른 분들이 진짜 리얼스톤 리얼스톤 해서 장난인줄 알았는데 깃헙 계정이 정말 realstone이었군요..)\n진석님 고생하셨습니다. 저도 준형님 영업으로 BMAD METHOD활용해서 코딩을 이리저리 해보고 있었는데, 이번에 큰 도움을 받으셨군요.ㅎㅎㅎ\n엔티티에 대한 구조도 잘 분리하셨고 전반적으로 위배되는 것들은 많이 없으셨던 것 같아요. 타입이지만 entity에서 entity를 improt하는 경우는 있는 것 같아서 이 부분에 대해서는 수정이 필요해보이네요. \n\n> list query detail query 엮는 방식\n\n지금의 작성 방식 처럼 detail과 list를 분리하고 공통으로 관리하는 키들을 가져와서 각각 조합해서 쓰는 방식을 사용하고 있어요 ㅎㅎ\n\n> FSD 위젯\n\n위젯의 역할이 사실 모호하긴하죠. 레이어에 대해 feature나 app에서 조합하기 애매하다고 느껴질 때 주로 위젯에 몰아넣는 경우들이 왕왕 있는것 같은데, 일단 앱에 두고 컴포넌트를 분리하는 것이 좋을 것 같아요.\n그리고 그 컴포넌트가 재사용성이 생긴다면 위젯에 두는것도 좋은 분리 방법일것 같아요.\n\n> AI와의 협업 패턴\n\n지금의 작업방식은 좋은 것 같아요! 구체적인 작업 지침과 파일명, 수정 방향까지 주고 작업을 맡기는거죠. 저는 이 부분에 있어서 중요한 건 인간의 피드백이 언제 들어가냐 인거 같은데요. 인간은 AI보다 작업의 단위가 적으니까 인위적이라도 단위를 내가 이해할 수 있는 범위로 나누고 검증 후 작업 루프를 만드는게 그나마 유지보수 성을 높이고 빠르게 개발하는 방법이 아닐까 싶습니다 ㅎㅎ 하지만, bmad의 방식은 그런것들을 전부 해주려고 하는 패턴이다 보니 결론이 나온 경우에 내가 이 코드를 이해하기 너무 힘든것 같아요 ㅎㅎ 애매하면 마지막에 작업한 것들을 내가 이해하기 명확하게 정리해서 문서로 줘 하고 파악하는것도 나쁘지 않은 방법일 것 같구요.\n\n고생하셨고 다음주는 AI 디톡스를 해야 하는데, 화이팅입니다!\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/2"
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "찬규님 고생하셨어요.\n꼼꼼하게 작성해주신 회고를 읽으니까 어떤 식으로 과제를 진행하셨는지 너무 잘 이해할 수 있었던 것 같네요 ㅎㅎ 엔티티에서 feature를 접근해서 사용하고 있거나 , 피처에서 피처로 접근하는 코드들이 있는것 같아요. 이런 부분 잘 체크해보시면 좋겠네요!\n그 외에 ky는 제가 별을 찍어놨었는데ㅋㅋㅋㅋㅋ이제서야 다시 꼼꼼하게 보게 되었네요. 좋은 시도였던것 같습니다 :+1 덕분에 다시 보게 되었어요.\n\n말씀해주신것도 있고 성진님 피드백에도 남겨뒀지만 저희는 회사에서 이 규칙을 적용하고 있는데요. 사실 지금의 토론이 많이 갈리는 주제이겠지만 생각을 바꿔보면 저런 규칙이 없이 코드를 작성하다 보면 각자의 생각이 그냥 아무런 제약없이 녹여진다 라고 볼 수 있을 것 같아요. 그러다 보면 리뷰를 할 때 서로의 의견이 들어가다보니 반복적이게 논의를 해야 하는 경우도 많아지고 주제들이 프로젝트를 진행하면서 점점 산발적이게 생길것 같아요. 그럼 이 프로젝트를 운영하는 장기적 관점에서 이전에 논의했던것들은 자연스럽게 잊혀지고 결국 엉망진창 레거시 코드가 탄생하는 것 같아요. 하지만 FSD는 팀 내에서 미리 논의되어야 하는 주제거리를 던져 합의를 하게 하고 추후에 새로 들어오는 인원들은 별도의 논의 없이 이 규칙을 지키게 할 수 있게 되는거죠. 참여하고 있는 사람들도 '내 맘에는 안들지 몰라도' 적어도 프로젝트 자체가 잘 운영이되도록 코드가 작성되는것은 반박할 수 없을거에요. 그런 관점에서 접근을 한다면 나쁘지 않은 주제다!라고 생각할 수 있지 않을까요? ㅎㅎ(개발에 일가견 있는 분들끼리 저런거 하나하나 주제잡고 정하는건 늘 어렵고 빡센 일이니까요)\n\n> API 기준 Feature 분리에 대한 피드백\n\n이런 기준은 너무 좋지만, 사실 말씀해주신것처럼 복잡한 비즈니스 로직에서는 유효하지 않을 수 있고..API자체를 순수하게 잘 나눠주시는게 아니라면 적용하기 어려울 수 있어요. 저희가 커뮤니케이션을 BE측과 명확하게 할 수 있다면 이 패턴이 좋겠지만 아니라면 어댑터 형태로 저희가 처리하는게 필요하지 않을까 싶습니다.\n\n> 전역 상태 관리의 적절한 범위\n\n좋습니다!\n\n> 실무 관점에서의 FSD 적용\n\n이 부분은 사실 새로 시작하는 프로젝트가 아닌경우에는 약간 어려운 것 같아요. 엔티티를 기반으로 잡고 개선해나가는게 필요한데 이 관점이 점진적으로 옮기면서 검증을 하면서 진행하기에는 어렵죠.. 그럼에도 옮겨야 한다면 명확한 단위의 계획이 필요할 것 같고 명확한 테스트도 함께 미리 구획을 한 다음 작은 단위로 하나하나 옮기는게 필요할 것 같습니다. 그리고 절대 이 이전 작업을 중간에 끊어서도 안될것 같아요.\n\n> 스프레드 연산자 사용: { ...options, method: \"GET\" } 방식이 매번 새 객체를 생성하는데, 성능상 문제가 없을까요?\n\n넵 크게 문제없을거에요!\n\n> 타입 체크: options에서 method를 덮어쓰는 방식인데, 사용자가 실수로 options에 method를 넣어도 무시되는 게 맞는 설계일까요?\n\n\n넵!\n\n\n고생하셨고 다음 과제도 잘 부탁드립니다!!!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/6"
    }
  },
  {
    "passed": true,
    "name": "오하늘",
    "feedback": "수고했습니다. 지난 3주간 클린코드를 비롯한 소프트웨어 공학적으로 결합도 낮추기 응집도 높이기를 위한 이론과 프론트엔드에서의 적용등을 통해서 좋은 코드와 구조에 대한 다각도의 시야가 생겼기를 기대합니다.\n\n\"테오.. 저 힘들었어요..... 🥺\"\n\n\"기능이 많으면 많아질수록 커지는 뎁스와 폴더들... 이게 맞나요? 저는 잘 모르겠어요. 하나의 기능에 대해 model, api, ui 등... 그리고 api 폴더 안에 api.ts는 하나밖에 없으니까 이 파일 하나를 위해 폴더를 생성하는 게 맞는지 모르겠어요. 지금은 관리자 대시보드 형식의 과제라서 구현한 기능이 그렇게까지 많은 것도 아닌데, 뎁스를 타야 하는 게 너무 많아요. 실무에서는 이걸 어떻게 적용하는지 궁금해요.\"\n\n힘들었군요. ㅋㅋ 좋은 징조입니다. 그렇게 고생한만큼 훨씬 더 머리속에는 잘 각인이 되었을거라고 생각해요. 의미있는 고생은 추억이라는 행복으로 보상해주니 결과론적으로는 좋은거에요 ㅎㅎ \n\n이게 맞나? 라는 고민 역시 좋은 포인트입니다. 사실상의 표준이 정립이 되기 전에는 다양한 관점과 제안이 나오기 마련이고 그 제안들을 실제로 내가 적용하면서 정말로 괜찮은지 안닌지를 판단할 수 있는 것은 매번 새로운게 만들어지고 바뀌는 개발자에게는 중요한 능력입니다. 본인에게 맞는것과 불편한 것들에 대해서 믿고 더 나은 방법은 뭐가 있을지를 항상 고민해보길 바래요. 잘했어요\n\n실무에서는 좋은 것은 받아들이고 아니다 싶은 것들은 나름 자신의 해법등을 적용해보게 되어 있습니다. 그러면서 또 새로운 제안등이 만들어지기도 하구요. 본인의 느낌을 믿고 더 나아지는 형태를 계속해서 찾아보길 바래요.\n\n\nQ) 테오! 저 커밋이 너무 많아요. ㅋㅋㅋㅋ 다른 분들은 많아 봤자 20-30개 정도인데, 저는 기능 하나 구현하고 수정할 때마다 히스토리 관리를 더불어 디버깅 차원에서 커밋을 매번 하는데, 이게 맞을까요? 좋을까요? 궁금합니다.\n\n=> 커밋이 많은건 나쁜게 아녜요. 아주 좋은 습관입니다! 다만 완성이 되어 있지 않은 (테스트가 깨지거나 빌드가 안되는) 커밋을 자주 해버리는건 좋지 않죠. 그런게 아니라면 아주 좋은 습관이니 꾸준히 그렇게 하기를 바래요!\n\n\nQ) * 위에서 말씀 드렸듯 파일을 한 개밖에 가지고 있지 않은 폴더 구조가 과연 맞는 걸까요? 폴더가 많으면 메타데이터 영역을 차지한다.. 라고 알고 있는데, 요즘 컴퓨터 사양이 많이 좋아졌으니 이런 말은 무시해도 되는 걸까요?\n\n=> 네, 폴더가 많다고 한들 메타데이터 영역이 그렇게 커지지는 않아요. 폴더1개에 파일 1개뿐인 폴더는 안 좋을 수 있죠. 만약 프로젝트 규모가 아직 그정도라면 세부 폴더를 굳이 만들지 않아도 괜찮다고 생각해요. 그게 아니라 일부 폴더 1-2개만 그런거라면 일관성을 위해서 통일하는게 맞다고 생각해요.\n\n=> 폴더구조는 결국 더 잘 이해하도록 하기 위해서 만드는 것이니 그게 도움이 안된다고 생각하면 도움이 되는 구조를 한번 고민해보면서 여러가지 변형을 만들어봐요. 그러나 일관성이 중요합니다.\n\n\"테오 덕분에 재미있는 과제 진행해 나갈 수 있었던 것 같아요. 3주 동안 감사 드렸습니다~\" \n=> 저도 고마워요 하늘!\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/18"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "안녕하세요 윤우님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 제가 만든 최종 형태의 폴더 구조의 단점이나 빠진 고려해야할 부분(또는 추가되면 좋을)이 있을까요!?\n\n안녕하세요 윤우님! 폴더 구조는 무척 잘 만들어주셨다고 생각해요!\n현재 미션에서 추가적으로 더 고려할점은 딱히 보이질 않네요..!\n개인적으로 FSD에 대해 더 디테일하게 고민해보기 위해선 여러 개의 페이지가 필요하다고 생각해요. 다만 지금은 페이지가 한 개라서 아쉽네요 ㅎㅎ\n\n> entities쪽에 tag, user에 대한 GET API가 존재하여 별도 slice 폴더로 구분하였습니다.\n근데 또 막상 tag 리스트는 게시물 리스트 필터에 이용되고, user또한 게시물쪽 데이터 추가에만 사용되는 구조인데 나누는게 좋았을까요?\n지금 보니 post로 편입하는게 나았을까? 하는 생각이 듭니다.\n\n흠.. 지금 보니 src 폴더가 있고 fsd_old 폴더가 있는데, old에서의 상황을 말씀해주시는 것 같군요 ㅎㅎ\n결국 각 엔티티간의 연관성 때문에 합칠까 말까를 고민하는 상황처럼 보여요.\n저는 이럴 때는 분리하는게 좋다고 생각합니다..!\n딱 지금 미션만 생각하면 분리할필요 없겠지만, 실무에서의 상황을 생각해보면 분리해놓는게 추후를 위해 좋지 않을까!? 라는 생각입니다. 어디서 어떻게 쓰일지 예측이 안 되니까요!\n\n> 현재 과제에서 분리하면 좋겠다! 싶은 순수함수를 찾지 못했습니다. 코치님이 보시기에 분리하면 좋을법한 부분이 있을까요?\n\n```tsx\nif (variables.postId && currentUser) {\n  queryClient.setQueryData(COMMENT_QUERY_KEY.detail([variables.postId]), (oldData: GetCommentResponse) => {\n    if (!oldData) return oldData\n\n    // 새 댓글을 목록에 추가 (userId 1의 실제 사용자 정보 사용)\n    return {\n      ...oldData,\n      comments: [\n        ...oldData.comments,\n        {\n          id: Date.now(), // 임시 ID\n          body: variables.body,\n          postId: variables.postId,\n          user: {\n            id: currentUser.id,\n            username: currentUser.username,\n            image: currentUser.image,\n          },\n          likes: 0,\n        },\n      ],\n      total: oldData.total + 1,\n    }\n  })\n}\n```\n\n이게 useCrateComment 내부의 함수인데요,\n여기서 새로운 comment를 만들어내는 부분도 순수함수로 분리할 수 있다고 생각해요.\n이렇게 쓰이는 모습을 상상하시면 좋답니다!\n```tsx\nif (variables.postId && currentUser) {\n  queryClient.setQueryData(COMMENT_QUERY_KEY.detail([variables.postId]), (oldData: GetCommentResponse) => {\n    if (!oldData) return oldData\n\n    // 새 댓글을 목록에 추가 (userId 1의 실제 사용자 정보 사용)\n    return {\n      ...oldData,\n      comments: [...oldData.comments, createNewComment(variables, currentUser)],\n      total: oldData.total + 1,\n    }\n  })\n}\n```\n\n이 외에도 훅 내부에서 데이터를 다루는 구간은 다 분리할 수 있으리라 생각해요 ㅎㅎ\n\n이렇게 컴포넌트 내부에 있는 로직도 마찬가자입니다.\n```tsx\n  const [searchParams, setSearchParams] = useSearchParams()\n\n  const handleSortOrderChange = (sortOrder: string) => {\n    setSearchParams((prev) => {\n      const updated = new URLSearchParams(prev)\n\n      updated.set(\"sortOrder\", sortOrder)\n      return updated\n    })\n  }\n```\n\n이런 모습을 상상해보시면 좋을 것 같아요.\n\n```tsx\n  const [searchParams, setSearchParams] = useSearchParams()\n\n  const handleSortOrderChange = (sortOrder: string) => {\n    setSearchParams((prev) => updateQueryParams({ sortOrder }))\n  }\n```\n\n아니면 별도의 훅을 하나 만들어서 사용한다거나!?\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/13"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "윤영서",
    "feedback": "이번주 과제도 훌륭합니다.\nFSD규칙을 명확하게 지켰고, 명확한 규칙을 가지고 잘 나눴습니다.\n모범사례로 볼 수 있을것 같아요.\n\n> features를 어디까지 분리해야할까에 대한 고민\n\n말씀해주신 부분이 적절한 분석인 것 같아요. 버튼까지 나눌 필요가 있나 싶긴해요. 단순히 '분리' 관점에서 해당 부분을 고민하고 나눈다면, 재사용성에 대한 판단이 흐려지고 일단 나누고 보는 관점이다보니 응집도도 낮아지구요. 지금과 동일한 규칙대로 운영하면 될 것 같아요.\n\n> 전역상태 관련 고민\n\n저도 구체적이게 작성한 설명을 보니까 어떤 고민을 하게 되었는지 명확하게 이해가 되었는데요. 일단 필요하지 않으면 굳이 사용할 필요는 당연히 없습니다. 결국 서버 상태를 제외하고 전역 라이브러리를 사용한다는 것은 드릴링을 방지하는것도 있지만, 복잡한 상태 동기화 등에서도 고려할 수 있는 부분이지만 설명을 들어보면 사용하지 않아도 된다고 저는 생각해요.\n\n지금의 구조가 comment에 대한 UI가 모든 곳에서 재사용 될 수 있는 관점이라면 entity에 위치하는게 적합할 수는 있지만, 지금같으면 아예 page에 컴포넌트 자체를 끌어올려야 할 수도 있겠네요.\n\n제 개인적으로는 이렇게 생각하는데, 이 의도에 대해서는 발제자님께 명확하게 질문해보는게 가장 명쾌한 것 같습니다.\n\n다음주도 화이팅입니다.",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/20"
    }
  },
  {
    "passed": true,
    "name": "이가은",
    "feedback": "(진석님은 리얼스톤인데 이가은님 계정은 tooth is silver였군요...? 두 분 원래 아시던 사이였나요..?)\n가은님 고생하셨습니다. \n회고를 엄청 정성스럽게 작성해주셨는데, 읽어보니 어떤 과정으로 과제를 진행하셨는지 너무 잘 이해가 되네요. 모호한 규칙들을 잡고 가려는 노력들이 특히 좋았습니다! 사실 현업에서도 적용을 하는데 있어서 글로 작성되어있는 여러 규칙들을 반영하려다 보면 프로젝트 성격에 맞춰 다시 협의가 필요한 부분들이 많이 있거든요. 이런 경험들이 추후에 만약 실무에서 적용을 하시려 한다면 큰 도움이 되지 않을까 싶습니다.\n\nPostList.tsx에서는 feature레이어에 접근을 하고 있는 것처럼 보이는데요! 피처와 피처간에 접근은 금지되어있어서 주의해야 할 것 같아요.\n이런것들 때문에 보통 alias를 통해 가독성을 좋게 하고, 린트룰을 적용하는 것 같은데 잘 챙겨야 할거 같습니다 ㅎㅎ 결국 언급하는 장점은 이런 규칙을 명확하게 지켰을 때 오는거라서요.\n\n> page 내부의 useEffect\n\n훅 내부에서 처리를 하면 어땠을까 싶긴 한데요! 한번에 처리되는 값들이 많고 컴포넌트 내부에서 처리가 많은 부분들이다 보니 별개로 분리했으면 가독성이 더 올라가지 않았을까 싶네요!\n\n> page 내부의 게시물 상세\n\n넵 맞아요! 정확한 판단입니다. 피처가 다른 피처를 children으로 받는 것은 위배되는 규칙인 것 같아요. 이런 부분을 위젯으로 분리해 사용하는 것도 방법이고 페이지에서 불러서 사용하는 것도 방법일 것 같아요. 페이지에서 일단 사용한 다음 여러 곳에서 재사용성이 높아진다거나.. 아니면 위젯 자체의 사용성과 맞는 컴포넌트라면 위젯으로 구현을 시작하는것도 좋은 방법일 것 같네요.\n\n고생하셨고 다음주도 화이팅입니다!!\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/19"
    }
  },
  {
    "passed": false,
    "name": "이민재",
    "feedback": "안녕하세요 민재님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ\n\n> 제가 직접 FSD 구조 설계를 경험해보니 ‘좋은 코드’에는 정답은 없는 것 같습니다. 다만, 구성원들의 경험마다, 애플리케이션 규모, 비즈니스 모델, 환경 등에 따라 구성원들에게 더 좋은 경험을 제공해줄 수 있는 코드를 작성하는 것이 ‘좋은 코드’를 작성하는 것이다라는 것을 배웠습니다.\n\n좋은 인사이트라고 생각해요! 코드에 대한 정답보단 나의 생각을 찾아가는 과정이라고 생각합니다 ㅎㅎ \n\n> 위 내용처럼 Features 계층의 규모가 적절한가? 단점을 고려하여 설계한 구조가 적절했는지? 더 나은 방법이 있다면 어떤 방법인 사례가 있을지 궁금합니다!\n\nwidget 에다가 책임을 몰아넣을 수도 있을 것 같아요 ㅎㅎ\n결국 기능이 많아지면 어떤 구간은 뚱뚱해질 수 밖에 없는데, 어떤 구간에 이를 몰아주는게 좋을까? 에 대한 결정이라고 생각합니다.\n저희 팀은 use-case 라는 계층을 하나 더 만들어서 진행하고 있땁니다!\n\n---\n\n고생하셨습니다 민재님!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/12"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이유진",
    "feedback": "수고했습니다. 지난 3주간 클린코드를 비롯한 소프트웨어 공학적으로 결합도 낮추기 응집도 높이기를 위한 이론과 프론트엔드에서의 적용등을 통해서 좋은 코드와 구조에 대한 다각도의 시야가 생겼기를 기대합니다.\n\n\"이번 과제는 AI 도움을 최대한 받지 않고 진행했습니다. 회사에서 리액트를 사용하지 않아서 이 기회에 리액트를 제대로 경험해보고 싶기도 했고, 4,5주차에 배웠던 내용들을 최대한 스스로 적용해보고 싶었습니다.\"\n\n\"과제를 딱 처음 받았을 때는 뭐부터 분리해야 할지 여느때처럼 막막했는데요, 4,5주차를 경험하고 나니 그래도 전보다는 수월하게 분리를 하고 있다는게 스스로 느껴졌어요. 아직 많이 부족해도 지난주보단 조금이라도 나아졌구나...!가 느껴져서 기뻤습니다.\"\n\n\"테오가 멘토링때 해주셨던 [ 일단 결합도를 낮춰놓으면 응집도를 높이는건 어려운게 아니다! ] 라는 말을 계속 생각하면서 과제를 진행했어요.\" \n\n\"FSD 보다는, 결합도를 낮춰야 한다!는 말을 계속 생각하며 개발을 하고 싶습니다. 결합도가 낮으면 유지보수면에서도 훨씬 좋을 것 같은데, 어떻게 결합도를 낮출 수 있는지, 어떻게 하면 분리를 잘 할 수 있을지는 조금 더 많은 연습과 고민이 필요합니다.\"\n\n코드를 살펴봤는데 잘했습니다. 결합도를 낮춰둔 것이 실제로 도움이 되는지는 나중에 그렇게 분리해둔 코드로 요구사항 수정과 개선 과정에서 어려움을 겪지 않을 때 느낄 거에요. 이게 웃긴게 결합도를 낮춰놔서 일을 쉽게 한건 사실 체감이 잘 안되요. 안될때에만 뭔가 이상하다 느끼기 때문이죠. \n\n\"실무에서 사업 요건에 따라 유지보수 해야하는 경우가 종종 있는데, 어떤 코드는 유지보수하기 쉽고, 어떤 코드들은 그렇지 않다는 걸 매번 느꼈습니다. \" \n\n에서 그렇지 않은 코드들을 경험하는게 적은 것으로 느껴보기를 바래요! 이번에 과제를 하면서는 결정과 선택을 하는데 에너지를 많이 써서 힘들게 느껴졌겠지만 어느순간 이렇게 하는게 편하네 하는 것들은 별 에너지 없이 좋은 코드를 작성하고 있을 거에요.\n\n화이팅입니다! 수고많았어요!\n\n\nQ. 사실 저는 대부분 사람들이 그렇게 사용하니까 배럴파일을 사용해서 export를 하고 있긴 한데요... 사실 import 할 때 경로가 간단해서 보기 깔끔하다..! 말고는 좋은점을 모르겠어요. 오히려 index.ts 파일이 너무 많아져서 어느 계층에 있는 index 파일인지 체크하면서 개발하기가 오히려 더 불편한 것 같은데, 제가 배럴파일을 잘못 쓰고 있어서 그 장점을 못느끼는건지 궁금합니다..!\n\n=> 의견이 분분한거 보면 여기도 정답보다는 취향의 영역인것 같습니다. 개인적으로 배럴파일을 좋아하지 않습니다. 배럴방식의 장점은 하위 레이어의 구현 코드를 수정하고 변경해도 상위 계층의 import를 변경하지 않아도 된다는 장점이 있죠. 또한 외부로 export해야하는 것을 한 곳에서 보고 관리할 수 있다는 면이 있습니다. import 문이 깔끔한것도 있지요.\n\n=> 반면 tree-shaking이나 관리의 복잡도 index파일이 늘어나는 것. 그리고 index파일을 알아보기 어렵다는 단점이 존재합니다. 장점이 단점보다 좋은냐 하는 점인데 저 개인적으로는 장점이 단점을 압도한다 보기 어려워 저는 배럴을 사용하고 있지 않아요. 유진도 그렇게 느꼈다면 사용하지 않아도 좋습니다. 언제나 지금처럼 본인이 직접 경험해보고 판단하는건 중요한것 같아요. 그리고 언제든 또 상황에 따라 바뀔 수 있기에 최대한 장점을 느껴보고자 노력을 하면서 마음을 열어두는것과 그래도 본인의 느낌을 믿고 결정하는 것이 필요할거에요. 스스로를 충분히 믿을 수 있을 만큼 이해해보고 결정하면 될것 같아요!\n\nBP 선정 이유: 작성한 코드가 일관성 있게 충분히 결합도가 낮은 좋은 구조로 분리를 했기에 참고가 될 수 있을거라 생각하여 선정하였습니다.\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/22"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이은지",
    "feedback": "수고했습니다. 지난 3주간 클린코드를 비롯한 소프트웨어 공학적으로 결합도 낮추기 응집도 높이기를 위한 이론과 프론트엔드에서의 적용등을 통해서 좋은 코드와 구조에 대한 다각도의 시야가 생겼기를 기대합니다.\n\n\"이전에는 새로운 기능을 추가할 때마다 \"이 코드는 어느 폴더에 넣지?\"라고 고민했는데, FSD를 적용하고 나니 자연스럽게 적절한 위치가 보이더라구요.\"\n\"FSD 구조를 기반으로 모듈을 분리하고 위치시키면서 각 모듈에 대한 기능, 역할에 대해 더 얇은 레이어로(?) 디테일하게 생각해볼 수 있었던 것 같습니다. \"\n\n수고했습니다. 코드를 보니 다양한 시도들을 해본 것 같아서 너무 좋네요. 특히 이번 과제는 정답이 있는게 아니라 여러가지의 선택지가 있는 문제에서 다양한 관점 그자체들을 고민하고 배우는데 있었는데 잘 해준 것 같아 좋습니다.\n\nFSD라는 틀을 통해서 바라보면 그전에 희미했던 코드의 계층과 구조에 대해서 조금 더 잘게 선명하게 보일 수 있을 거에요! 나머지는 실무를 통해서 폴더구조가 아니라 코드의 계층과 역할 그리고 자리를 떠올려볼 수 있게 되기를 바래요 :)\n\nQ) 질문 1: FSD 아키텍처에서 도메인 중심 슬라이스 설계의 적절성\n=> 폴더구조는 일종의 멘탈 모델입니다. 사실 폴더구조가 어떻든지 간에 대부분 코드는 검색해서 찾아가고 결합도만 낮다면 스파게티 코드가 되지는 않습니다. 그렇지만 내가 시각적으로 드러나는 구조가 내 머리속의 지도가 되어 주기에 폴더구조만큼의 생각 구조를 머리에 담을 수 있죠.\n\n=> 세분화를 하는게 좋으냐 아니냐는 실제 기획단위의 대화에서 어떤 관점으로 보느냐가 중요합니다. 이번 과제의 경우 포스트 삭제 편집 생성 기능을 분리하지 않아도 될거라고 생각해요. 일부 기능만 on/off를 하거나 변경하거나 하지는 않을 것 같아요. 그렇지만 기획하고 만드는 과정에서 하나씩 분리해서 다루고 말하고 기획서가 되어 있다면 나눠주는게 더 낫습니다. 저는 가급적 기획서에 가깝게 혹은 말하는 그대로의 폴더구조를 만들고 싶거든요.\n\n\nQ) 질문 2: 낙관적 업데이트의 선언적 모듈화 방안\n\n=> 패턴이 반복되는 것은 함수형 프로그래밍을 풀 수 있습니다. 우선 동일한 함수에서 변경이 되어야 하는 부분을 인자로 받는 함수를 만들고 이를 통해서 원 함수를 다시 작성을 하면 뼈대만 사용하고 나머지는 교체하는 템플릿 메소드 패턴을 함수로 만들 수 있습니다. (코드 예시는 이 내용으로 AI에게 알려달라고 해보세요)\n\n그렇게해서 유사한 코드 패턴을 템플릿으로 교체하면서 작성하게 되면 자연적으로 선언적 모듈화가 됩니다. 무조건 이 방식이 더 나은 코드를 만들지는 않습니다. 어떻게 구성을 하느냐에 따라서 유연성없고 불편한 코드가 되거나 변하지 않은 부분이 잘 감춰진 멋진 라이브러리가 될 수 있어요. \n\n\nQ) 질문 3: 다중 쿼리 타입 환경에서의 캐시 동기화 전략\n\n잘했습니다. TanstackQuery가 제안하는 표준적인 방식입니다. 이렇게 서버데이터를 클라이언트 상태관리를 대신해서 관리할 수 있도록 해주는 거죠. 실무에서도 이런 방식으로 활용합니다.\n\nBP 선정이유 : 과제를 하면서 많은 고민들을 담아내어보고 시도를 많이 해본 것들이 잘 느껴졌습니다!\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/48"
    }
  },
  {
    "passed": true,
    "name": "이의찬",
    "feedback": "수고했습니다. 지난 3주간 클린코드를 비롯한 소프트웨어 공학적으로 결합도 낮추기 응집도 높이기를 위한 이론과 프론트엔드에서의 적용등을 통해서 좋은 코드와 구조에 대한 다각도의 시야가 생겼기를 기대합니다.\n\n\"이번 과제를 진행하면서, FSD는 비즈니스의 복잡성으로 인해 요구사항의 변화에 따라서 코드가 계속 갈아엎어지는 부분을 해결하려고 레이어 사이를 분리해 두었던 게 아닐까? 라는 생각이 들었습니다.\"\n\n\"결국 어떤 상황에 어떤 구조를 선택해야할까?에 대해서는 아직 막연하게 느끼는 것 같아서 아쉽습니다.\"\n\n프론트엔드는 그동안 빠르게 변화해왔습니다. 하나의 정답을 두지 않고 프레임워크를 제안하고 CSS 라이브러리를 제안하고 상태관리끼리 경쟁하며 발전해왔죠. 그리고 차츰 대부분이 사용하는 사실상 표준과 같은것들이 만들어졌습니다. prettier의 경우도 포맷터 논쟁은 예전에는 엄청나게 많았지만 사실상 표준이 생겨버렸죠. 폴더구조는 아직 표준 정립 전 뭐가 나은지를 탐색하고 있는 단계라고 생각해요. 그리고 아마 언젠가는 사실상 표준적인 구조가 만들어질 거에요.\n\n모든 개발이 그렇습니다. AI도 마찬가지로 누가 더 어떤게 정답인지 모른채 저마다가 잘하고 있다고 믿는 쪽으로 찾다가 자연스레 Think mode, Agent, MCP 등으로 정립이 되는 것처럼요.\n\n그렇지만 표준이 정립되기 전까지에는 가장 나은게 무엇일지 찾아야 합니다. 그리고 개발은 앞으로도 이러한 사이클이 반복이 되는 만큼 많이 고민을 해봐야겠지요\n\n\"테오가 FSD에 대한 내용은 개념만 남기고 잊으라고 했지만, 사실 이 구조가 썩 마음에 들어서 실제로 한번쯤 사용해보고 싶은 마음은 있습니다. 물론 적절하게 사용할 수 있는 기회가 온다면요!\"  화이팅입니다!\n\nQ) 이번 챕터에서 가장 어려운 것은 결국 어디까지 함수를 쪼갤 것인가와 폴더 구조를 무엇을 근거로 선택할 것인가 두 가지라고 생각해요. 제가 생각해도 굉장히 막연한 질문이긴 한데, 혹시 테오는 이 두 가지에 어떤 기준을 가지고 하시는지를 알려주시면 감사드리겠습니다!\n\n=> 제가 솔루션으로 작성했던 엔티티, 순수함수, useQuery, useMutation, lib, util hooks, UI 컴포넌트, 도메인 컴포넌트, 컬렉션, 템플릿, 레이아웃 정도까지는 기계적으로 분리를 합니다. 검증이 된 계층이니끼요\n\n=> 폴더 구조의 경우 가급적 기획서를 따르려고 합니다. 정확히는 실제로 어떻게 추상화해서 다루고 있는지요. 가령 이번 과제에서 포스트 검색기능이라고 부르고 있다면 포스트 검색 기능을 폴더로 만들고 포스트 관리라고 칭한다면 묶을거에요. 폴더구조는 멘탈모델이 되어 주어야 한다고 생각합니다.\n\n=> 그 밖에 저는 interface가 가장 적게 만들어져야 한다고 생각해요. 그래서 인자나 리턴값에 별도로 타입들이 만들어지는게 많다면 좋은 구조는 아니라고 생각하고 있어요. 최대한 적은 코드로 적은 계층 적은 타입만 가지고도 가능한 코드가 되는 방향으로 만들고자 합니다.\n\n도움이 되기를 바래요! 수고하셨습니다.",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/38"
    }
  },
  {
    "passed": false,
    "name": "이정우",
    "feedback": "정우님 고생하셨습니다.\n체크리스트를 모두 채워주시려고 노력했지만, 적절하게 나눠주셨다고 보기에는 어려운것 같아요. 모두 한 곳에 상태가 모여있어서요 ㅠㅠ\n이 부분에 대해서는 조금 더 고민을 해보고 다른 분들 코드를 참고해보셔도 좋을 것 같아요! 아쉽지만 체크리스트를 모두 완성했다고 보지 못할것 같아 통과하지 않은 것으로 처리하겠습니다.\n\n> 대규모 프로젝트에서 Query 캐시 키를 어떻게 체계적으로 관리하시는지?\n\n지금의 키 관리 방식도 좋고 라이브러리를 사용하는 것도 좋을 것 같아요. 리스트와 디테일을 계층으로 구조화해서 무효화 할때 함께 처리할 수 있는 구조를 늘 염두해서 작성하면 좋을것 같아요!\n\n> 디자인 시스템을 별도 패키지로 뺄 때 파일/버전 구조 팁이 있다면?\n\n요거는 따로 뭔가 과제와 직접적으로 연결이 되는 질문은 아닌것 같은데요! 버전은 가능하다면 semver를 따르도록 하는게 이상적인것 같고, 파일 관련되서는 각각 컴포넌트를 구성하시는 것과 크게 다르지는 않을것 같아요. 대신 디자인 시스템이니까 외부에서 사용할 수 있는 API 인터페이스를 늘 고려해서 작성해야 한다 라는게 중요하지 않을까! 이 관점에서 요즘 radix ui나 shadcn같은 개념이 많이 인기가 있으니 이것도 참고해봐도 좋겠네요!\n\n> FSD 쓰실 때 “이건 공통인가? 기능 폴더인가?” 경계 기준을 어떻게 정하시는지 듣고 싶어요.\n\n이 부분은 미리 예측을 하고 처리를 하는것도 좋지만, 작성을 하고 중복되는 것이 관찰될 때 옮기는게 가장 좋은 방식이에요. 중복해서 사용할것이라고 예측을 하고 분리했는데도, 사용성이 달라져 따로 다시 작성하는 경우들도 많거든요. 비슷한 구조가 여러번 등장하게 되면 순수함수로 분리해보고 비즈니스 로직에 있어서 만약 여러번 등장하게 된다면, 같은 이유로 수정을 하게 되는지 검토한 다음 공통 함수로 분리하면 좋을 것 같아요!\n\n고생하셨고 다음주 테스트 과제에서 인사드리겠습니다. 화이팅!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/36"
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "안녕하세요 지현님! 클린코드 마지막 과제 잘 진행해주셨네요!\n\n> 코치님 이라면 이 과제에서 전역상태 라이브러리를 어느 부분에서 사용하실 것 같나요?\n\n저는 아마 사용하지 않았을 것 같아요 ㅎㅎ\n제가 생각하기에 전역상태는 도메인 상태를 다루는 경우에 필요한데, 지금은 이걸 tanstack-query로 다루고 있고\n나머지는 context를 사용하면 되지 않을까!? 라고 생각합니다.\n\n혹은 그냥 context 대신에 jotai나 zustand를 사용해봐도 무방해보이긴해요!\nui 전역 상태는 context를 사용하는 편이라..\n\n> 과제에서 게시글 목록 필터의 쿼리스트링을 편하게 관리하기 위해서 커스텀훅을 만들었습니다. 이 훅 구현의 방향성 및 파일 경로에 대해서 궁금증이 있어 질문드립니다.\n\n일단 디바운스 적용한건 좋은 것 같아요!\n\n지금 제일 큰 고민이 query의 기능이 post에서 쓰이는데 이걸 합치는게 좋을지 안 좋을지에 대한 고민인 것 같네요 ㅎㅎ\n저는 좋다고 생각해요! 일단 usePostsQuery 라기보단 usePostFilter 라는 이름으로 사용해주면 어떨까요? 다만 이 filter가 query랑 연계되어있는거죠 ㅎㅎ\n\n```tsx\nconst searchQuery = useSearchQuery();\nusePostFilter({ onUpdate: searchQuery.update })\n```\n\n그리고 이런 모습을 상상해봐도 좋답니다!\n\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/41"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "이지훈",
    "feedback": "회고에 있는 그림이 엄청 직관적이네요ㅋㅋㅋㅋ덕분에 어떤 과정을 거치셨는지 잘 이해할 수 있었습니다. 고생하셨습니다 지훈님.\n전반적으로 핵심적인 부분들을 잘 이해하고 적용해주신 거 같아요!\n탠스택 쿼리를 현재는 entity에 속해있는 경우가 있는데, 이 부분도 해석하는 사람마다 다르겠지만 단순히 해당 엔티티에 대한 페칭이 아닌 여러 액션을 담고 있는 부분이 있어 각 피처에서 다뤄야 한다는 얘기가 많이 있긴해요! 지금의 구조가 단순히 데이터를 조회하는 맥락이라면 엔티티의 위치도 좋지만 상태에 대한게 함께 전달이 되니 이렇게 되면 왔다갔다 하니까 규칙을 아예 만들어버리는 경우도 있구요 ㅎㅎ\n\n> 코치님은 현재 어떤 폴더 구조를 사용하고 계신지 궁금합니다. 사용중인 폴더 구조에서 장점과 단점은 어떤게 있나요? 질문의 의도는 단순히 사용중인 폴더 구조가 궁금한 것과 폴더 구조를 다룰때 어떤걸 더 중요하게 생각 하시는지 궁금합니다.\n\n저는 아쉽게도(?) FSD를 쓰고 있어요 ㅎㅎ\n팀 내 프로젝트에 작년에 도입을 했는데 꽤나 좋은 사용성을 갖고 있습니다. 저는 늘 통일된 규칙을 갖는것 일관성이 가장 중요하다고 생각하는 편인데요. (그게 나쁜 규칙이라도)\n저희는 회사에서 이 규칙을 적용하고 있는데요. 사실 지금의 토론이 많이 갈리는 주제이겠지만 생각을 바꿔보면 저런 규칙이 없이 코드를 작성하다 보면 각자의 생각이 그냥 아무런 제약없이 녹여진다 라고 볼 수 있을 것 같아요. 그러다 보면 리뷰를 할 때 서로의 의견이 들어가다보니 반복적이게 논의를 해야 하는 경우도 많아지고 주제들이 프로젝트를 진행하면서 점점 산발적이게 생길것 같아요. 그럼 이 프로젝트를 운영하는 장기적 관점에서 이전에 논의했던것들은 자연스럽게 잊혀지고 결국 엉망진창 레거시 코드가 탄생하는 것 같아요. 하지만 FSD는 팀 내에서 미리 논의되어야 하는 주제거리를 던져 합의를 하게 하고 추후에 새로 들어오는 인원들은 별도의 논의 없이 이 규칙을 지키게 할 수 있게 되는거죠. 참여하고 있는 사람들도 '내 맘에는 안들지 몰라도' 적어도 프로젝트 자체가 잘 운영이되도록 코드가 작성되는것은 반박할 수 없을거에요. 그런 관점에서 접근을 한다면 나쁘지 않은 주제다!라고 생각할 수 있지 않을까요? ㅎㅎ(개발에 일가견 있는 분들끼리 저런거 하나하나 주제잡고 정하는건 늘 어렵고 빡센 일이니까요)\n\n장기적인 관점에서 커뮤니케이션 비용이 가장 적은것, 새로운 사람이 아무 정보없이 봤을 때 온보딩이 가장 쉬운 방식들을 사용하려는 편인것 같아요!\n\n고생하셨고 다음주차 과제도 화이팅입니다~~",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/3"
    }
  },
  {
    "passed": true,
    "name": "이진희",
    "feedback": "안녕하세요 진희님! 클린코드 마지막 챕터 잘 진행해주셨네요 ㅎㅎ 고생하셨어요!!\n\n> 모달 관리를 어떻게 하시나요?\n\njotai로 모달을 다 관리하는건 어렵다고 생각해요 ㅎㅎ 특히 여러 개의 모달이 있을 때, jotai에서 이를 관리하기가 무척 까다롭답니다.\n그래서 저는 context를 사용하는 방법이 좋지 않나!? 라고 생각하는데요,\n일단 context의 경우 react에서 제공하는 api이기 때문에 라이브러리로 만들어서 관리하기도 수월해요!\n\n그리고 modal이 jotai를 직접적으로 의존하기보단, 한 단계의 추상화된 레이어 (useModal 같은)를 만들고 이를 의존하도록 작성해주시면 좋을 것 같아요! 그렇게 해야 jotai를 사용하다가 다른 라이브러리로 바꾸거나 context로 바꿀 때 유연해진답니다 ㅎㅎ\n\n\"가장 효율적이고 확장 가능한 방법\"이라는건 사실... 딱히 정해져있다고 생각하지 않아요. 어떤 프로젝트에서는 진희님께서 만들어주신 모달이 최적의 코드일 것이고, 어떤 프로젝트에서는 다양한 요구사항으로 인해 다르게 쓰일 수 있으니까요!\n\n\"모달간의 복잡한 상호작용\"의 경우, 모달끼리는 상호작용을 하지 않도록 하는게 좋다고 생각해요 ㅎㅎ\n그냥 모달은 \"데이터의 UI 표현\"일 뿐이고, 데이터를 다뤄야 하는거죠.\n\n말씀해주신 상황도 Context와 Modal이 1:1로 매칭되는 상황이면 대체로 해결되지 않을까!? 라는 생각이 드네요.\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/25"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "안녕하세요 태영님! 6주차 과제 잘 진행해주셨네요! 고생하셨습니다 ㅎㅎ\n\n> 만약 이 과제 기준으로 규모가 확장되어 음.. 뭐 게시물을 등록 할 때 관리자 승인이 있어야 한다 는 요구사항이 생기면 이 부분을 Features로 구성하면 되지 않을까요? 이 부분에 대해 코치님께서는 어떤 생각이 드시나요?\n\n말씀해주신 것 처럼 feature로 구성해주면 될 것 같아요! 지금은 모든 계층에 대해 테스트 하기에는 페이지가 하나라서 조금 아쉽긴 하네요 ㅎㅎ ㅠㅠ\n\n다만 \"게시물을 등록 할 때 관리자 승인\" 이라는게 여러가지 비즈니스가 섞여있다보니 features로 만들어보고 안 되면 widgets 로 옮기면 좋지 않을까?! 라는 생각이 들어요 ㅎㅎ\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/23"
    }
  },
  {
    "passed": true,
    "name": "임규원",
    "feedback": "안녕하세요 규원님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n문의사항은 따로 없어서 피드백은 바로 마무리하겠습니다!\n\n궁금한 내용 있으면 문의 채널에 남겨주세요~ 고생하셨습니다!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/47"
    }
  },
  {
    "passed": true,
    "name": "임두현",
    "feedback": "안녕하세요 두현님! 클린코드 마지막 과제 잘 진행해주셨네요 ㅎㅎ\n\n> FSD의 경우 리팩토링을 상향식으로 하는 것이 좋을 지 하향식으로 하는 것이 좋을까요 다른 세그먼트들이 하나의 레이어에 묶여있습니다. 개인적으로 상태/모델은 작은것부터 분리해서 조립하여 올라가는 방식이 편하고 UI는 큰 덩어리부터 작은 덩어리로 쪼개나가는 것이 편합니다. 이번 과제를 통해 같은 레이어 단위 속에서 공존하여 이 때 어던식으로 판단하시는지 여쭤보고자 합니다.\n\n말씀하시는 상향식/하향식이 아래에서부터 조립하는지, 위에서부터 분리하는지로 따져보자면...\n저는 위에서부터 분해해서 만들어가는걸 선호하는 편이랍니다!\n\n특히 지금처럼 리팩토링을 하는 과정에서는 더더욱 그렇게 하는 것 같아요 ㅎㅎ\n처음부터 프로젝트를 구성하고 만들어간다면 작은 단위의 코드부터 구성할 수 있겠지만 지금은 개선을 하는 작업이니까요!\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/30"
    }
  },
  {
    "passed": false,
    "name": "장루빈",
    "feedback": "루빈님 고생하셨습니다.\n체크리스트를 모두 채워주시려고 노력했지만, 적절하게 나눠주셨다고 보기에는 어려운것 같아요. \nshared에 대부분의 로직들이 분포되어있고, 전체적인 구조를 초반부터 다시 잡아야 할 것 같네요 ㅠㅠ 이 부분에 대해서는 조금 더 고민을 해보고 다른 분들 코드를 참고해보셔도 좋을 것 같아요! 아쉽지만 체크리스트를 모두 완성했다고 보지 못할것 같아 통과하지 않은 것으로 처리하겠습니다.\n\n> 실제 실무에서 FSD 구조를 적용할 때, 팀원들과의 합의나 기준을 어떻게 맞추는 게 좋을지 궁금합니다.\n> entities/feature/widget 레이어의 경계가 애매할 때, 어떤 기준으로 결정하면 좋을까요?\n\n여기서 중요한건 분명하게 FSD는 각각 합의가 필요한 부분이 명확하게 있지만, 기초적인 구획은 명확하게 있다는거 같아요. FE관점에서 특히 리액트 관점에서 명확하게 구획을 잡을 수 있도록 가이드가 있고 어느정도 복잡한, 그리고 외부 라이브러리들을 사용하는 경우에 협의가 필요한 부분들이거든요. (폴더 구조라거나) FSD 가이드 문서에 일단 명확한 설명이 있으니 이 부분을 따르도록 노력하고 작은 단위부터 구획을 잡아가는게 저는 이 구조에서는 편한것 같더라구요. entity는 무엇이 될 수 있는가! 부터 다시 고민을 해보면 도움이 많이 될 것 같습니다. \n\n> tanstack-query와 jotai/zustand를 같이 쓸 때, 상태의 소유권(서버/클라)을 더 명확하게 구분하는 팁이 있을까요?\n\n단순하게 '서버와 동기화할 필요가 있는가'를 기준으로 보면 될 것 같아요 ㅎㅎ 그러다 보면 네트워크 요청같은것들은 자연스럽게 서버 상태가 되고 서버는 제외하고 컴포넌트끼리 넘나드는 상태는 전역 상태에 두는거죠. \n그럼 서버상태를 전역상태에 넣어두고 쓰면 되는거 아닌가 라고 생각할 수는 있지만, 이렇게 될 경우 동기화를 시켜야 하는 작업이 중복해서 드니 그런것들을 쉽게 해주는 기능들이 포함된게 탠스택 쿼리인것 같아요!\n그런 관점에서 일단은 접근하면 좋지 않을까 싶습니다 ㅎㅎ\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/31"
    }
  },
  {
    "passed": false,
    "name": "장희진",
    "feedback": "안녕하세요 희진님!\n6주차 과제 잘 진행해주셨네요 ㅎㅎ 다만 심화과제까진 진행을 다 못해주셨군요 ㅠㅠ\n\n추후에 과제 회고도 작성해보시면 좋겠어요!\n리뷰받고 싶은 부분을 남겨주지 않아서 일단 피드백은 바로 마무리하겠습니다!\n\n궁금한 부분 생기면 문의채널에 남겨주세요!\n\n고생하셨습니다 ㅎㅎ",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/21"
    }
  },
  {
    "passed": true,
    "name": "정건휘",
    "feedback": "건휘님! 이번 주차는 과제 달성률이 많이 떨어지는데 역시나 건휘님은 잘 해내셨군요 :) \n멋집니다!\n\n넵 말씀하신대로 저도 리액트 쿼리의 효능을 참 많이 좋아하는데요.\n특히나 리액트 쿼리의 캐시로 인해 데이터를 교환하거나 패칭을 한 번만 할 목적으로 상태관리도구를 사용하는 경우가 많이 줄었어요.\n오히려 단순히 공유를 목적으로하는 상태관리도구의 사용성이 줄어드니 비즈니스 로직을 담는 역할에 더 충실해지는 것 같기도 하고요 :)\n그리고 공용 요청 client라고 부르신 API 패칭 레이어는 제 생각에는 모든 프로젝트에서 반드시 필요한 레이어가 아닐까 생각해요.\nAPI 호출은 일단 한 번 추상화하고 봐야합니다. 그로인해서 여러가지 장점을 취할 수 있어욥.\n\n주말 잘 보내세요!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/46"
    }
  },
  {
    "passed": true,
    "name": "정도은",
    "feedback": "안녕하세요 도은님! 클린코드 마지막 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 1. 여전히 FSD가 어려운거 같아요. 특히 단방향 의존성 부분이요... 의존성을 지키기 위해 상위에서 쓰는 로직들을 하위로 내리기도 했는데 이 방식이 맞을까 하는 의문이 있습니다. FSD가 정답은 없다고 하지만 어느정도 룰을 지키는게 중요하다고 보는데 이렇게 의존성을 지키기 위해 계층을 업다운 하는게 맞는지..궁금합니다.\n\n흠.. 말씀해주신 부분을 알려주시면 판단하기가 쉬울 것 같은데요.. \"의존성을 지키기 위해 상위에서 쓰는 로직을 하위로 내리는 경우\"를 현재 코드에서 찾기가 어렵네요 ㅎㅎ ㅠㅠ\n\n상위 계층에서 정의된 \"이름\"을 그대로 하위 계층으로 내리기보단 인터페이스를 통해 소통하는 방법이 있답니다!\n인터페이스를 통해 소통한다거나!?\n\n> 2. 이번에 더미 API 때문에 검색 쿼리를 전역상태로 관리해야했나? 하는 고민이 듭니다. 원래는 지역이 맞다고 보는데 쿼리키에서 params를 넣어줘야 해당 캐시를 가져올 수 있어 prop로 전부 내려주는 작업을 했습니다. 그리고 제가 만든 검색쿼리 hook이 재사용을 고려하고 만든거라 리스트 검색하나만을 위해 또 동일한 기능의 훅을 만드는게 맞는건지도 좀 고민이 됐습니다.. 좋은 해결책이 있었을까요?\n\n검색쿼리가.. 주소의 쿼리를 말씀하시는게 맞겠죠!?\n일단 사용자가 입력하는 값 자체는 로컬에서 관리하고, 입력이 완료되면 주소에 반영하는 한 다음에 주소의 값을 다른 곳에서도 가져다 사용하는 방식을 생각해볼 수 있을 것 같아요!\n\n\n> 3. 컴포넌트를 쪼갤지 말지 판단하는 코치님만의 기준이 있으신가요?\n\n처음부터 쪼개는 편은 아닌 것 같아요 ㅎㅎ\n부모에서 정의된 상태가 특정 영역에서만 쓰인다면, 해당 상태와 컴포넌트를 같이 분리한다거나!? (렌더링 관점)\n혹은 재사용보단 목적에 따라 분리하는 편인 것 같습니다. \n\n1. 재활용할 수 있다면 분리하고\n2. 렌더링 여파에 따라 분리하고\n3. 목적과 역할에 따라 분리하고\n\n보통 이렇게 세 가지로 구분되는 것 같습니다..!\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/5"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "정민기",
    "feedback": "안녕하세요 민기님! 클린코드 마지막 챕터 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 제가 궁금했던 것은 PostItem을 엔티티로 하게된다면, 단방향 흐름에 따라 엔티티안에 피쳐가 못온다는 부분을 알고있어서 PostItem을 위젯으로 했는데요. 제가 생각한 부분이 틀릴까요? 아니면 PostItem 전체를 엔티티로 두고 EditIcon, TrashIcon, DetailIcon도 그냥 엔티티로 두어야했을까요?\n\nwidget으로 두거나 혹은 feature로 둬도 무방하다고 생각해요 ㅎㅎ\n또 다른 방법은, PostItem이 아니라 TableItem 이라는 UI로 하나 추상화 한 다음에 여기에 entities나 features로 만들어진 데이터를 매핑하는거죠.\n\nIcon은 widget과 동일한 레이어에 위치시키거나 혹은 shared/icon 같은 폴더를 만들어서 유지시켜도 좋았을 것 같네요!\n\n여튼 정리하자면, 디자인시스템을 생각해보시면 좋은데요, 디자인 시스템은 다양한 UI의 단위를 만들어서 제공하고 있어요.\n현재 과제에서도 Table과 TableItem 혹은 Tr 이라는 UI 요소를 추출할 수 있지 않을까!? 라는 생각이 드네요!\n\n물론 이를 랩핑해서 사용하는 영역은 features 혹은 widgets가 맞다고 적절하다고 생각합니다 ㅎㅎ\n\n---\n\n위에 남긴건 저의 생각일뿐이고, 결국 제일 중요한건 민기님의 생각이라고 생각해요. 누군가가 \"이렇게 코드를 작성한 이유가 있나요?\" 라고 물어봤을 때 다른 사람의 생각을 기반으로 민기님의 생각을 전개할라고 하면 결국 말문이 막히게 된답니다.\n\n민기님이 왜 이렇게 생각하게 되었는지에 대해 촘촘하게 고민해보시면 좋겠어요!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/11"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "정유열",
    "feedback": "수고했습니다. 지난 3주간 클린코드를 비롯한 소프트웨어 공학적으로 결합도 낮추기 응집도 높이기를 위한 이론과 프론트엔드에서의 적용등을 통해서 좋은 코드와 구조에 대한 다각도의 시야가 생겼기를 기대합니다.\n\n회고에서 FSD가 왜 이러한 선택들을 했는지 그리고 그걸 실전에 적용하는 과정에서 어떤식으로 유열이 인사이트를 얻어가는지를 너무 잘 이해할 수 있도록 회고를 잘 써줬다고 생각해요.\n\n\"점진적 승급 전략이 유효했다.\"\n\"...신경 쓰지 않아도 될 코드는 신경 쓰지 않을 곳에 구획을 만들어두고 시선을 두지 않는 것도 좋다\"는 말이 인상깊었는데, 엔티티 구조를 사용하면서 비즈니스 로직은 따로 정리해두고, 필요할 때만 꺼내 쓰는 식으로 적용해보면 좋겠다는 생각이 들었습니다.\"\n\n기능이라고 하는 애매한 경계에 대해서 고민해보고 이후 확장의 개념이 feature slice design하게 만들어지게 되는 이유에 대해\u001e서도 잘 생각해보게 된 것 같아서 좋습니다.\n\nQ1) @features/add-post/ui/add-post-form-dialog.tsx와 같은 컴포넌트는 피쳐로 분리할때 다이얼로그에서 액션 로직과 연결되어있는 부분까지만 분리할지, dialog를 통째로 분리할지 고민하다가 dialog를 통째로 분리했습니다. '모달이 표시된다'라는 현상 자체도 기능으로 보기로 결정했기 때문입니다. 하지만 이 dialog 안에도 add-post라는 기능이 있는데 이런 기능의 중첩 상황같은 경우 세부 분리를 더 진행하는게 좋을까요?\n\n=> 분리를 더하고 말고의 기준은 실제로 이들의 결합이 실제 업무나 기능적으로 추상화되어 생각하냐 입니다. post는 액션이 있고 user는 액션이 없지만 대개 다이얼로그를 기준으로 생각합니다. 왜냐하면 그게 제일 확실한 단위라고 생각을 하니까요. 그리고 이 경우에는 CRUD도 하나로 묶어서 생각하게 될거에요. 그러니 세부 분리를 더 진행을 안해도 괜찮을 수 있습니다.\n\n=> 세부분리를 더 해서 폴더 구조를 만든다면? 그건 그거대로의 장점이 있습니다. 여기에는 확실히 삭제, 편집, 생성 기능이 있구나 하는 것을 시각적으로 알게 되죠. 나중에 편집 기능을 수정해야하는 경우라면 해당 기능으로 찾아가거나 분리를 할 수도 있습니다.\n\n=> 요는 더 하는게 좋다 나쁘다의 방향보다는 실제로 그렇게 했을때 도움이 되느냐? 입니다. 도움이 되지 않을 작업을 구태여 복잡하게 일을 벌일 필요는 없겠죠. \n\n\nQ2) @entities/post/api/queries.ts 파일처럼 부담스럽지 않은 코드라인 수준이라면 여러개의 useQuery를 굳이 파일분리를 진행시켜주지 않아도 되겠다 싶어 이번 프로젝트에서는 모아둔 로직들이 많은 것 같습니다. 합리적인 선택이었을까요? 아니면 제가 인지못한 불편함이 존재할까요?\n\n=> 코드를 폴더 구조나 파일로 드러내주면 모르는 사람이 이 프로젝트를 처음 봤을때 이해도가 높아지게 됩니다. 그런데 3줄 4줄 밖에 안되는 파일들을 많이 만드는게 안 좋을 수도 있죠. 이건 직접 해보고 선택하시면 좋겠네요. 그럴만한 가치가 있는지를 직접 느껴보시면 좋겠습니다. 어떤 선택이든 일리가 있다고 생각해요.\n\n\nQ3) 항상 질문을 할 때 포괄적인 범위의 질문은 안된다고 전달받았으나, 이번 과제는 괜찮으시다면 파일구조를 잘 구성했는지를 봐주시면 감사하겠습니다. 제가 파일 구조를 잘 짰는지 정말로 궁급합니다.\n\n=> 네 잘 이해하고 보편적인 관점에서 잘 만들어주었다고 생각합니다. 잘했습니다. 폴더명은 케밥케이스로 작성하기는 하나 보통 파일명과 함수명 혹은 컴포넌트명과 비슷한 경우에는 가급적 같은 포맷으로 작성하곤 합니다. 가급적 코드에서 다뤄야할 종류가 많아지는 것은 좋지 않거든요. 폴더구조와 코드면에서는 과제에서 요구하는 대로 잘 해주었다 생각합니다. 수고했습니다.\n\nBP 선정이유: 회고의 작성이 생각의 흐름을 잘 따라가도록 기술이 되어 다른 사람에게도 크게 도움이 될 수 있다고 생각합니다.\n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/28"
    }
  },
  {
    "passed": false,
    "name": "조영민",
    "feedback": "안녕하세요 영민님!\n6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다.\n\nfsd와 tanstack-query 를 적용해주긴 했는데, 완전하진 않아서 일단 기본과제만 합격해놓도록 하겠습니다.\n\n별도의 질문은 없어서 피드백은 바로 마무리할게요!!\n궁금한점 있으면 문의채널에 남겨주세요! ",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/10"
    }
  },
  {
    "passed": true,
    "name": "주산들",
    "feedback": "수고했습니다. 지난 3주간 클린코드를 비롯한 소프트웨어 공학적으로 결합도 낮추기 응집도 높이기를 위한 이론과 프론트엔드에서의 적용등을 통해서 좋은 코드와 구조에 대한 다각도의 시야가 생겼기를 기대합니다.\n\n\"이번에 이렇게 직접 해보니까 확실히 해보기 전에 비해 FSD 감각이 생겼다고 생각한닷.\"\n\"힘든 밸런스게임이었다...ㅜㅜ\"\n\"뭔가 나만의 AI 쓰는 타이밍을 알게된 것 같은 느낌인데 안쓰는 것 보다는 이렇게라도 활용하는 게 좋지 않을까..\"\n\"그런 생각이 들어도 그냥 할 수 있는 데 까지(내가 생각이 닿은 데 까지) 일단 만들어 보고 리뷰를 많이 받거나 다른 사람들의 코드를 많이 보는 편이 더 도움이 될 것 같다.\"\n\n좋은 성찰 포인트가 너무 많네요! 과제의 취지에 맞게 잘 따라와줘서 고마워요. AI가 확실히 막연한 생각의 느낌을 언어로 만들어주도록 도와줄때 참 빛을 발하는 녀석이죠. LLM을 글쓰기 능력이 생각을 하게 만드는데 참 많이 도움을 준다 생각해요.\n\n정답이라는 것을 배워서 적용하는 것보다 정답이 없는 선택에 대해서 고민을 해본다는 것이 인간에게 있어 능력을 참 많이 키우게 해주는 방법이라고 생각해요. 그렇지만 너무 많은 생각과 고민이 행동을 방해해서는 안되겠죠. 고민은 곧 행동을 위함이니까요! 이번 경험이 강직하고 빠른 선택을 할 수 있게 해주는 계기가 되길 바래요.\n\n결정에 대해서 도움을 줄 수 있는 팁이 있다면 A,B중 7:3으로 A가 좋다면? 당연히 A를 고를거에요. 6:4로 A가 좋다면? A를 고르겠죠. 지금 고민이 된다는건 아마 5.5:4.5 정도로 둘 사이가 별 차이가 없어서 일지도 몰라요. 그렇다면 이때 필요한 건 빠른 결정인거죠. 사실 둘의 차이가 별로 없었을 수도 있으니까요. 만약 그 결정이 되돌리기 쉬운 결정이라면 더더욱 고민하지 말고 해보는게 나아요. 신중해야 하는건 이 결정이 돌이킬수 없을때만이에요!\n\nQ) * 실무를 하는 팀에서 FSD를 사용할 때, 뭔가 그 팀 만의 FSD 룰이 생기나요? 지금 과제를 하면서 팀원들과 이야기를 나눴을 때 다 각자가 생각하는 기준이 달랐거든요. 실무에서도 각자가 생각하는 기준이 다를 것 같은데 이런건 어떻게 통합되고 합의되나요?\n\n=> 네 자신만의 FSD가 생깁니다. FSD를 완전히 적용하는 경우도 있지만 FSD가 모든 프로젝트에 다 맞는 만능일 수 없거든요. 누구나 같은 해석을 하는것이 아닌만큼 여러가지 베리에이션이 나오고 해석을 통일하고 컨벤션을 만들게 되요. 그러면서 뭔가 기준이나 컨벤션이 만들어져 갑니다.\n\n=> 말그대로 해석이니 팀에서 정한 컨벤션은 따르는게 좋습니다. 그렇다고 의견을 말 안할 이유는 없겠죠. 내 의견이 받아들여질거라는 기대없이 관철시키려 하지 말되 솔직하고 친절하게 나의 해석을 제안하면 됩니다! \n\n수고많았습니다.",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/26"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "최용훈",
    "feedback": "용훈님 수고많으셨습니다!\n\nQ. 코드를 분리하다보니 shared에 지나치게 치중된 것 같은데, 분류가 맞는지 모르겠습니다.\n\nA. shred의 내용을 보면 정말 공통적인 것들만 잘 모와뒀다고 생각합니다. 베이스 컴포넌트도 쉐어드에 두면 좋은 레이어 인 것 같고요.\n저는 괜찮아보입니다.\n\nQ.feature와 entity의 구분에 대해 모호합니다.\n\nA. 레이어간의 구분은 사실 저도 FSD에서 모호한 부분중 하나라고 생각해요. 세그먼트 형태로 일관성있게 추상화해서 기능을 분리하는 것은 좋은 아이디어라고 생각합니다.\n그냥 FSD의 레이어의 구분은 종속관계 즉 재사용 범위 중요하다고 생각해요 각각의 역할이 있다기보다는. 어디까지 쓰이느냐이죠\nfeature 레이어까지만 N번 사용된다면 entity인것이고 entity 레밸까지 N번 사용된다면 shared입니다.\n의존구조는  아시다시피 shared -> entites -> feature ->widget -> pages -> process -> app 이런거죠.\n레이어의 상하관계를 유지하고 디펜던시는 한 방향으로 흐른다는 컨셉만 유지하고 각 레이어의 이름과 종류는 사실 하기 나름이라고 생각합니다.\nFSD가 의도한 것을 제대로 100% 파악하는 것이 중요하다기보다는 FSD가 고민했던 것이 무엇이고 그것을 어떻게 해결했고 그래서 나는 어떻게 장점만 취할지가 더 중요할 것 같습니다.\n\nQ. 저는 개인적으로 feature와 entity를 하나의 layer로 바라보고 통합하는 건 어떨까 생각합니다.\n\nA. 위 질문에서 말씀드렸듯 레이어 종류는 저는 크게 중요하지 않다고 생각합니다. 하나의 레이어로 묶어서 service라는 레이어를 만들어도될 것 같아요.\n\n수고하셨습니다!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/1"
    }
  },
  {
    "passed": true,
    "name": "최재환",
    "feedback": "안녕하세요 재환님! 클린코드 마지막 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 현재 comment-manage가 댓글의 모든 CRUD를 담당하고 있는데, 이걸 더 세분화해야 할지 고민입니다.\n\n꼭 분리할필요는 없을 것 같아요! 분리해야 한다면 아마 \"렌더링 최적화\" 때문이지 않을까 싶네요 ㅎㅎ\n그래서 분리가 필요할 떄 분리하면 된다고 생각해요! 일단은 현상유지 해도 좋아보입니다\n\n> 각 계층별로 어떤 테스트 전략을 적용하는 게 효과적일지 궁금합니다. 핑계이긴 하지만 시간 부족으로 테스트 코드까지는 작성하지 못했습니다만. FSD라는 패턴 안에서 어떻게 전략을 짜면 좋을까 고민하다 이런 방향을 생각해봤는데, 다른 좋은 접근법이 있는지 궁금합니다.\n\n말씀해주신 방식대로 진행해도 좋아보여요! 저는 개인적으로 컴포넌트에 대한 테스트는 선호하지 않아서, 아마 features 까지만 테스트할 것 같긴해요 ㅎㅎ\n\nwidgets에 대한 테스트는 약간 애매하고, 차라리 pages에 대해 통합테스트를 진행하는게 더 가성비가 있지 않을까!? 라는 생각이 들어요!\n\n---\n\n고생하셨습니다!!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/49"
    }
  },
  {
    "passed": true,
    "name": "한아름",
    "feedback": "수고했습니다. 지난 3주간 클린코드를 비롯한 소프트웨어 공학적으로 결합도 낮추기 응집도 높이기를 위한 이론과 프론트엔드에서의 적용등을 통해서 좋은 코드와 구조에 대한 다각도의 시야가 생겼기를 기대합니다.\n\n\"게시글 필터의 경우 지금은 src/widgets/post-filter/ui 내에 로직이 한번에 들어가 있는데 이를 검색/태그/정렬 단위로 잘게 나누는게 더 나은 방식인지 아직도 고민이 끝나지 않는다.. 잘게 쪼개면 기능들이 더 한눈에 보이겠지만 반대로 너무 컴포넌트가 세분화되어 관리가 번거로워질 수도 있다는 생각이 든다.\"\n\n\nQ) 파일 위치 및 구조를 제일 고민했던 부분은 dialog (대화상자 모달) 관련 로직 및 ui인데요. 코치님이라면 해당 부분을 어떻게, 어느 위치에 두고 리팩토링을 하실 지 궁금합니다.\n\n=> 다이얼로그 show/hide를 하는 코드를 widgets에다가 하나 만들고 나머지 Dialog등을 표기하는 방식으로 했군요. 좋습니다. 나쁘지 않은 방식이라고 생각해요.\n\n=> 저는 PostDialog를 만들어서 하나로 만들어서 <App/> 컴포넌트에 모아서 두거나 하위 폴더를 만들어서 AppDialogs를 만들어 관리를 했을 것 같아요. 하나의 위젯단위라기 보다는 페이지 일부에 속하는 섹션인것 같아서 Dialogs 모음을 만들거라면 pages/ui나 app/ui 에 둘것 같아요.\n\nQ) 만약 저처럼 zustand로 구현한다면 어떤 구조가 더 나을 지, 아님 아예 zustand로 처리하지 않는다면 어떤 방식으로 구현하실 지 알고 싶습니다 !!\n\n=> zustand를 쓰지 않을거라면 jotai를 쓸거에요. reocil와 redux가 표준에서 내려온 지금 전역상태관리 라이브러리로써는 저 2개가 제일 많이 쓰인다고 생각합니다. 확실히 zustnad의 채택률이 제일 좋으니 그걸 쓰시면 좋겠네요\n\n수고하셨습니다.",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/37"
    }
  },
  {
    "passed": true,
    "name": "허정석",
    "feedback": "가만히 있었는데 믿어준 사람이 된거같아서 너무 좋네여.\n정석님 고생 많으셨습니다. \n더 챙겨야 할 부분은 많이 있지만 그럼에도 전반적인 관점에서 필요한 고민들은 많이 해주신 것 같아요!\n이전 과제도 그랬겠지만, 지금 과제에서도 새로운 얘기가 정말 많으셨던것 같은데 학습의 맥락에서도 하나하나 짚어서 과제를 해내주시는게 정말 멋있는것 같습니다. 아키텍처의 관점도 사실은 리액트에 국한되는 내용이 아니라 개발 전체를 관통하는 이야기의 일환이긴 하거든요. 레이어를 나누고 각 코드를 배치하고 하는 약속들을 통해 응집성을 같고 순환참조를 맺지 않게 하면서 결합도를 낮추는 방향들을 많이 보신것 같아 좋네요!\n\n> 추후 FSD를 적용한다면 위처럼 features 를 기능별 세분 방식으로로 진행 해보고싶습니다. 그래서 위 구조가 실무에서도 활용을 자주하는 구조인지? 아니면 다른 구조가 좀 더 실무에 적합한지에 대한 의견이 듣고싶고, 실질적인 예시가 있다면 간략한 구조도를 부탁드리겠습니다.\n\n넵 좋습니다. 검색의 경우에는 종류에 따라 각 도메인에 묶어서 관리할 수도 있을것 같네요. https://feature-sliced.github.io/documentation/examples 를 보면 알겠지만, 수많은 FSD가 있고 규칙을 지키지만 구조는 전부 다른것을 알 수 있을거에요. 가장 핵심이 되는 규칙을 따르는게 중요한 것이기 때문에 통일된 규칙으로 약속을 잘 만들고 지키는게 중요하지 않을까 싶습니다.\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/16"
    }
  },
  {
    "passed": true,
    "name": "현지수",
    "feedback": "수고했습니다. 지난 3주간 클린코드를 비롯한 소프트웨어 공학적으로 결합도 낮추기 응집도 높이기를 위한 이론과 프론트엔드에서의 적용등을 통해서 좋은 코드와 구조에 대한 다각도의 시야가 생겼기를 기대합니다.\n\n\"현재 댓글과 게시물의 데이터 조합 로직을 features 레이어에 배치했지만, 이 결정이 완전히 명확한지 확신이 서지 않습니다. 예를 들어 fetchPostsWithAuthors는 두 개의 entities API를 조합하는 역할인데, 이것이 features에 있어야 하는지 아니면 별도의 레이어나 shared 영역에 있어야 하는지 고민됩니다. 특히 다른 기능에서도 동일한 조합이 필요할 때 중복 코드가 발생할 가능성이 있습니다.\"\n\n사실 굉장히 헷갈리는 문제죠. 특히나 layers의 단위가 의존성을 바탕으로 수직적인 계층을 다루는 만큼 복수개의 entities를 다루게 되면 features인가? 라고 생각하게 되고 실제로 그런 경우가 많으니까요.\n\n그래서 해당 코드를 features로 넣게 되면 다른 features와 성격이 유사한가 더 이상 이 코드는 entities가 아니게 되나? 이런 생각을 한 번해보세요. entities끼리도 계층과 의존이 있고 features끼리도 계층과 의존이 있을 수 있는데 의존과 계층이 아니라 둘이 분명 갈라지게 하는  캐릭터가 존재하고 그게 달라지는 경계를 기준으로 삼아보기를 바래요.\n\n과제를 통해서 전달하고 싶은 내용들이 잘 전달이 된것 같네요. 이 코드를 어디에 둘까를 고민하는 것 자체에 좋은 코드를 만드는 생각의 시작이기에 좋은 계기가 되어주었기를 바랍니다.\n\nQ) FSD 아키텍처 레이어 분리 기준\n데이터 조합 로직 위치: fetchPostsWithAuthors 같은 복합 API를 features에 두었는데, 다른 기능에서도 같은 조합이 필요할 때 중복을 어떻게 해결해야 할까요? entities vs features 판단 기준이 궁금합니다.\n\nfeatures 내 shared 폴더: features/post-management/shared/ui/PostFormDialog.tsx에 생성/수정 공통 폼을 배치했습니다. 이렇게 특정 도메인 내에서만 공유되는 컴포넌트를 위해 features 안에 shared 폴더를 만드는 것이 FSD 표준에 부합하는지, 아니면 다른 구조가 더 적절한지 궁금합니다.\n\n=> 앞서 설명했지만 entities vs features는 조합의 문제가 아니라 실제로 분리를 해보면서 작업을 하면 명확히 다른 그룹이 형성이 됩니다. 엔티티를 사용하는게 기준이 아니라 성격이 달라지는 것들을 기준으로 생각해보면 도움이 될거에요.\n\nQ) React Query 캐시 키\n쿼리 키 팩토리 패턴: 현재 쿼리 키가 하드코딩되어 있어서 오타나 불일치 위험이 있습니다. queryKeys.posts.withAuthors() 같은 쿼리 키 팩토리 패턴을 도입하는 것이 프로젝트 규모에 비해 과도한 엔지니어링인지, 아니면 초기부터 적용하는 것이 좋은지 의견을 듣고 싶습니다.\n\n=> 이건 제가 이렇다라고 답을 드린들 큰 의미가 없는것 같아요. 제가 설명하는 언어가 그걸 다 세세하게 말할 수 있을 만큼 설명하기가 어렵다고 생각해요. 그런 생각이 들 때에는 그냥 해보는게 좋습니다. 그래서 쿼리 키 팩토리 패턴이 정말로 도움이 되는지 그렇지 않은지를 느껴보고 나면 답을 찾을 수 있을 거에요!\n\n=> 개인적은 선호는 쿼리 키 팩토리를 굳이 만들려고 하지는 않는 편입니다. 대개 디버깅을 api를 기준으로 찾게 되는데 쿼리 키 팩토리가 api를 쉽게 찾을 수 있게 해주지는 않더라구요. 그렇지만 이 개념이 등장하는데에는 이유가 있겠죠? 찬성파는 찬성하니까 만들어지는 것이니 꼭 본인이 다 경험해서 판단하기를 바래요 :)\n\nQ) Jotai atom 분리 기준\natom 세분화: 현재 게시물 필터링 상태를 7개 atom으로 나누었습니다. 이렇게 세분화하면 컴포넌트가 필요한 상태만 구독해서 불필요한 리렌더링을 방지할 수 있지만, atom 개수가 많아져서 관리가 복잡합니다. 실무에서는 리렌더링 최적화와 코드 복잡성 사이에서 어떤 기준으로 판단하나요?\n\n성능 vs 복잡성: 리렌더링 최적화를 위해 atom을 세분화했지만 관리 복잡도가 증가했습니다. 실무에서는 어떤 기준으로 균형을 잡는지 궁금해요!\n\n=> 문제가 없다면 간결한 쪽이 낫습니다. FE는 성능보다 관리가 더 중요하니까요. 방치하라는건 아니고 최대한 적은 코드도 간결하게 구현할 수 있는 방향으로 구현하되 문제가 생길때 성능의 이슈가 생길때 복잡성을 조금씩 구현하는 방향이 좋습니다. 복잡도가 높아지는게 좋은 코드는 아니니까요.\n\n수고많았습니다!! \n",
    "assignment": {
      "name": "STEP12 클린 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter2-3/pull/34"
    }
  },
  {
    "passed": true,
    "name": "강병준",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/65"
    }
  },
  {
    "passed": true,
    "name": "권지호",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/7"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/48"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/45"
    }
  },
  {
    "passed": true,
    "name": "김소희",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/67"
    }
  },
  {
    "passed": false,
    "name": "김수민",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김수현",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/20"
    }
  },
  {
    "passed": false,
    "name": "김연수",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "김유현",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/36"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/55"
    }
  },
  {
    "passed": true,
    "name": "김효진",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/29"
    }
  },
  {
    "passed": true,
    "name": "김휘린",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/35"
    }
  },
  {
    "passed": true,
    "name": "박상수",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/28"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/52"
    }
  },
  {
    "passed": false,
    "name": "박의근",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "박준형",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/4"
    }
  },
  {
    "passed": true,
    "name": "박창준",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/44"
    }
  },
  {
    "passed": true,
    "name": "신홍준",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/34"
    }
  },
  {
    "passed": true,
    "name": "신희원",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/42"
    }
  },
  {
    "passed": true,
    "name": "양성진",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/43"
    }
  },
  {
    "passed": false,
    "name": "양창훈",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/59"
    }
  },
  {
    "passed": true,
    "name": "여진석",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/3"
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/30"
    }
  },
  {
    "passed": false,
    "name": "오하늘",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/66"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/10"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "윤영서",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/24"
    }
  },
  {
    "passed": true,
    "name": "이가은",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/53"
    }
  },
  {
    "passed": true,
    "name": "이민재",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/49"
    }
  },
  {
    "passed": false,
    "name": "이유진",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/56"
    }
  },
  {
    "passed": false,
    "name": "이은지",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/64"
    }
  },
  {
    "passed": false,
    "name": "이의찬",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/62"
    }
  },
  {
    "passed": false,
    "name": "이정우",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/60"
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/32"
    }
  },
  {
    "passed": true,
    "name": "이지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/39"
    }
  },
  {
    "passed": false,
    "name": "이진희",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/25"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/21"
    }
  },
  {
    "passed": true,
    "name": "임규원",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/51"
    }
  },
  {
    "passed": true,
    "name": "임두현",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/33"
    }
  },
  {
    "passed": false,
    "name": "장루빈",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/57"
    }
  },
  {
    "passed": true,
    "name": "장희진",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/61"
    }
  },
  {
    "passed": false,
    "name": "정건휘",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/58"
    }
  },
  {
    "passed": true,
    "name": "정도은",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/22"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "정민기",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "http://github.com/hanghae-plus/front_6th_chapter3-1/pull/17"
    }
  },
  {
    "passed": true,
    "name": "정유열",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/12"
    }
  },
  {
    "passed": true,
    "name": "조영민",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/31"
    }
  },
  {
    "passed": true,
    "name": "주산들",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/5"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "최용훈",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/46"
    }
  },
  {
    "passed": true,
    "name": "최재환",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/6"
    }
  },
  {
    "passed": true,
    "name": "한아름",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/50"
    }
  },
  {
    "passed": false,
    "name": "허정석",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/26"
    }
  },
  {
    "passed": true,
    "name": "현지수",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/63"
    }
  },
  {
    "passed": true,
    "name": "강병준",
    "feedback": "고생하셨습니다!\n양이 꽤 많았는데 테스트를 작성하시면서 많이 익숙해지신것 같아서 좋네요 ㅎㅎㅎ\n작성해주신 내용이나 회고를 읽어보니 알차게 한 주를 보내셨었던 것 같네요. 결국 테스트가 공부를 할수록 명확한 기준이 생기기 전까지는 모호한 기준이지 않을까, 어떤 부분을 검증할까 라는 것들이 바로 기준이 생기시지 않을 수 있지만 결국 많이 작성해보고 운영해보는 경험들이 도움을 줄 것이라고 생각합니다.\n여유가 있으시다면 하드도 한번 도전해서 해결해보시면 좋겠어요.\n\n> 테스트 코드의 리팩토링은 언제, 어떻게 진행하는 게 좋을까요?\n\n사실 테스트 코드는 작성하는 시점에 깔끔하게 작성하는게 좋지만, (사실 그렇게 복잡한 로직은 없을 것이라는 가정이기 때문에) 작성한 직후 테스트가 통과한다면 정리를 하고 넘어가는게 좋은 것 같아요 ㅎㅎ \n만약 추가 어설션을 선언해서 쓰는 것처럼 전체적 개선이 필요하다면 말 그대로 '필요해질 때' 쓰는게 좋은 것 같습니다. 말 그대로 테스트는 검증의 기준이기 때문에 자주 변한다는 것 자체가 (리팩토링의 맥락에서는 영향이 없어야 하지만) 좋은 신호는 아닌것 같아요!\n\n> 테스트 코드 작성 능력을 향상시키기 위해 어떤 학습 방법을 추천하시나요?\n\n작성해주신것처럼 테스트의 의도를 파악하는게 가장 중요한것 같아요.\n지금은 제가 테스트를 작성해드렸지만 결국 무엇을 테스트할지, 범위를 어떻게 정해야할지 생각해야하는건 병준님이시니까요.\n어떻게 케이스를 정의해야할지 모르겠다면 가장 좋은 방법은 명세를 정리해보는겁니다. 기획서를 직접 정의하지 않았다면 정리를 하고 테스트 할만한 시나리오들을 추려보는거죠. 유저 관점에서 사용하는데 중요한 시나리오들에 맞춰 데이터를 이전 Q&A때 공유드렸던 방법론들처럼 나눠보는것도 방법일 것 같아요. \n(아니면 AI에게 켄트벡의 페르소나를 주입해 테스트 케이스를 만드는것도 큰 도움을 받는 방법일 수도..!)\n\n고생하셨고 담주도 화이팅입니다!",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/65"
    }
  },
  {
    "passed": true,
    "name": "권지호",
    "feedback": "와…… 회고 내용이 무슨 논문이네요 :) \n지호님 멋집니다.\n\nQ. 제가 작성한 단위 테스트의 신뢰도가 높다는 것을 스스로 판단하는 지표를 세운다면 어떤것을 기준으로 생각해볼 수 있을까요?\n\nA. 사실 그것을 판단할 수 있는 지표는 없다고 생각해요. 정성적인 것말고 정량적으로는 커버리지가 도움이 될 수 는 있을 것 같아요. 기본적으로 테스트를 기준(팀에서 정한 전략)에 맞게 잘 작성했다는 가정하에 얼마나 커버하고 있는지를 알 수 있으니까요. 전체적인 커버리지보다는 브랜치 커버리지로 코드의 어느부분이 테스트를 통해 실행되지 않는지를 확인할 수  있을 것 같습니다. 정성적인 지표는 아마 찾기 힘들 것 같아요.  일단 테스트는 “깨져야 할 때 잘 깨져주면” 신뢰도가 높다고 볼 수 있고 \"깨져야 하는데 안깨지면\" 신뢰도가 낮다고 볼 수 있을 것 같아요. \"안깨져야 하는데 깨져도\" 마찮가지겠죵.\n\nQ. 신뢰도 있는 단위 테스트를 작성하기 위해서는 어떤것을 고려하면서 작성하면 좋을까요?\n\n신뢰도를 높이는 단 한가지는 테스트도 모듈로 생각하고 테스트 대상 모듈과 함께 계속 유지보수하고 중복코드를 제거하고 필요 없어진 코드는 없애는 작업을 하는 것 밖에는 없는 것 같습니다.\n\nQ. QnA 시간에 유의미한 단위테스트와 그렇지 못한 단위테스트에 대해 설명해주셨는데, 사실 구별을 잘 못하겠습니다. 단위 테스트 작성에 익숙해진다면 구별하기 어렵지 않은 것일까요? 초심자가 어떤 것을 위주로 공부하면 빠르게 감각을 익힐 수 있을까요?\n\nA. 일단 많이 작성하는 수밖에는 없는 것 같습니다! 관련 책을 찾아서 보면 더 도움이 될 것 같아요. 제가 경험해본 바로는 한 1년 정도 작성하면 감이 생기고 어떤 것을 테스트할 때는 어떤 방법을이라는 노하우가 축적됐던 것 같습니다.",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/7"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "안녕하세요 민지님! 테스트에 대한 재미를 아예 못 느끼는 그런 상태군요 ㅎㅎ ㅠㅠ 충분히 그럴 수 있다고 생각해요!\n\n> 풀스택을 하고 있다보니 오히려 자바 쪽은 커버리지때문에 테스트 코드는 작게라도 짜봤는데 리액트는 테스트 코드를 짜본 적이 없어서 그런 지, 아니면 배경 지식이 약해서 그런건지 테스트 코드에 대한 흥미도가 너무 없습니다. 어떻게 하면 흥미도를 끌어올릴 수 있을까요 전에 했던 주차에 비해 의욕이 떨어진달까요; 너무 개인적인 기호같아서 질문을 할까 망설였지만, 같이 고민해주시고 답을 주시지 않을까 싶어서 한 번 남겨 봅니다 ㅎㅎ..\n\n지금처럼 테스트를 작성하는게 아마 민지님께 \"유의미한 효과\"가 없다고 느껴서 그럴 수 있다고 생각해요!\n제가 추천드리는 방법은... 1주차 과제에서 진행했던 민지님이 직접 작성한 코드에 대해 테스트를 작성해보면 어떨까!? 라는 생각입니다 ㅎㅎ\n내가 작성한 코드에 대해서는 어떤 input을 넣었을 때 어떤 output이 나오는지 알 수 있고 예측에 대한 범위가 있어서 조금 더 수월하고 재밌게 만들 수 있을 것 같아요!\n\n혹은 아싸리 e2e 테스트를 해본다거나...?\n아마 다음주차에서 e2e 테스트에 대해 접하게 될텐데 이 때는 재미를 느낄 수도 있지 않을까!? 라고 생각합니다 ㅋㅋ\n\n쉽지 않았을텐데 과제 잘 진행해주셔서 감사해요!! ",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/48"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "안녕하세요 상수님! 7주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 실무에서 단위, 통합 테스트까지 테스트 코드 짜는 경우가 많을까요? 그냥 제 생각에는 테스트 코드를 짠다고 하면 e2e 테스트가 시간 대비 가장 효율적일것 같긴한데 어떻게 생각하시나요??\n\n말씀해주신 것 처럼 e2e 테스트만 있어도 대부분의 케이스는 커버 가능하다고 생각합니다! 다만 e2e의 경우 실행 시간이 무척 오래 걸리고, 테스트를 실행하는 컴퓨팅 비용도 단위 테스트보다 비싸요. 그래서 자주 실행하기가 부담스럽고, 그러다보면 대체로 마지막 단계에 검증하는 경우가 많답니다 ㅎㅎ 실패에 대한 피드백을 빠르게 받기가 어렵기 때문에 개선하기 까지의 과정이 조금 더 오래걸리죠. 대신 정확도는 높아요!\n\n반대로 빠르게 문제를 찾아낼 수 있는 단계가 단위테스트이지만, 말 그대로 단위테스트이기 때문에 다양한 비즈니스의 결합에 대해 검증하기는 어려운거죠.\n\n결론은 테스트의 목적과 효과 자체가 다르기 때문에 적절한 전략이 필요하다고 생각해요!\n\n> 테스트 코드를 짜면 확실히 유지보수 할 때 QA 하는 시간을 줄일 수 있을 것 같은데 회사에서 그런 시간을 줄 수 없다면 어떻게 설득을 해야될까요??\n\n테스트를 한방에 뽝 작성해놓고 \"만들었어요!\" 라고 해보는거죠 ㅋㅋ\n이미 만들어놨고, 효과가 있다면 이에 대해서 \"굳이?\" 라고 이야기를 꺼낼 사람은 많이 없다고 생각해요. 물론 테스트 자체도 유지보수를 해야하기 때문에 이에 대한 부담이 있을 수는 있죠!\n\n특히 테스트가 \"설득보단 용서\" 라는 키워드에 어울린다고 생각해요. 도입했을 때 안 좋을 게 딱히 없다보니..",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/45"
    }
  },
  {
    "passed": true,
    "name": "김소희",
    "feedback": "수고했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다.\n\n회고를 작성하지 않으신 것은 아쉽네요. 테스트 코드를 처음 접하는 분들이 많아서 과제를 진행하면서 어떤 어려움이 있었는지, 어떤 부분에서 성장을 느꼈는지 스스로 적어보면 빠르게 내것이 되는게 있답니다. 언제라도 적어 보길 바래요.\n\n테스트 코드 작성은 처음에는 막막하게 느껴질 수 있지만, 한번 경험해보면 생각보다 접근하기 어렵지 않다는 것을 알게 되었을거라 생각합니다. 순수 함수의 단위 테스트부터 시작해서 점진적으로 복잡한 통합 테스트까지 진행하는 과정에서 자연스럽게 테스트 코드에 대한 감을 익혔기를 바래요.\n\n테스트 코드는 우선 \"나를 대신해서 컴퓨터가 검증하도록 하는 과정\"이라는 것을 이해하는 것입니다. 내가 평소에 기능을 확인하기 위해 브라우저에서 클릭하고 입력하던 그 과정을 코드로 작성하는 것이죠. 이후에는 사용자가 이 기능을 수행할 때 기대하지 않은 동작을 할걸 예상하면서 예외처리등을 보강해가는 것이라 생각하면 조금 더 접근하기 쉬울 거에요. \n\n테스트 코드가 주는 가장 큰 가치는 심리적 안정감입니다. 코드를 수정할 때 \"다른 곳에서 에러가 나지 않을까\" 하는 불안감 없이 마음 놓고 리팩토링을 할 수 있게 되거든요.\n\n다음번에는 과제를 진행하면서 느낀 점들을 회고로 남겨주시면, 더 구체적이고 도움이 되는 피드백을 드릴 수 있을 것 같습니다. 코드를 작성하는 것도 중요하지만, 그 과정에서 무엇을 배웠고 어떤 어려움이 있었는지 돌아보는 것이 성장에 더 큰 도움이 되니까요.\n\n다음주 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/67"
    }
  },
  {
    "passed": false,
    "name": "김수민",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "김수현",
    "feedback": "수고했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. \"테스트 코드 작성 후 통과하면 짜릿하다는 기분을 느낄 수 있다고 했는데 정말 느꼈습니다..\" ㅋㅋㅋ 충분히 심리적 장벽을 허물고 많이 친해진것 같아요. ㅎ\n\n\"ai를 사용하지 않고 함수들이 어디에서 어떻게 쓰이는지 직접 확인해 가면서 테코를 작성하니 시간이 많이 걸렸지만, 재미를 느꼈던 것 같습니다.\" 좋은 접근이었습니다. 직접 코드를 따라가면서 이해하는 과정이 시간은 오래 걸리지만 더 깊은 이해를 가져다주죠. 뇌는 에너지를 효율적으로 쓰고 싶어서 의미가 있는 정보를 선별적으로 보관하려 하는데, 애써 하려고 한다는 그 의식적 노력과 고통을 증거로 삼으니까요. 고생했어요! 잘했습니다.\n\n\"실무에서는 테코를 작성하지 않아서 항상 코드를 수정, 추가하려고 할 때 다른 곳에서 에러가 나지 않을까 생각하며 조심스럽게 수정해나가는데 테코를 작성하면 마음 놓고 수정할 수 있지 있겠다\" 정말 맞는 말입니다. 테스트 코드가 주는 가장 큰 가치 중 하나가 바로 이런 심리적 안정감이에요. 귀찮음의 허들이 처음에는 더 높겠지만 불안함의 해소가 귀찮음보다 더 커지는 순간이 올테니 꼭 실무에서도 한번의 허들을 넘어가보길 바랍니다.\n\n\u0003Q) 이 테코를 진행할 때 만약 휴일이 추가될 경우 테스트 코드 에러가 날텐데 그런 경우를 대비해서 작성할 수 있는 방법이 있을까요?\n\n=> 오히려 테스트가 깨져야 정상입니다. 휴일이 추가되었다는 건 기능이 변경된 것이고, 그에 맞춰 구현체도 수정되어야 하는 거죠. 테스트 코드가 깨진다는 건 \"이 부분을 업데이트해야 한다\"는 신호를 주는 거예요. 실제로 이런 상황에서는 새로운 휴일 데이터로 fetchHolidays 함수를 업데이트하고, 해당 테스트 케이스도 새로운 기대값으로 수정하면 됩니다.\n\n=> 테스트는 변경사항을 감지해서 개발자에게 \"여기 수정 필요해!\"라고 알려주는 역할을 하는 거거든요. 변경사항이 생겼는데도 테스트가 통과한다면 그게 더 문제입니다. 테스트가 제 역할을 못하고 있다는 뜻이니까요.\n\n\"시간이 된다면 실무 테코도 작성해보고 싶습니다.\" 이런 마음가짐이 정말 좋네요. 일단 작은 것부터라도 하나씩 만들어보면서 그 가치를 직접 체험해보길 바라요. 수고하셨습니다.\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/20"
    }
  },
  {
    "passed": false,
    "name": "김연수",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "김유현",
    "feedback": "안녕하세요 유현님!\n과제를 진행하기에는 시간이 조금 부족했던 것 같군요 ㅠㅠ\n시간 될 때 꼭 한 번 시간되시면 좋을 것 같아요!! 화이팅입니다!!",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/36"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "수고했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. 회고를 보아하니 잘 수행해준 것 같아요.\n\n\"적어도 기본과제는 ai사용을 줄이고 감이 안 와서 포괄적인 해결 팁을 받아보거나 하늘님이 정리해주신 자료, 검색, 토론하는 자리에 가서 들어보고 해결하려고 노력했습니다\" 좋은 접근이었습니다. 직접 고민하고 찾아보는 과정이 시간은 오래 걸리지만 더 깊은 이해를 가져다주죠. 나중에는 AI를 사용하는것도 고민하고 찾아보는 과정의 도구로 활용하면서도 지금처럼 토론, 자료, 논의, 사유등을 통한 고민들도 함께 해보길 바래요.\n\n\"toBeTruthy()/toBeFalsy()와 toBe()의 차이를 몰라 전자를 사용했는데, 병준님의 회고 덕분에...\" 아주 좋습니다. 의외로 이렇게 남을 통해서 얻은 지식이 상당히 머리에 잘 남습니다. '잘 모르지만 내가 들은 얘긴데... ' 라는 식의 소문(?)과 같은 소식을 뇌는 잘 좋아하고 잘 기억하니까요. ㅎㅎ 내용적으로 toBe()가 더 엄격한 검증을 한다는 이해가 정확합니다.\n\n\"테스트 코드를 직접 작성하고 기존 코드를 분석하는 과정에서, 코드의 견고함을 확보하는 테스트의 중요성을 체감했습니다\" 아주 좋습니다. 사실 이러한 내용이 이론적으로 모르는게 아닌데 체감을 한다는게 참 중요하죠. 이번 과제가 그런 역할을 잘 해줬기를 바랍니다.\n\nQ1) 시스템 시간을 특정 월로 고정하고 해당 월의 휴일을 검증하는 현재 테스트 시나리오가 올바른 접근 방식인지, 혹은 더 효과적인 다른 테스트 방법이 있을지 궁금합니다.\n\n=> 현재 접근 방식이 올바릅니다. 시간에 의존적인 테스트는 항상 예측 가능하게 만드는 것이 중요해요. vi.setSystemTime으로 고정하는 것은 좋은 방법입니다.\n\n=> 다만 좀 더 명시적으로 테스트하려면 이런 방법도 있어요. 각 테스트 케이스마다 다른 시간을 설정해서 검증하는 거죠. 예를 들어 \"3월로 이동했을 때 삼일절이 나타나는지\", \"5월로 이동했을 때 어린이날이 나타나는지\" 이런 식으로요.\n\nQ2) 의미있는 테스트 시나리오와 테스트 항목을 잘 작성하는 팁이 있을까요?\n\n=> 일단 내가 구현한 내용을 혹은 디버깅을 할때 어떻게 테스트를 하고 있는지를 생각해보세요. 테스트 코드란 인간이 하는 그 일련의 과정을 컴퓨터에게 알아먹도록 코드로 작성하는 행위니까요.\n\n=> 그리고 좋은 테스트 코드는 기획서의 내용(=요구사항)과 일치합니다. 내가 요구사항을 받아서 어떻게 구현을 했고 그 구현이 요구사항에 맞게 만들었는지를 확인하는 그 과정을 테스트 코드화 한다라고 생각해보세요.\n\n=> 이후 엣지 케이스는 이걸 사용자가 모르는 사람이 실행할때 의도치 않은 입력을 한다면 뭐가 있을까 하면서 경계값 테스트를 의식적으로 추가해보세요. 아까 \"무엇을 테스트할까?\"가 완성이 되었다면 추가적으로 \"무엇이 잘못될 수 있을까?\"를 생각해보세요. 버그가 발생할 수 있는 지점들을 먼저 찾아보는 거예요.\n\n어쨌건 이러한 고민들이 한번에 잘 만들어야겠다가 아니라 일단 만들어보고 경험해보자는 생각으로 시도하면서 마주하고 풀리게 될 고민들이라 꼭 실무에서 한번 써먹어 보기를 바래요! 다음 주차도 화이팅입니다 \n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/55"
    }
  },
  {
    "passed": true,
    "name": "김효진",
    "feedback": "안녕하세요 효진님!! 7주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 테스트 코드의 항목을 나누는 기준이 궁금합니다. 어느정도 세세하게 나눠야하는지에 대한 기준이랄까요? 테스트의 양이 많아지더라도 모든 발생 가능한 동작에 대해서 테스트 코드를 짜는게 좋은지 궁금합니다.\n\n나누는 기준은 함수마다 다르다고 생각해요. 어떤 함수는 input과 output의 범위가 명확하고, 경계값에 대해 딱 테스트하면 되기 때문에 이에 대한 고민을 할 필요가 없어지기도 하고..?\n\n어떤 함수는 이게 불명확한 경우도 있고 그러니까요 ㅎㅎ\n저는 개인적으로 \"최대한 많은 케이스\"에 대해 일단 작성해보는걸 권장드려요. 효율적인 방법을 찾기 위해선 일단 많이 해봐야하고 체험을 해야 한다고 생각합니다.\n\n일단 커버리지 100%를 다 채워보는거죠. 그렇게 하다보면 \"이런 테스트는 없어도 될 것 같은데..?\" 라는 생각이 들 수 있어요.\n\n저의 경우 테스트 코드 항목... 이라기보단 컴포넌트에 대한 테스트는 무의미한 경우가 많다고 생각해요.\n컴포넌트의 내부 로직을 훅으로 분리한 다음 훅의 input/output 에 대해 테스트하는거죠.\n\n어차피 컴포넌트는 데이터를 표현하는 수단이니까요 ㅎㅎ\n\n> handler와 handlersUtils를 작성하기는 했지만 이 둘에 대한 구분이 정확히 되진 않은 것 같습니다. 실제로 코드에서도 handler는 setupServer에서만 사용되고 테스트 코드를 작성할 때는 handlersUtils만 사용했는데 그렇다면 이 둘을 제대로 활용을 못하고 있는 것 같아서요. 둘의 정확한 차이와 각각 어떻게 쓰이면 좋은지 궁금합니다.\n\n차이가 없다고 느낀다면 그냥 합쳐도 된다고 생각해요 ㅋㅋ\n제가 설명해서 납득하는 것 보다 효진님께서 느낀게 중요하니까요.\n\nhandlerUtils는 각 테스트 케이스에 필요한 별도의 핸들러를 초기화 및 정의하는 용도\nhandler는 대부분의 테스트에 필요한 기본적인 핸들러를 정의하는 용도\n\n이렇게 구분할 수 있지 않을까 싶네요 ㅎㅎ",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/29"
    }
  },
  {
    "passed": true,
    "name": "김휘린",
    "feedback": "수고했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. 회고를 보아하니 잘 수행해준 것 같아요.\n\n\"처음 easy 난이도의 테스트들을 작성할 때, 생각보다 괜찮은데? 라는 생각으로 쉽게 작성했다..\" 다행입니다. 매번 기수때마다 이번 챕터의 과제의 양에 압박을 받고 테스트 코드라는 안해본 걸 해야하기에 쉽게 시작을 못 하는 경우가 많았는데 순수 함수부터 시작해서 점진적으로 복잡도를 높여가는 과정이 테스트 코드의 허들을 낮추며 친해지는 계기가 되었으면 좋겠네요.\n\n\"마치 내가 QA를 하는것처럼 이런 케이스는 이렇게 검증해야지 하는 생각을 먼저 한 뒤 코드로 옮기면 쉽게 끝낼 수 있었다\" 아주 테스트 코드는 첫번째로는 나 대신 컴퓨터가 구현한 결과를 디버깅한 결과를 테스트 하는 과정을 옮겨내는 것이고, 이후 사용자가 이 과정을 테스트할때 잘못된 행동을 하는 것을 추가적으로 검증하는 거니까요. 이 두가지를 생각하면 테스트 코드를 어떻게 작성해야할지 더 감이 잘 올거에요!\n\nQ1) MUI의 Select컴포넌트의 option은 react portal로 열리는것을 확인했습니다. 그런데 어떻게 App 외부의 option을 클릭할 수 있었는지 의문입니다.\n\n=> React Testing Library는 실제 DOM을 기반으로 동작하기 때문에 portal로 렌더링된 요소들도 찾을 수 있어요. 이건 Virtual DOM의 장점인데 결국 가상으로 만들어진 데이터이기에 React의 요소를 그대로 찾을 수 있는 것이죠. testing-library/react의 render 함수가 이러한 Virdual DOM document를 기준으로 쿼리를 수행을 하지요. 그래서 portal로 body에 추가된 요소들도 screen으로 접근 가능합니다.\n\nQ2) 두 케이스는 사실상 내부적 동작이 같습니다. 이런 경우 하나의 설명으로 요약하고 테스트를 줄여야하는지, 아니면 월의 경계를 더 다양하게 설정해서 테스트를 했어야 하는지 궁금합니다.\n\n=> 결과적으로 그렇게 만들어졌겠지만 테스트 케이스의 의도가 달라지면 결국은 테스트 코드가 달라지기 마련입니다. 애초에 \"월의 경계에 있는 이벤트 필터링\"과 \"7월 전체 이벤트 반환\"은 검증하고자 하는 시나리오가 다르기에 월의 경계에 있는 이벤트가 7월이 아닌 것들도 나중에는 검증을 하게 될테니까요. 물론 휘린이 말한대로 어색해 보이는 테스트 코드에 케이스의 의도를 더 살린 코드들을 추가해주면 더 좋겠죠!\n\nQ3) 통합테스트에서 notification 알림 테스트 방법에 대한 질문입니다.\n\n=> 두 번째 방법(알림시간까지 시간을 흘려보낸 뒤 확인)이 가장 적절합니다. 통합테스트의 목적은 여러 모듈이 함께 동작하는 것을 검증하는 거거든요. 시간 흐름 → 알림 발생이라는 전체 플로우를 확인하는 것이 의미가 있어요.\n\n=> 첫 번째 방법은 휘린님 말씀대로 단위 테스트와 차이가 없고, 세 번째 방법은 너무 많은 것을 한 번에 검증해서 실패했을 때 원인 파악이 어려워요. 통합테스트는 초기 상태를 기반으로 요구사항의 의도를 하나씩 검증하는 것을 목적으로 합니다. 하나의 거대한 시나리오를 전체로 테스트를 하는건 e2e가 하는것이죠. 둘의 테스트가 추구하는 것이 다르므로 통합 테스트는 기능에 대한 요구사항의 케이스 검증이고 e2e는 사용자 관점에서 실제 환경에서의 하나의 큰 흐름을 테스트하는거라고 생각해주세요! :)\n\n테스트 코드에 대한 전반적인 감을 잘 익히신 것 같아서 좋네요. 이런 고민들을 하면서 점점 더 나은 테스트를 작성하게 될 거예요. 다음 주 과제도 화이팅입니다\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/35"
    }
  },
  {
    "passed": true,
    "name": "박상수",
    "feedback": "상수님~ 회고 문서가 없어서  당황했었네요\n사실 체크박스가 중요하긴 한데 코드를 살펴보니 코드를 대부분 작성한 것으로 보입니다.\n그래서 일단 합격으로 드릴게요.\n다음엔 회고문서도 꼭 작성하시면 좋을 것 같아요.\n역랑을 궁극적으로 발전시키는데에는 동작하는 코드도 중요하지만 코드에대한 생각 정리와 과정에 대한 복기인 것 같습니다!",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/28"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "소연님 수고하셨습니다.\n음 이정도로 하실거면 그냥 hard를 도전해보시지 그러셨어요 :) \n많은 노력을 하신 흔적이 보여서 너무 좋습니다!\n정말 시간만 더 있으셨다면 hard로 bp도 노릴 수 있으셨지 않았을까 싶어요!\n수고하셨습니다~\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/52"
    }
  },
  {
    "passed": false,
    "name": "박의근",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "박준형",
    "feedback": "안녕하세요 준형님! 7주차 과제 잘 진행해주셨네요 ㅎㅎ\n\n준형님께서 작성해주신 테스트에 대한 관점이 무척 인상적이었어요. 저는 이런 생각을 해본적이 딱히 없었는데, 덕분에 좋은 인사이트 얻어갑니다!\n\n프론트는 결국 data의 표현에 집중이 되어있는 경우가 많다보니.. 테스트의 효과를 체감하기 어려운 부분이 분명 있으리라 생각해요. 다만 이것도 어떤 서비스 혹은 도구를 만드냐에 따라 달라질 수 있어서 테스트 앞에는 \"비즈니스\"에 대한 내용이 추가되어야 한다고 생각한답니다 ㅋㅋ\n\n제가 만드는 제품의 경우 ux보단 진짜로 백엔드처럼 데이터에 대한 input/output 이 무척 중요하다보니..\n\n> EventTestStore 패턴: Map 기반으로 구현했는데, 이 방식이 다른 프로젝트에서도 일반적으로 사용하는 접근인지 궁금합니다. factory 패턴이나 builder 패턴으로 확장하는 게 더 적절할까요?\n\n일반적인 접근은 아니라고 느꼈어요. 이게 필요한 이유가 각 테스트가 다루는 데이터를 독립적으로 다루기 위함인데 보통 beforeEach, beforeAll, afterEach, afterAll 등에서 초기화를 해주고, 초기화과 완료된 시점에 테스트를 진행한다거나 하니까요 ㅎㅎ\n\n준형님께서 만들어주신건 데이터를 초기화한다기보단 데이터를 아예 독립적으로 분리해서 관리하면 좋지 않을까!? 라는 의도로 보였습니다. 좋은 아이디어라고 생각해요!\n\n그리고 이걸 만들어가는 방식은.. builder는 잘 모르겠고 factory (createData 같은...?) 방식으로 만들면 나쁘지 않을 것 같네요!\n\n잘 생각해보니, 저희 팀은 create~~~ 방식으로 테스트 데이터를 각 테스트마다 만들어서 사용하고 있네요 ㅋㅋ\n\n> 통합 테스트 범위: medium.integration.spec.tsx 같은 경우, \"일정 추가\" 테스트에서 폼 입력 → 저장 → 목록 확인까지 전 과정을 한 테스트로 두었는데요. 이렇게 긴 시나리오를 그대로 두는 게 맞는지, 아니면 쪼개는 게 더 바람직한지 고민입니다. 만약 쪼갠다면 어떤 기준이 적절할까요?\n\n문제를 잘 발견할 수 있다면 어떤 방식이든 중요할까? 라고 생각해요. 물론 테스트를 더 잘 작성하고 관리할 수 있는 방법이 있겠지만 중요한건 테스트를 통해 사이드 이펙트를 찾아서 조기조치 할 수 있는게 테스트의 첫 번째 원칙이라고 스스로 생각하고 있어요.\n\n그래서 말씀해주신 것 처럼 해도 무방하고, 이걸 쪼갠다면 아마 그냥 일부 과정을 유틸 함수 같은걸로 분리해서 다룰 수 있지 않을까!? 라는 생각이 들어요 ㅎㅎ\n\n이런 느낌이죠.\n\n```tsx\ntest('일정 추가 테스트', () => {\n  폼입력_검증();\n  폼저장_검증();\n  목록확인_검증();\n})\n```\n\n근데.. 딱히 정답은 없다고 생각해요 ㅋㅋ\n\n> 테스트 데이터 관리: createTestEvent()를 통해 기본값을 세팅하고 필요한 부분만 오버라이드하는 방식을 썼습니다. 그런데 경우에 따라선 오히려 혼란스럽기도 했습니다. 매번 완전한 데이터를 새로 만드는 방식과 비교했을 때 어떤 접근이 더 유지보수에 유리할까요?\n\n어떤 부분이 혼란스럽게 느껴졌을까요!? 유지보수에 좋은 방식이 뭘까 고민해보자면, 테스트를 보고 어떤 값이 표현되고 있는지 어떤 값을 수정했는지 한 눈에 볼 수 있으면 좋다고 생각해요.\n재활용의 측면보다 읽기가 수월한가? 에 대한 측면이 테스트에서는 더 중요하다고 생각합니다!\n\n그래서 지금 방식도 나쁘지 않다고 생각해요 ㅎㅎ ",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/4"
    }
  },
  {
    "passed": true,
    "name": "박창준",
    "feedback": "안녕하세요 창준님! 역시 믿고 보는 창준님의 과제네요 ㅎㅎ\n\n> act는 React의 상태관리를 래핑해주는 함수로만 알고있고 waitFor은 비동기나 useEffect처리처럼 바로 나타나지 않는 결과를 처리할때 쓰는거로 공부했는데 어떨때 적절하게 쓸지 아직 감은 못잡았습니다.\n\nact는 React의 렌더링 시스템과 연관있는데요, 비동기로 동작하는 react의 렌더링을 동기적으로 치환해주는 역할을 해준답니다 ㅎㅎ\nwaitFor은 일정한 시간동안 waitFor 내부에 정의된 코드가 정상적으로 동작할 때까지 기다리는거라서 큰 차이가 있어요.\n\n> 무엇보다 단순히 테스트를 많이 작성하는 것이 아니라 어떤 것이 의미가 있고 어떤것이 불필요할지 구분하는 감각을 조금이나마 얻을 수 있게된것 같습니다.\n\n좋은 인사이트를 얻어가셨군요!! 다행입니다!!\n\n> MUI 같은 외부 UI 라이브러리를 쓰다 보면 포털, 비동기 렌더링 같은 특성 때문에 예상치 못한 DOM 구조가 생겨서 테스트 작성이 복잡해지는 경우가 있습니다. 특히 UI 라이브러리를 MUI에서 Antd나 shadcn 같은 다른 걸로 바꾸면 테스트 코드도 크게 수정해야 할 것 같은데요. 실제 실무에서는 이런 DOM 의존적인 테스트에 시간을 많이 쓰는 편인가요? 아니면 테스트 전략을 단순화하거나, UI 라이브러리에 덜 의존하는 방식으로 접근하는 경우가 더 일반적인가요?\n\n저는 UI에 대한 테스트는 딱히 하지 않고 있어요 ㅎㅎ\n컴포넌트(UI)는 결국 데이터를 표현하는 수단이라고 생각합니다. 그렇다면 컴포넌트가 아니라 컴포넌트 렌더링에 필요한 데이터와 데이터를 변경하는 함수에 대해 테스트를 한다면 컴포넌트에 대한 검증도 자연스럽게 어느정도는 이루어지지 않나!? 라는 생각이라서요.\n컴포넌트에 대해 테스트가 꼭 필요한 경우는 인터랙션의 연결이 자연스러운지 검증할때라고 생각해요.\n물론 이 부분도 e2e 테스트를 통해 커버하는게 더 자연스럽다고 생각하는 편입니다!\n\n그리고 보통 컴포넌트에 대한 테스트는 스토리북으로 대체하는 경우가 많은 것 같아요 ㅋㅋ \n\n> 현업에서 TanStack Query를 많이 사용하는데, 이런 데이터 페칭 라이브러리를 사용하는 컴포넌트를 테스트할 때 테스트가 복잡하거나 관리하기 번거로운 편인지 궁금합니다. 특히, 캐싱, 비동기 상태, 쿼리 무효화 같은 기능 때문에 테스트 작성이 어려울 것 같은데 이런부분은 어떻게 학습하고 대응하는지 궁금합니다..\n\n위의 내용과 연계되는 부분인데요, 컴포넌트 자체보단 tanstack-query로 만들어진 코드를 훅으로 래핑한 다음에 훅에 대해 테스트를 하는 편이랍니다!\n\n> CI에서 간헐적으로 실패하는 테스트가 있습니다. 1주차에서도 그랬고 이번 과제에서도 그랬는데 로컬에서 돌리면 잘 통과하는 테스트들이 CI환경에서는 실패하는 경우가 종종 있더라구요. 이걸 플래키 테스트라고 부르던데 현업에서 이를 잘못된 테스트로 보고 반드시 리팩터링하는지, 아니면 리트라이 등 다른 방식으로 대응하는지 궁금합니다.\n\n대체로 이런 경우는 UI에 대해 테스트할 때 발생하는 것 같아요. e2e의 경우 패키지 버전에 따라 달라지기도 하고!?\n컴포넌트가 아닌 데이터를 다루는 함수에 대해서만 테스트 하는 경우에는 대체로 이런 문제가 발생하지 않았어서요..!\n그치만 원인 자체는 알아내고 이를 해결하면서 트러블슈팅을 하는 과정은 필요하다고 생각해요. 내가 알아낸 문제와 해결방법이 다른 사람들에게는 도움이 될 수 있으니까요!",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/44"
    }
  },
  {
    "passed": true,
    "name": "신홍준",
    "feedback": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/41\n수고하셨습니다 홍준님~\n아이고 이렇게 잘 작성해주셨는데, 큰일 날뻔했네요 ㅎㅎ\n기존 링크도 수정가능하면 수정해주시면 좋을 것 같네요.\n\nQ. vitest와 같은 플러그인 사용 등과 같이 하나의 테스트만을 독립적으로 실행하는 경우가 되게 많다고 생각하는데, handlers를 사용하면 이전, 이후 테스트에 영향을 끼치게 되더라구요. handlers만을 사용한 병렬적이지 않은 테스트 코드는 언제 필요할까요? QnA 때도 대충의 설명은 들었지만 구체적인 예시를 몰라서 그런지 감이 잡히지 않습니다.\n\nA. QnA때 어떤 이야기가 설명되었는지 잘 모르겠네욥. 말씀하셨던 대로 handlersUtils를 사용해서 테스트 별로 독립적인 목데이터와 핸들러로 병렬 테스트 실행에도 서로 영향을 받지 않도록 만들었어요.  글로벌하게 handler를 등록해서 사용하는 것보다는 유닛테스트의 경우에는 지금 처럼 독립적으로 구성하는 것을 추천해요. 나중에 통합테스트나 전체적인 시나리오의 흐름을 테스트할 때 필요할지 모르겠지만 그럴때도 조금 큰 영역을 커버하는 독립적인 핸들러를 등록하는게 좋지 않을까 싶습니다. 독립적으로 구분해놓은 핸들러를 조합하는 형태로 큰 영역을 커버하면 재사용성이 높아질 것 같아요~\n\n아직 저도 써보진 않았지만 msw 2.2부터는 boundary라는 기능이 생겨서 애초에 병렬 실행에서 서버를 격리할 수 있는 기능이 생겼어요. 요것도 한 번 살펴보시면 도움이 될 것 같습니다.\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/34"
    }
  },
  {
    "passed": true,
    "name": "신희원",
    "feedback": "수고했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. \n\n\"Hard 진행하다가 커밋하지 않은 파일들이 다 날라갔어요.. ^0^\" ... 내가 웃는게 웃는게 아니야.. ㅠ 아이고... 정말 고생 많으셨네요. git reset --hard는 정말 조심해야 하는 명령어인데 ㅠㅠ 그래도 미디움으로 다시 해보면서 반복학습할 수 있어서 좋았다고 하니 긍정적으로 생각하는 모습이 대단합니다. 멋집니다!!\n\n\"결국 구글링을 해서 찾은 방법!!! 몇시간동안 삽질했는데.... 다음부터 절대 똑같은 에러를 보더라도 AI한테 고쳐달라는둥 시간낭비하지말자\" 아주 소중한 경험이었네요! AI도 좋은 도구지만 결국 본질적인 문제 해결 능력은 직접 찾아보고 이해하는 과정에서 나오는 거죠. 이런 삽질 경험이 실력 향상에 더 큰 도움이 됩니다. 최근에 느낀 하나의 팁이 있다면 내가 잘 모르겠지만 AI를 썼을때 답이 수렴되지 않는다면 AI가 방향성을 제대로 짚지 못한거구나 하는 징조로 느낄 수 있더라구요. ㅎ\n\n\"easy 테스트 작성도 재밌었고, 통합테스트는 처음에 좀 막막했지만 방법을 알고 하나씩 해보니 오히려 easy보다 더 재밌었습니다\" 맞습니다. 유닛테스트는 내가 함수만 잘 만들어 두면 이제 AI가 뚝딱 만들어줄 정도로 쉬운 영역이죠. 통합테스트는 상태를 기반으로 기획서와 코딩을 맞춰가는 재미가 있지요!\n\nQ1) 데이터를 불러오는 방법 중에 1번 방법은 언제 많이 사용하는지 궁금합니다.\n\n=> 1번 방법(setTimeout(resolve, 0))은 \"다음 이벤트 루프\"로 넘어가면서 pending 상태의 Promise들이 resolve되기를 기다리는 방식이에요. 주로 useEffect나 비동기 작업이 자동으로 실행되는 경우에 사용합니다.\n\n=> 2번 방법은 명시적으로 함수를 호출하는 거고요. 더 명확하고 의도가 분명하기 때문에 2번 방법이 일반적으로 더 좋아요. 1번 방법은 \"뭔가 비동기적으로 실행될 것 같은데 정확히 언제 실행될지 모를 때\" 사용하는 일종의 해킹 기법입니다.\n\nQ2) 의미있는 테스트 코드를 작성하기 위한 기준이 어떤것인지 궁금합니다.\n\n=> 제일 중요한건 desc에 쓰는 테스트의 의도, 즉 요구사항에 기반하는 것이 중요합니다. 기획서에 해당하는 요구사항이 있었다면 너무 뻔하다고 할지라도 테스트를 하는게 좋습니다.\n\n=> 이번에 보여준 예시에서는 경계값의 테스트인데 달력으로 입력을 받는 Form을 사용한다면 사실 경계값등은 크게 문제가 되지 않을 수도 있겠지만, 코드로 입력하는 엑셀같은거였다면 반드시 검증을 해야겠지요. 사용자 입장에서 해당 요구사항이 틀릴 수 있는 환경인지 아닌지, 그래서 기획상에서 요구사항에 명세를 담아할 정도라면 테스트를 하는게 좋습니다.\n\n=> 그래서 정리하자면 1) 기획관점에서 요구사항 관점에서 중요한 시나리오인가? 2) 그리고 사용자로 인해서 실제로 발생할 수 있는 상황인가? 3) 이 테스트가 실패하면 사용자에게 문제가 되는가? 혹은 무언가 처리가 필요한가? 이런 기준으로 판단해보세요.\n\n고생 많으셨고, 이런 시행착오 경험들이 나중에 더 큰 자산이 될 거예요. 다음주 과제도 화이팅입니다! ",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/42"
    }
  },
  {
    "passed": false,
    "name": "양성진",
    "feedback": "안녕하세요 성진님! 7주차 과제 잘 진행해주셨네요 ㅎㅎ\n심화과제의 경우 컴포넌트에 대한 테스트만 추가되어서 아쉽지만 불합격으로 남겨놓겠습니다 ㅠㅠ\n\n> 테스트를 작성하게 되면 어떤 내용은 테스트를 해야할지, 아니면 안해도 되는지에 대한 뭔가 그 경계선을 어떻게 잡으면 좋을까요? 저는 사용자가 직접 자주 접하는 기능을 위주로 테스트코드를 만드는게 가장 맞는거 같은데 꼭 그렇지는 않은가요.\n\n말씀하신 기준으로 적용해도 좋고, 저의 경우 의존하는 파일 혹은 함수가 많은 경우 (가령 유틸함수 같은..?) 에는 꼭 테스트가 필요하다고 생각해요! 변경사항에 대한 여파를 최대한 안전하게 관리하는거죠 ㅎㅎ\n\n경계에 대해 찾아가는 방법은.. 답정너 같긴 한데 결국 테스트를 많이 작성해보면서 알아가는게 좋다고 생각해요 ㅋㅋ 일단 테스트를 많이 작성해보세요!\n\n> 이번에 만들다보니까 결과를 알고 만드는거라 케이스를 억지로 짜맞춰서 만드는거 같은데 케이스를 보통 어떻게 해야 좋은 케이스를 테스트코드에 줄수 있을까요? 좋은 테스트 코드를 만드는 전략이라는게 생각하시는게 있나요?\n\n결과를 알고 만드는게 테스트이지 않을까요? 완성된 결과물에 대해 테스트 케이스를 정의하고 만들어가는 게 기본적인 테스트 방식이라고 생각해요 ㅎㅎ\n아마 성진님께서 생각하는건 TDD 같은데 처음부터 TDD에 집중할필요는 없답니다.\n\n테스트에 대해 익숙해질 때 TDD도 잘 할 수 있다고 생각해요..!\n좋은 테스트 코드를 만들기 위해선 위에도 이야기 했지만, 일단 테스트 자체를 많이 만들어보시면 좋아요.\n그러다보면 자연스럽게 \"이런 테스트는 읽기가 어렵네?\" 라는 지점도 있을 것이고, \"이런 테스트는 독립적이면 좋겠네?\" \"이런 테스트는 너무 느리네?\" 라고 알아가는 부분도 있으리라 생각해요.\n\n이에 대해 하나하나 다 설명하기보단 성진님께서 작성해보고 느껴보는게 중요하다고 생각합니다.\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/43"
    }
  },
  {
    "passed": false,
    "name": "양창훈",
    "feedback": "아숩게도 테스트가 완전히 통과하지는 못했네요ㅜ\n일단 지금 작성되어 있는 테스트를 보면 작성하시는데 특별하게 엄청 잘못된 패턴은 없는 것 같고 시간이 부족하셨던 것 같네요.\n여유가 있으실 때 꼭 채워주시고 관련해서 학습 진행해주시면 좋겠네요!\n\n화이팅입니다~",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/59"
    }
  },
  {
    "passed": false,
    "name": "여진석",
    "feedback": "안녕하세요 진석님! 7주차 과제 잘 진행해주셨네요 ㅎㅎ 다만 심화과제는 시간이 많이 부족했군요.. ㅠㅠ 아쉽습니다.\n\n> handlersUtils 함수 로직: 과제의 핵심이 병렬로 실행했을 때 문제가 없어야한다고 하셨는데, 테스트가 병렬로 돈다면, 여러곳에서 동시에 server.use로 override를 하면 문제가 생기는 것이 아닌가? 하는 걱정이 되었습니다. 테스트를 실행했을 때는 문제가 발생하지 않는데, 테스트가 병렬로 돈다는 의미가 동시에 테스트가 실행된다는 것은 아닌걸까요? server.resetHandlers()를 해주지 않으면 외부 테스트에 영향주는 것을 보았을 때는 그렇지만은 아닌거같고.. 약간 혼란스러운 부분입니다.\n\n## 테스트 병렬 실행의 의미\n\nJest/Vitest에서 \"병렬 실행\"은 **서로 다른 테스트 파일들**을 병렬로 실행하는 것을 의미한답니다!\n\n```bash\n# 이런 식으로 여러 파일이 동시에 실행됩니다\ntest-file-1.test.ts (Worker 1) ← 독립적인 프로세스\ntest-file-2.test.ts (Worker 2) ← 독립적인 프로세스  \ntest-file-3.test.ts (Worker 3) ← 독립적인 프로세스\n```\n\n하지만 별도의 설정을 해주지 않는다면 **하나의 테스트 파일 내부에서는 테스트들이 순차적으로** 실행된답니다..!\n\n공식문서 링크: https://vitest.dev/guide/parallelism.html#file-parallelism\n\n## MSW Server 인스턴스\n\n각 테스트 파일은 독립적인 MSW server 인스턴스를 가집니다.\n\n```typescript\n// setupTests.ts에서 생성된 server는 각 파일마다 독립적\nexport const server = setupServer(...handlers);\n```\n\n따라서 파일 A에서 `server.use()`를 호출해도 파일 B의 server에는 영향을 주지 않는답니다!\n즉, 다르게 이야기해보자면 같은 파일 내의 테스트 간에는 문제가 생길수도 있어요.\n\n\n```typescript\n// 같은 테스트 파일에서\ndescribe('Event tests', () => {\n  test('should handle creation error', () => {\n    setupMockHandlerCreationError(); // server.use()로 POST 핸들러 추가\n    // 테스트 실행...\n  });\n\n  test('should handle normal flow', () => {\n    // 이전 테스트의 POST 핸들러가 여전히 활성화되어 있을 수 있음!\n    // afterEach는 테스트 완료 후에 실행되므로\n  });\n});\n```\n\n그래서 이러한 접근이 필요할 수 있답니다!\n\n```typescript\nexport const createMockHandlerScope = (handlers: any[]) => {\n  let originalHandlers: any[];\n  \n  return {\n    setup: () => {\n      // 현재 핸들러 백업\n      originalHandlers = server.listHandlers();\n      server.use(...handlers);\n    },\n    cleanup: () => {\n      // 정확히 이전 상태로 복원\n      server.resetHandlers(...originalHandlers);\n    }\n  };\n};\n\n// 또는 테스트별 독립적인 설정\nexport const withMockHandlers = (handlers: any[], testFn: () => void) => {\n  const originalHandlers = server.listHandlers();\n  \n  beforeEach(() => {\n    server.use(...handlers);\n  });\n  \n  afterEach(() => {\n    server.resetHandlers(...originalHandlers);\n  });\n  \n  return testFn;\n};\n```\n\n> 회사에서 테스트 코드 도입하는 방법:  위에 회고에 적은 것처럼 레거시 로직과 함께 개발할 때 필요성이 느껴진 것 같습니다. 해당 포인트로 팀원들과 얘기해서 도입을 해볼까 싶은데, 준일님은 어떻게 생각하시나요? 제가 새로운거 배웠다고 신나서 편협된 시각으로 지금 상황을 바라본게 아닐까? 걱정되었습니다.\n\n테스트를 정말 도입하고 싶다면, 팀에 \"테스트\"에 대한 이야기를 꺼내지 않고 일단 테스트를 작성해서 PR을 올린다음에 \"이렇게 하니까 ~~ 등의 효과를 느꼈어요!\" 라고 추가해보는거죠 ㅎㅎ\n\n무조건 모든 코드에 도입하기보단 그냥 진석님이 필요하다고 생각하는 부분에 테스트를 추가해서 도입하면 된다고 생각해요.\n\n이렇게 일단 눈에 보이는 방식으로 테스트를 보여준 다음에 팀원의 반응을 살펴보세요. \"굳이?\" 라는 키워드가 계속 노출된다면.. 아마 도입하기 힘들 수 있답니다 ㅠㅠ\n\n> 테스트 코드의 기대값을 어디까지 정적으로 두어야하고 동적으로 만들어야할지? (이미 오프코치님께서 답변을 해주셨지만, 준일님께도 들어보고 싶네요 ㅎㅎ..)\n\n이런 문제를 해결하기 위해 목데이터가 있다고 생각해요 ㅎㅎ 기대값이 바뀌지 않도록 목데이터를 통해 고정해놓는거죠.\n그러면 꼭 이럴 때 목데이터를 써야하는가!? 라기 보단... 최소한의 고정이 필요하다고 생각해요.\n가령 날짜만 고정해놓는다거나!?\n\n사이드 이펙트가 최소화된 로직이라면 어떤 input이든 output을 뱉어내는 방식은 동일할테니까요!\n대신 엣지케이스(경계값)을 테스트 케이스에 꼼꼼하게 추가해주면 좋답니다!\n\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/3"
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "안녕하세요 찬규님! 7주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 테스트 케이스의 범위에 대한 고민이 있습니다 \"컴포넌트가 렌더링되는가\" 같은 기본적인 테스트부터 복잡한 사용자 시나리오까지 다양하게 작성했는데, 어느 정도 선에서 테스트를 작성하는 게 적절한지 궁금합니다. 특히 단순한 렌더링 테스트가 실제로 의미가 있는 건지, 아니면 좀 더 비즈니스 로직에 집중해야 하는 건지 아직 감을 잘못잡았습니다...\n\nhttps://discord.com/channels/1288769861589270590/1369931229696229386/1408221063317295295\n\n오프 코치님께서 남겨주시긴 했는데, 저는 대체로 컴포넌트에 대한 렌더링 테스트는 무의미하다고 생각해요 ㅎㅎ\n컴포넌트는 \"데이터를 표현하는 수단\"이고, 그렇다면 데이터의 output에 대한 검증을 할 수 있다면 컴포넌트도 자연스럽게 검증되는게 많다고 생각합니다.\n다만 인터랙션을 컴포넌트가 연결해주기 때문에 인터랙션 연결이 자연스러운지에 대해서는 컴포넌트 레이어에서 테스트해볼 수 있겠죠!?\n다만 이게 vitest 처럼 nodejs 환경에서 검증하는게 대체로 어려어요.\n그래서 컴포넌트 레이어에 대한 테스트가 필요하다면 아예 e2e 테스트를 해보면 어떨까!? 라는 생각입니다.\n\n결론은, 비즈니스 로직에 조금 더 초점을 맞춰서 테스트 해주시면 좋겠다는 생각입니다!\n\n> 테스트 코드의 중복에 대해 궁금한 점도 있습니다! 비슷한 로직을 테스트하는 케이스들이 있는데, 이런 경우 테스트를 합치는 게 좋을지 아니면 각각의 케이스를 명확하게 구분해서 유지하는 게 좋을지 조언을 받아보고 싶습니다!\n\n검증하는 코드를 아예 함수로 분리해주시면 좋답니다 ㅎㅎ\n\n이런 느낌이죠.\n\n```tsx\ntest('일정 추가 테스트', () => {\n  폼입력_검증();\n  폼저장_검증();\n  목록확인_검증();\n})\n```",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/30"
    }
  },
  {
    "passed": false,
    "name": "오하늘",
    "feedback": "수고했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다.\n\n회고를 작성하지 않으신 것은 아쉽네요. 테스트 코드를 처음 접하는 분들이 많아서 과제를 진행하면서 어떤 어려움이 있었는지, 어떤 부분에서 성장을 느꼈는지 스스로 적어보면 빠르게 내것이 되는게 있답니다. 언제라도 적어 보길 바래요.\n\n테스트 코드 작성은 처음에는 막막하게 느껴질 수 있지만, 한번 경험해보면 생각보다 접근하기 어렵지 않다는 것을 알게 되었을거라 생각합니다. 순수 함수의 단위 테스트부터 시작해서 점진적으로 복잡한 통합 테스트까지 진행하는 과정에서 자연스럽게 테스트 코드에 대한 감을 익혔기를 바래요.\n\n테스트 코드는 우선 \"나를 대신해서 컴퓨터가 검증하도록 하는 과정\"이라는 것을 이해하는 것입니다. 내가 평소에 기능을 확인하기 위해 브라우저에서 클릭하고 입력하던 그 과정을 코드로 작성하는 것이죠. 이후에는 사용자가 이 기능을 수행할 때 기대하지 않은 동작을 할걸 예상하면서 예외처리등을 보강해가는 것이라 생각하면 조금 더 접근하기 쉬울 거에요. \n\n테스트 코드가 주는 가장 큰 가치는 심리적 안정감입니다. 코드를 수정할 때 \"다른 곳에서 에러가 나지 않을까\" 하는 불안감 없이 마음 놓고 리팩토링을 할 수 있게 되거든요.\n\n다음번에는 과제를 진행하면서 느낀 점들을 회고로 남겨주시면, 더 구체적이고 도움이 되는 피드백을 드릴 수 있을 것 같습니다. 코드를 작성하는 것도 중요하지만, 그 과정에서 무엇을 배웠고 어떤 어려움이 있었는지 돌아보는 것이 성장에 더 큰 도움이 되니까요.\n\n다음주 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/66"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "수고하셨습니다 윤우님!\n\nQ. setupTests쪽에서 vi.useFakeTimers({ shouldAdvanceTime: true });을 설정했습니다. 해당 옵션은 제가 이해하기로는 테스트속에서 시간이 흐르도록 만드는 옵션으로 이해했습니다. 그치만 medium.useNotifications.spec 테스트 코드 작성 시 vi.advanceTimersByTimeAsync(1000), 혹은 waitFor(()=>,{timeout:2000}) 형태의 코드를 넣어주지 않으면 시간이 흐른걸 테스트 하기가 어려웠습니다 해당 두 메서드 사용이 괜찮을까요? 더 좋은 방법이 있었을까요?\n\nA. 제가 예전에 정리한건 shouldAdvanceTime만은 타이머를 한번에 꽝하고 시간을 조절하는 것이 아니라 조금씩 흐르는 것을 시뮬레이션만 해줄뿐\n온전하게 시간이 흐르고 타이머의 콜백들이 온전하게 실행되게 하려면 시간을 쭈욱 밀어주는 작업이 필요하다로 정리했어요. 그게  vi.advanceTimersByTimeAsync()죠. 즉 shouldAdvanceTime 설정은 그냥 타이며 시간이 흐름에 관한 이야기고 온전히 시간히 흐른것을 보장해 모든 콜백을 실행하는 것은 별개의 이야기 인것이죠.\n\nQ. 컴포넌트 테스트 코드 작성 시 어떤걸 작성해야할지 조금 어렵습니다. 예를 들어 EventFormPanel 컴포넌트에 대한 테스트 작성 시 일정 수정, 일정 추가는 통합테스트에서 진행하는데 그럼 이 폼은 어떤걸 테스트해야하는걸까하는 생각이 들었습니다.\n\nA. 그러니까 중복테스트에 대한 이야기죠? 이건은 테스트전략을 짜기 나름인 것 같아요. 예를들어 단위테스트에서는 EventFormPanel의 스펙을 테스트하고, 통합테스트에서는 EventFormPanel를 사용하는 좀 더 큰 컴포넌트 예를들면 page레이어에서 통합테스트를 진행할수도 있는 것이지요. 저라면 그렇게 전략을 짤것 같아요~\n\n\nQ. 퍼블리싱을 할 때 각 역할에 맞는 role, aria-label 같은 요소들을 모두 설정해주는게 좋을까요? 어떤 UI는 없고 어떤 UI는 있는 경우들이 있는데 설정하는 기준이 궁금합니다!\n\nA. 어떤것이 더 옳은가 혹은 나은가에 대한 이야기라면 최대한 많이 aria를 커버하는 것이 접근성에는 좋을 수밖에 없어요. 하지만 실무에서는 많이 못챙기는데요 ㅎㅎㅎ 오히려 테스트를 작성할때 후킹(엘리먼트 찾기)용도로는 좋은 추상이라고 생각해서 테스트를 위해 자주 사용합니다 저는 ㅎㅎ",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/10"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "윤영서",
    "feedback": "안녕하세요 영서님! 7주차 과제 잘 진행해주셨네요 ㅎㅎ\n여러가지 일이 겹쳐서 항상 극한의 챌린지(?)를 하고 있는데 그럼에도 불구하고 뚝딱뚝딱 잘 해내는 모습이 멋있으면서도 걱정되네요 ㅋㅋ 너무 무리하진 않았으면 좋겠씁니다..\n\n> test() vs it()\n\n사실 이에 대해 깊게 고민해본적이 없었는데, 작성해주신 내용을 보고 \"아하! 그렇구나!\" 라는 생각을 했어요! 굿굿\n\n>  expect.hasAssertions()\n\n이것도 처음 보는데 덕분에 새로운 API를 알아갑니다 ㅋㅋ 감사해요\n\n> 미친 1시간 반동안의 트러블 슈팅 - Fake Timers와 비동기 작업 간의 타이밍 이슈\n\nㅋㅋㅋ 저도 2기 때 과제 솔루션 만들면서 동일한 문제를 겪었는데요, 1시간만에 해결하셨다니!!! 멋있네요..\n\n> 갑자기 작성하면서 든 궁금증인데, 그렇다면 만약 로딩후에 저런 토스트 메시지가 없는 경우에는 어떻게 비동기적으로 데이터가 불러와졌음을 알 수 있을까요? 작성하면서 궁금해집니다.\n\n이건 뭐.. 내부 로직이 어떻게 구현되었는가에 따라 다르다고 생각해요 ㅎㅎ 특저 함수의 호출로 확인해볼 수도 있고, 혹은 tanstack-query를 사용한다고 했을 때 강제로 onSuccess 혹은 onError 같은 이벤트를 밖에서 주입할수도 있고!?\n\n> useEventForm이라는 애가 너무 책임이 거대한것 같아서 내부적으로 역할을 분리하게 되었습니다. 그중에 useTimeValidation이라는 훅을 만들었습니다. 이 훅은 내부적으로 getTimeErrorMessage를 쓰는데 해당 유틸은 이미 유닛테스트가 존재합니다. 일단 저는 이 getTimeErrorMessage에 대한 검증을 useTimeValidation에서 하는게 의미가 없다고 생각하는데요. 그렇다면 useTimeValidation에서 할수있는 테스트는 구현에 대한 부분만 보면 상태 업데이트, 인터페이스관련, 핸들러를 생성하는 부분에 대한 것 정도가 될거같은데 이런 부분에 대한 검증이 의미가 있는 것일까요? 정리하자면 유틸함수에 대한 테스트가 구현되어있고, 이를 단순히 이용해서 상태를 관리하는 훅이 있다고 하면 이 훅에 대한 테스트가 유의미하다고 생각하시나요? '오류 상태에서 정상적인 값으로 변경하면 오류가 초기화되어야 한다' 와 같이 상태 업데이트 정도는 검증할 수 있겠다는 생각이 드는데, 어디까지 검증을 해야하는지 좀 모호한 것 같습니다.\n\n깊게 들어가서 고민해보자면.. 필요한 구간만 선별해서 검증하자! 라고 이야기할 수 있겠지만 솔직히 그걸 선별하는 과정이 더 오래걸린다고 생각해요 ㅎㅎ 아싸리 다 검증해버리는게 속편하지 않나? 라는 생각입니다. 저는 그냥 다 검증하는 편이랍니다.\n\n> 단순히 presentation 컴포넌트로 뷰잉역할을 하는 컴포넌트가 있을때 props로 핸들러들이 넘어온다는 이유로 어떤 이벤트가 발생햇을때 이벤트 핸들러를 모킹해서 테스트 하는게 의미가 있을까요?\n\n제가 종종 이야기 했었는데, 저는 컴포넌트에 대한 테스트는 의미 없는 경우가 많다고 생각해요. 컴포넌트는 데이터를 표현하는 수단이고, 그렇다면 데이터에 대해 그리고 데이터를 만들어내는 함수에 대해 검증할 수 있다면 컴포넌트에 대한 검증도 어느정도는 되는게 아닐까!? 라고 생각합니다.\n\n다만, 컴포넌트는 인터랙션을 연결하는 수단이 될 수 있기 때문에 인터랙션이 잘 발생하는가!? 정도는 테스트해볼 수 있겠죠 ㅎㅎ\n이 경우에는 그냥 e2e 테스트를.... 해보면 어떨까!? 라고 또 연결이 되네요 ㅋㅋ\n\n> 데이터가 전부 비어져있는 상황인 경우에 로딩후에 '일정 로딩 완료!'와 같은 토스트 메시지가 없다면 어떻게 데이터가 불러와졌음을 알아 차릴 수 있을까요?\n\n이야기드린 것 처럼 목 함수를 이벤트에 넘겨준 다음에 목 함수가 호출되는지 확인해보는거죠. 다만 이건 어떤식으로 코드가 작성되어있는지에 따라 달라질 수 있다고 생각해요!\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/24"
    }
  },
  {
    "passed": true,
    "name": "이가은",
    "feedback": "안녕하세요 가은님!! 7주차 과제 너무 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!!\n\n> 테스트 코드 첫 만남인데 너무 재밋고 어렵고 신기했습니다. 저한텐 유니콘🦄 같은 존재였는데 실제로 만나서 뿔도 만져보고 말도 걸어보고 생김새를 관찰해본 느낌이었습니다.\n\n표현이 인상적이네요!!\n\n> 테스트 코드는 기획, UX적인 측면에서 고려해야할 것이 많고 그 부분을 코드로 풀어야 하다보니 UX와 친하지 않다면 코드를 짤 때마다 고될 것 같습니다.\n\n프론트엔드 영역에서의 테스트는 말씀해주신 것 처럼 UI/UX 에 대한 표현과 결합이 되어있어서 이런 부분까지 코드를 통해 검증하기가 사실 쉽지 않죠.. 변경도 무척 많이 발생하기도 하고..?\n그렇다면 UI/UX에 대한 부분을 꼭 코드로 검증해야 좋은지 고민해보는것도 필요해요. 더 좋은 방법은 없을지, 혹은 어떻게 핵심만 분리해서 테스트할 수 있을지 등!\n\n> 프로덕트를 빠르게 개발한 후에 만드는 테스트 코드는 도입 의미가 희석될 수 있으며, 이 테스트 코드를 완벽에 가깝게 만들기 위해서는 상당한 시간 투자가 필요하다는 것을 과제하면서 또 다시 느꼈습니다.\n\n저는 사실 반대로 생각하는 편인데요, 테스트를 먼저 작성하든 늦게 작성하든 일단 있기만 하면 그 이후로는 안정감을 가지게 되어요. 그래서 코드를 더 적극적으로 개선할 수 있고, 그러다보면 자연스럽게 코드의 품질이 올라가는거죠 ㅎㅎ\n\n사람마다 가지고 있는 경험이 다르기 때문에 단언할 수는 없겠지만... 저는 TDD를 해야한다가 아니라 테스트를 어떤 방식으로든 작성해야 한다고 생각합니다! \n\n그리고 테스트 작성이 익숙해야 TDD도 가능하다고 생각해요!\n\n> 테스트 코드도 클린 코드만큼이나 가독성이 중요하고 개인의 취향을 많이 타는 것 같아서, 팀 내에서 일관된 스타일 가이드나 방향성이 있다면 더 좋을 것 같다고 생각했습니다. 특히 테스트 코드를 처음 작성하는 입장에서는 명확한 가이드라인이 있었으면 더 체계적으로 접근할 수 있었을 것 같습니다.\n\n이러한 가이드라인은 스스로 체감하면서 만들어가야 한다고 생각해요 ㅎㅎ 그래야 내가 테스트에 대해 더 자신있게 이야기할 수 있답니다!\n남들이 말하는 좋은 테스트가 아닌 내가 느끼고 체험한 좋은 테스트가 중요한거죠.\n\n> 현재는 각 테스트 파일 내에서 더미데이터를 관리하고 있는데, 프로젝트 규모가 커질 때를 대비한 효과적인 테스트 데이터 관리 방법이 있는지 궁금합니다. 언제 분리하고 어떤 기준으로 구조화하는 것이 좋을까요? 이전 멘토링때 코치님께서 실무에서 더미데이터를 따로 분리해서 사용하시는 것을 보여주셨는데 그 방법이 실제로 괜찮은 방법이어서 채택됐는지 아니면 다른 방법도 있었는데 그렇게 바뀌게 된건지도 궁금합니다.\n\n제가 담당하고 있는 프로젝트의 경우, 원래 테스트 데이터가 파편화 되어있었어요. 사실 테스트 케이스가 많지 않다면 상관 없는데... 프로젝트 규모가 커지고 테스트 케이스도 5000개 정도 되니까 자잘한 변경이 발생할 때 마다 테스트에 대한 유지보수를 하기가 너무 어려웠답니다 ㅎㅎ\n그래서 날잡고 팀원들과 다같이 테스트 데이터를 한 곳에 모아서 관리할 수 있도록 개선했어요. 이러면 변경에 대한 여파를 관리하기가 수월해지고 변경에 대한 대응을 신속하게 할 수 있어서 좋았답니다!\n\n현재 프로젝트에서 쓰이는 도메인 객체의 모습을 미리 만들어서 input/output 용도로 사용할 수 있도록 관리해보세요!\n\nhttps://jojoldu.tistory.com/611\n\ntest fixture 라는 용어로 검색해보면 많이 나온답니다!\n\napi와 강결합 되어있다면, api 데이터를 주기적으로 가져와서 fixture에 업데이트 하도록 설정하는 방법도 찾아보면 있어요! 지금은 기억이 가물가물해서... 어떻게 설정하는지 까먹었네요 ㅋㅋ;\n\n> 통합테스트가 단위테스트보다 작성하기 어렵고 복잡하다는 것을 경험했습니다. 실제 프로젝트에서는 이 둘의 적절한 비율이나 우선순위를 어떻게 정하는지, 그리고 통합테스트 없이 단위테스트만 진행할 경우 크게 문제가 있을까요? 테스트 코드를 작성하면서 일부 단위테스트의 내용이 통합테스트에도 비슷하게 사용되었는데 단위테스트에서 최대한 커버하고 통합 테스트에서는 딱! 단일 ui적인 부분만 테스트하면 되지 않을까..하고 상상해봤는데 맞는지 모르겠습니다!\n\n통합 테스트와 단위 테스트의 목적이 다르기 때문에, 단위 테스트만으로 통합 테스트의 문제를 해결하기는 사실 어려워요. \n그치만 통합 테스트를 작성하는게 굉장히 어렵고 복잡하기 때문에.. 이보다는 다른 방법에 대해 고민을 많이 했던 것 같아요.\n보통 통합테스트 대신에 스토리북을 이용해서 개별 UI에 대한 동작을 빠르게 검증하는 방식으로 진행하는 모습을 많이 봤어요.\n컴포넌트에 대한 통합 테스트 대신 컴포넌트 내부 로직을 훅으로 분리해서 훅에 대해 테스트를 한다거나..!?\n혹은 아예 e2e 테스트를 진행하는거죠 ㅎㅎ\n\nplaywright으로 e2e 테스트를 하는 방법에 대해 한 번 찾아보시면 좋답니다!\n\n\n\n\n\n\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/53"
    }
  },
  {
    "passed": false,
    "name": "이민재",
    "feedback": "수고했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. 회고를 보아하니 이번 과제가 좋은 의미가 되어 준것 같네요.\n\n\"초기엔 코드 한줄 한줄 문서를 보며 테스트를 실행시키며 해결해가는 과정이 시간이 촉박하기도 하고, 성취감을 느끼기도 했습니다.\" 맞아요. 처음엔 막막하지만 하나하나 이해해가는 과정에서 성취감이 생기죠. 테스트 코드가 당장 실무로는 와닿지 않고 뭔가 다른 세상의 코드 같아서 막연함이 있지만 막상 해보고 나면 아~ 이런거구나 하는 마음이 들었을거에요.\n\n\"가장 큰 필요성을 느꼈을 때가 바로 리팩토링 과제 때 였습니다.\" 좋은 인사이트네요. 실제로 번들 시스템 개선과 노드 업그레이드 같은 작업을 할 때 테스트 코드가 없으면 정말 막막하죠. 테스트 코드의 필요성을 체감하는건 중요한 경험입니다. 그래야 해볼 수 있는 동력이 생기니까요.\n\nQ) 테스트 코드를 안정적이면서 실용적으로 작성하는 방법에 대해서 고민이 됩니다. 나도 모르게 의도되는 값으로 작성을 하게 될 수도 있을 것 같고, 엣지 케이스에 취약할 것 같은데 어떤 식으로 실무에서 테스트 코드를 계획하고 구성하시는지 알고 싶습니다!\n\n=> 함수나 훅 혹은 컴포넌트의 입장보다는 사용자의 입장이 되어 보는 것이에요. 내가 QA라면 의도적으로 여기에 어떤 나쁜 값을 넣어 볼 수 있을까? 이미 UI나 UX등에서 걸러진다거나 만들 수 없는 값들을 생각하지 마세요. 반대로 이런 값들을 실수로 혹은 악의적으로 넣어 볼 수 있겠는데? 하는 식으로 예측하며 엣지 케이스를 떠올려 봅시다.\n\n=> 그렇지만 엣지 케이스에 취약하더라도 정상동작만 체크해주는 테스트 코드라고 충분히 가치가 있어요. 그러니 일단은 만들어 보는 것에 집중을 합니다. 그러다보면 자연스럽게 분명 잘못된 경우인데 테스트가 통과를 하는 경우도 생겨요. 이럴때 아하! 하면서 보강을 해줘도 늦지는 않습니다. 테스트 코드는 한번에 잘 만드는게 아니라 야금야금 함께 성장하는것이니까요.\n\n이번 과제의 경험이 꼭 실무에서도 이어져서 꼭 하나라도 만들어보면서 그 가치를 지속적으로 확인해보길 바라요. 수고하셨습니다.",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/49"
    }
  },
  {
    "passed": false,
    "name": "이유진",
    "feedback": "수고했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다.\n\n회고를 작성하지 않으신 것은 아쉽네요. 테스트 코드를 처음 접하는 분들이 많아서 과제를 진행하면서 어떤 어려움이 있었는지, 어떤 부분에서 성장을 느꼈는지 스스로 적어보면 빠르게 내것이 되는게 있답니다. 언제라도 적어 보길 바래요.\n\n테스트 코드 작성은 처음에는 막막하게 느껴질 수 있지만, 한번 경험해보면 생각보다 접근하기 어렵지 않다는 것을 알게 되었을거라 생각합니다. 순수 함수의 단위 테스트부터 시작해서 점진적으로 복잡한 통합 테스트까지 진행하는 과정에서 자연스럽게 테스트 코드에 대한 감을 익혔기를 바래요.\n\n테스트 코드는 우선 \"나를 대신해서 컴퓨터가 검증하도록 하는 과정\"이라는 것을 이해하는 것입니다. 내가 평소에 기능을 확인하기 위해 브라우저에서 클릭하고 입력하던 그 과정을 코드로 작성하는 것이죠. 이후에는 사용자가 이 기능을 수행할 때 기대하지 않은 동작을 할걸 예상하면서 예외처리등을 보강해가는 것이라 생각하면 조금 더 접근하기 쉬울 거에요. \n\n테스트 코드가 주는 가장 큰 가치는 심리적 안정감입니다. 코드를 수정할 때 \"다른 곳에서 에러가 나지 않을까\" 하는 불안감 없이 마음 놓고 리팩토링을 할 수 있게 되거든요.\n\n다음번에는 과제를 진행하면서 느낀 점들을 회고로 남겨주시면, 더 구체적이고 도움이 되는 피드백을 드릴 수 있을 것 같습니다. 코드를 작성하는 것도 중요하지만, 그 과정에서 무엇을 배웠고 어떤 어려움이 있었는지 돌아보는 것이 성장에 더 큰 도움이 되니까요.\n\n다음주 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/56"
    }
  },
  {
    "passed": true,
    "name": "이은지",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/64"
    }
  },
  {
    "passed": false,
    "name": "이의찬",
    "feedback": "수고했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다.\n\n회고를 작성하지 않으신 것은 아쉽네요. 테스트 코드를 처음 접하는 분들이 많아서 과제를 진행하면서 어떤 어려움이 있었는지, 어떤 부분에서 성장을 느꼈는지 스스로 적어보면 빠르게 내것이 되는게 있답니다. 언제라도 적어 보길 바래요.\n\n테스트 코드 작성은 처음에는 막막하게 느껴질 수 있지만, 한번 경험해보면 생각보다 접근하기 어렵지 않다는 것을 알게 되었을거라 생각합니다. 순수 함수의 단위 테스트부터 시작해서 점진적으로 복잡한 통합 테스트까지 진행하는 과정에서 자연스럽게 테스트 코드에 대한 감을 익혔기를 바래요.\n\n테스트 코드는 우선 \"나를 대신해서 컴퓨터가 검증하도록 하는 과정\"이라는 것을 이해하는 것입니다. 내가 평소에 기능을 확인하기 위해 브라우저에서 클릭하고 입력하던 그 과정을 코드로 작성하는 것이죠. 이후에는 사용자가 이 기능을 수행할 때 기대하지 않은 동작을 할걸 예상하면서 예외처리등을 보강해가는 것이라 생각하면 조금 더 접근하기 쉬울 거에요. \n\n테스트 코드가 주는 가장 큰 가치는 심리적 안정감입니다. 코드를 수정할 때 \"다른 곳에서 에러가 나지 않을까\" 하는 불안감 없이 마음 놓고 리팩토링을 할 수 있게 되거든요.\n\n다음번에는 과제를 진행하면서 느낀 점들을 회고로 남겨주시면, 더 구체적이고 도움이 되는 피드백을 드릴 수 있을 것 같습니다. 코드를 작성하는 것도 중요하지만, 그 과정에서 무엇을 배웠고 어떤 어려움이 있었는지 돌아보는 것이 성장에 더 큰 도움이 되니까요.\n\n다음주 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/62"
    }
  },
  {
    "passed": false,
    "name": "이정우",
    "feedback": "안녕하세요 정우님! 이번에도 많이 바쁘셨군요 ㅠㅠ\n뜬금없지만 혜성님과 조만간 같이 일하게 된다고 들었어요 ㅎㅎ\n두 분 같이 일하면서 궁금한점 있으면 언제든 저에게 이야기해주세요!\n화이팅입니다!",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/60"
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "\"엄마! 나 테스트코드 알게되고 작성도 해봤어!!\" ㅋㅋ 잘했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물로 친숙해지는데 있었습니다. 회고를 보아하니 잘 수행해준 것 같네요. ㅎ\n\n\"내 인생에 내 손가락으로 직접 친 테스트코드!! 포기하지 않고 과제하는 것만으로도 기술적인 도전이자 해결이었다.\" 훌륭합니다. 그렇게 한번 쳐본 경험으로 앞으로 몰라서 생기는 두려움이나 귀찮음을 많이 극복해지게 되기를 바래요.\n\n나를 대신해서 컴퓨터가 테스트를 하기에는 다양한 방법들이 필요했다는 것을 기억하고 반대로 테스트를 할때 나라면 어떻게 할까를 떠올려보고 이를 컴퓨터라면 어떻게 해야할까 라는 생각들을 반복하다보면 어느새 코딩을 작성할때에도 테스트하기 편하게 작성을 하게 되고 이러한 생각습관의 결과물들이 좋은 코드를 만들어 줄거에요.\n\n수고하셨습니다. 다음 주차는 TDD네요. 화이팅입니다.\n\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/32"
    }
  },
  {
    "passed": true,
    "name": "이지훈",
    "feedback": "안녕하세요 지훈님! 7주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> src/__tests__/medium.integration.spec.tsx 파일에서 'event를 추가 제거하고 저장하는 로직을 잘 살펴보고, 만약 그대로 구현한다면 어떤 문제가 있을 지 고민해보세요.' 라는 주석이 존재하는데, 어떤 문제가 존재할 수 있는지 잘 모르겠습니다. api 호출시 에러를 처리하는 테스트가 존재하지 않는 것을 의미하는 걸까요?\n\n1. 동시성 문제: 비동기 작업 중 상태 변경으로 인한 불일치 가능성\n2. 에러 복구 부족: 실패 시 사용자 데이터 보호 미흡\n3. 중복 요청 미방지: 사용자 액션에 대한 디바운싱 부재\n4. 트랜잭션 부족: 여러 단계 작업의 원자성 보장 미흡\n\n일단 이렇게 4가지 정도라고 생각하는데, 사실 다 퉁쳐서 에러처리라고 묶을 수 있을 것 같아요 ㅎㅎ \"원하는대로 동작하지 않는 경우\"에 대한 내용들이니까요.\n이에 대한걸 테스트로 검증해볼 수 있지 않을까 싶네요!\n\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/39"
    }
  },
  {
    "passed": false,
    "name": "이진희",
    "feedback": "진희님 수고많으셨습니다!\n\n이지를 진행하시고  PR내용은 없는게 맞죵? 지금 금요일에 확인하니 그런 상황입니다.\n\n그래도 일부 노력을 많이 해주신 것 같습니다!\n오프코치님이 솔루션코드 올리시면 코드로 다시 한번 확인하는 시간 가지시면 좋을 것 같습니다!\n\n수고하셨습니다!",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/25"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "수고했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물로 친숙해지는데 있었습니다. 회고를 보아하니 잘 수행해준 것 같아요.\n\n\"단계별로 진행을 하는 방법 때문에 훨씬 접근하기 쉬운 느낌도 들어서 좋았습니다.\" 다행이네요. 과제의 양에 대해서 압박을 느끼는 경우가 많은데 차근 차근 잘 따라와줬네요\n\n\"내가 구현한 기능에 대한 검증이 쉽고 타인에게 검증하기가 쉽겠구나 생각이 들었고 그만큼 중요하다는 것도 알게 되었습니다.\" 맞아요. 테스트 코드는 분명 작성하는데 허들도 있고 에너지가 있지만 또 그만큼의 가치는 만들어주죠. \n\n\nQ) 실제 현업에서의 테스트 전략이 궁금한데 제가 회사에서 다루고 있는 솔루션의 볼륨과 코드 로직을 보여드리면서 어떤 방식으로 테스트를 작성하고 관리 할 수 있는지 물어보면 너무 좋겠는데... PR쓰는 지금 회사 gitLab에 외부망이라 접근이 불가능 하는지 궁금합니다.\n\n=> \"리팩토링이 필요한 부분으로는 테스트 코드의 중복을 줄이고 더 체계적인 구조로 개선할 수 있을 것 같습니다. 현재는 각 테스트 파일이 독립적으로 작성되어 있어서 공통 로직이나 헬퍼 함수들을 더 효율적으로 활용할 수 있을 것 같습니다.\"\n\n=> 우선은 테스트 코드를 테스트의 목적을 벗어나 그냥 한번 작성해보려고 해보세요. 테스트 코드를 작성하기 쉬운 코드는 좋은 코드라는 명제에 따라서 테스트 코드를 만드려고 하는 시도를 하는 과정에서 자연스럽게 리팩토링을 하면 좋을 부분들이 보입니다. 우선 그렇게 조금씩 코드를 개선해 나가보세요. 그렇게 조금씩 테스트 코드를 쌓아 나가는 식으로 해보면 좋습니다.\n\n=> 리팩토링이 어느 정도 진행이 되면서 디버깅을 해야할 때, console.log를 찍어야 한다거나 변경한 기능이나 구현한 기능을 확인하기 위해서 손으로 눈으로 확인을 한다고 느껴지면 한번 테스트 코드로도 만들어 보세요. 우선적으로 해야할 일은 '귀찮다. 어렵다' 하는 심리적 허들을 낮추는 것이니까요. 잘 만든 테스트 코드가 있어야 한다가 아니라 일단 하나라도 만들어 보자 정도로 써먹어 보기를 바래요.\n\n\n\"가장 큰 변화는 개발자로서의 **마인드셋 변화**입니다. 이제는 새로운 기능을 구현할 때 \"이 기능을 어떻게 테스트할 수 있을까?\"라는 생각을 자연스럽게 하게 되었고, 코드의 품질과 안정성에 대한 관심이 높아졌습니다.\" 아주 훌륭한 변화였습니다. 이 마음이 실무까지 이어져 꼭 하나라도 만들어 보면서 관점이 바뀌었다는 것을 스스로 확인해보길 바래요. 수고하셨습니다.\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/21"
    }
  },
  {
    "passed": true,
    "name": "임규원",
    "feedback": "헉 규원님도 회고문서의 내용이 없네요 ㅜㅜ\n사실 체크박스가 중요하긴 한데 코드를 살펴보니 코드를 대부분 작성한 것으로 보입니다.\n그래서 일단 합격으로 드릴게요.\n다음엔 회고문서도 꼭 작성하시면 좋을 것 같아요.\n역랑을 궁극적으로 발전시키는데에는 동작하는 코드도 중요하지만 코드에대한 생각 정리와 과정에 대한 복기인 것 같습니다!",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/51"
    }
  },
  {
    "passed": true,
    "name": "임두현",
    "feedback": "Q. 중간 선언의 정도 전체적인 테스트의 맥락을 담고 싶은 방향과 필요하지 않은 내용을 최소화하고 싶은 방향이 충돌하는 부분이라고 생각합니다. 테스트에서 주가 되는 부분이 아니라면 중간 선언을 최소화하고 한줄에 많은 동작이 이뤄나게 하고 싶습니다. 동시에 드는 우려는, 그럴 경우 테스트를 읽어나갈 때 흐름을 잃을 수 있지 않을까 하는 것입니다.\n\nA. 두현님 의견이 동의합니다~ 사실 저는 해당테스트에서 중요하거나 생략이 가능한 부분은 실제 코드와 다르더라도 생략을 하는 경우가 많습니다.\n예를들어 어떤 함수 5개의 프로퍼티를 인자로 받아서 어떤 결과를 만드는 함수라고 하고,\n이번 테스트에서는 프로퍼티중 2개만 필요한 상황이라면 저는 과감하게 필요한 프로퍼티만 넘기고 as 로 캐스팅해버립니다.\n중간선언은 아니지만 비슷한 맥락이라고 생각해요.\n테스트의 중요한 부분이 더 부각 되서  리더빌리티를 높일 수 있다면 그것이 제일 좋은 것 같습니다.\nexpect(sum(1,2)).toEqual(3) 과 같이 좀더 실제 테스트 코드가 대상 모듈(함수)의 기능과 역할을 최대한 좁은 영역에서 보여주는게 테스트의 의도를 더 잘 표현한다고 생각합니다.\n이 부분이 중요한 것이니까요. \n\n그만큼  리더빌리티는 테스트 대상 모듈 못지 않게 테스트코드에서도 중요합니다.\n그래서 반대로 목데이터가 큰 경우 그것을 이번 테스트에서 의미있는 변수명에 담아 씀으로 리더빌리티를 높일 수도 있을 것 같아요.\n\n리더빌리티의 관점에서 그때 그때마다 옳은 것을 선택하면 좋을 것 같습니다~",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/33"
    }
  },
  {
    "passed": false,
    "name": "장루빈",
    "feedback": "안녕하세요 루빈님!\n아무래도 과제를 진행하기에 시간이 많이 부족하셨나보네요 ㅠㅠ\n시간 되실 때 꼭 한 번 시도해보시면 좋겠어요!!\n남은 기간도 화이팅입니다!!",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/57"
    }
  },
  {
    "passed": false,
    "name": "장희진",
    "feedback": "수고했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다.\n\n회고를 작성하지 않으신 것은 아쉽네요. 테스트 코드를 처음 접하는 분들이 많아서 과제를 진행하면서 어떤 어려움이 있었는지, 어떤 부분에서 성장을 느꼈는지 스스로 적어보면 빠르게 내것이 되는게 있답니다. 언제라도 적어 보길 바래요.\n\n테스트 코드 작성은 처음에는 막막하게 느껴질 수 있지만, 한번 경험해보면 생각보다 접근하기 어렵지 않다는 것을 알게 되었을거라 생각합니다. 순수 함수의 단위 테스트부터 시작해서 점진적으로 복잡한 통합 테스트까지 진행하는 과정에서 자연스럽게 테스트 코드에 대한 감을 익혔기를 바래요.\n\n테스트 코드는 우선 \"나를 대신해서 컴퓨터가 검증하도록 하는 과정\"이라는 것을 이해하는 것입니다. 내가 평소에 기능을 확인하기 위해 브라우저에서 클릭하고 입력하던 그 과정을 코드로 작성하는 것이죠. 이후에는 사용자가 이 기능을 수행할 때 기대하지 않은 동작을 할걸 예상하면서 예외처리등을 보강해가는 것이라 생각하면 조금 더 접근하기 쉬울 거에요. \n\n테스트 코드가 주는 가장 큰 가치는 심리적 안정감입니다. 코드를 수정할 때 \"다른 곳에서 에러가 나지 않을까\" 하는 불안감 없이 마음 놓고 리팩토링을 할 수 있게 되거든요.\n\n다음번에는 과제를 진행하면서 느낀 점들을 회고로 남겨주시면, 더 구체적이고 도움이 되는 피드백을 드릴 수 있을 것 같습니다. 코드를 작성하는 것도 중요하지만, 그 과정에서 무엇을 배웠고 어떤 어려움이 있었는지 돌아보는 것이 성장에 더 큰 도움이 되니까요.\n\n다음주 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/61"
    }
  },
  {
    "passed": false,
    "name": "정건휘",
    "feedback": "아숩게도 테스트가 완전히 통과하지는 못했네요ㅜ\n일단 지금 작성되어 있는 테스트를 보면 작성하시는데 특별하게 엄청 잘못된 패턴은 없는 것 같고 시간이 부족하셨던 것 같네요.\n(중복된 세팅들은 setup, teardown 과정으로 분리하는 연습을 진행해보세요!)\n여유가 있으실 때 꼭 채워주시고 관련해서 학습 진행해주시면 좋겠네요!\n\n화이팅입니다~",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/58"
    }
  },
  {
    "passed": true,
    "name": "정도은",
    "feedback": "수고하셨습니다! 도은님\n\nQ. useNotifications 테스트 코드 작성시 setSystemTime문제\n\nA. 네 설정이후 미세한 시간의 차이가 생길수 있으니 beforeEach보다는 실제 테스트 케이스 즉 it()함수안에서 원하는 시간을 최대한 필요한 위치에서 설정하는 것이 좋을 것 같습니다 :) \n\nQ. shouldAdvanceTime의 역할\n\nA. 제가 예전에 정리한건 shouldAdvanceTime만은 타이머를 한번에 꽝하고 시간을 조절하는 것이 아니라 조금씩 흐르는 것을 시뮬레이션만 해줄뿐\n온전하게 시간이 흐르고 타이머의 콜백들이 온전하게 실행되게 하려면 시간을 쭈욱 밀어주는 작업이 필요하다로 정리했어요. 그게  vi.advanceTimersByTimeAsync()죠. 즉 shouldAdvanceTime 설정은 그냥 타이며 시간이 흐름에 관한 이야기고 온전히 시간히 흐른것을 보장해 모든 콜백을 실행하는 것은 별개의 이야기 인것이죠.\n\nQ. 통합 테스트에서 타임존 이슈\n\nA. 음 이건 서버에서 이슈가 발생했다는 뜻인가요?  음 이상하네욥 타임존 이슈는 보통 없었는데요 뭔가 시스템 설정의 타임존이 달라서 이지 않을까요?\n\nQ. 시간 관련한 테스트 코드가 제일 이슈가 많았습니다. 타이머 관련 테스트를 작성할때 팁\n\nA.  아마 처음이었기 때문에 적응하기 힘들었지 않았나 싶어요. 사실 vitest와 같은 테스트러너가 제공하는 api 셋이 그렇게 많지 않기 때문에 제생각에는\n이번에 한번 익숙해지시면 다음부터는 크게 어렵지 않을 것 같아요. 관련해서 마우스 드래그 같은 테스트도 처음에는 어떻게 하라는건지 난감한데요. 몇번 시행착오를 겪고 나면 별것 아니게 됩니다. :) 사실 저도 어떤 유형의 테스트를 오랜만에 하면 한동안 해매요 ㅎㅎ",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/22"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "정민기",
    "feedback": "Q. 멘토님은 테스트 코드를 먼저 작성해두시고 그 다음에 리팩토링을 진행하시나요? 아니면 리팩토링을 하면서 테스트코드를 같이 작성하시나요.?\n테스트 코드를 먼저 작성안하고 그냥 함수 구현을 먼저하고 테스트 코드를 작성하니까 뭔가 리팩토링이 잘안되는거같아서 질문드립니다.\n\nA. 함수단위의 모듈이라면 보통 테스트 코드를 먼저 작성합니다. 심화과제는 이미 구현된 것을 별도의 모듈로 분리하는 것이 주인데요.\n일단 해당 컴포넌트 혹은 훅이 해야하는 역할을 테스트케이스에 디스크립션으로 미리 만들어두고,\n아주 기본적인 것부터 하나씩 테스트케이스르 먼저 만들고 구현코드를 만들어 나갈 것 같습니다.\n그리고 해당 모듈의 기능을 모두 만들었다면 기존코드에 해당 모듈을 사용하는 형태로 하나씩 분리해나갈 것 같아요.\n일단 테스트 코드는 모듈간의 관계수준의 설계를 돕진 않아요.(인터페이스의 설계는 돕습니다)\n뭐를 분리할지에 대해서는 테스트 코드와 상관없이 그루핑 되는 역할의 단위를 기준으로 미리 계획을 하고\n그 분리되는 모듈의 역할을 정의한대로 테스트케이스와 함게 모듈을 개발하는 것이죵.\n\n테스트코드를 작성해야 리펙토링이라는 것을 제대로 할 수 잇을 것 같아요.\n리펙토링의 정의가 인터페이스 유지한채 성능을 개선하거나 코드 품질을 높이는 것이 잖아요.\n내가 수정하는 것들이 기존의 모듈의 기능에 부정적인 영햘울 주고 있는지 아닌지를 자동으로 확인해주는 것이 테스트 코드입니다.\n아무튼 테스트 케이스만 통과하면 기존의 기능은 모두 제대로 동작한다고 신뢰를 주는 것이죵.\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "http://github.com/hanghae-plus/front_6th_chapter3-1/pull/17"
    }
  },
  {
    "passed": true,
    "name": "정유열",
    "feedback": "안녕하세요 유열님! 7주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨씁니다!\nMSW에 대해 깊은 고찰(?)을 해보셨군요 ㅋㅋㅋ 이렇게 하나씩 알아가는거죠!\n\n> AI 사용을 지양하라고 하셨지만, 그러지 못했습니다. 코파일럿이 궁금하지 않아도 자꾸 힌트를 주었고, 과제 분량이 많다보니 테스트 코드를 작성해본 경험이 없어 더더욱 시간이 촉박해지면서 AI에 의존하는 비중이 점점 커졌습니다. 심화 파트를 할 시점에는 이미 내가 AI를 조종하는 것이 아니라, AI가 나를 조종하고 있는 상황이 펼쳐진 것 같은 아이러니한 상황이 펼쳐졌습니다. 그래도 중요한것은 테스트의 흐름을 이해하고 AI를 통해 올바른 테스트를 작성하기 위해 집중했다는 점입니다.\n\n사실 AI의 등장 이후에 개발자들이 제일 큰 도움을 받는 영역이 테스트라고 생각해요. 떼어내고 싶으도 떼어내기가 힘든 구간이죠 ㅎㅎ 잘 써보는것도 좋은 시도라고 생각합니다!\n\n> MSW handlers와 handlersUtils의 역할을 잘 분리한건지 잘 모르겠습니다. handlers에서 저처럼 성공케이스만 처리하는게 아니라 api의 에러케이스를 모두 다루는게 맞는건지, 그게 맞다면 handlersUtils의 에러케이스와 중복이 되는데 원래 그게 맞는것인지 궁금합니다.\n\n기본적으로 성공케이스를 반환하도록 하고, handlerUtils를 통해 특정 상황에서 오류 케이스에 대한 처리가 필요하다면 이를 만들어서 사용하는거죠 ㅎㅎ 잘 진행해주셨습니다!\n\n아 그리고 테스트 데이터를 독립적으로 사용할 때에도 이용해볼 수 있을 것 같아요. 기본 설정으로 만들어놓은 테스트 데이터를 사용하는게 아닌 특적 테스트에서만 필요한 데이터를 만들어서 handlerUtils에 넘겨준 다음 이를 사용하도록 하는거죠.\n\n> 테스트를 작성하다보니 단위테스트에서 이미 검증한 로직을 통합테스트에서 다시 검증하게 되는 경우가 있었습니다. 테스트를 단위테스트와 통합테스트 모두에 작성하게 될 경우 기능 수정 시 여러 곳을 동시에 수정해야 하는 유지보수 부담을 만들지 않을까 라는 생각이 듭니다. 그냥 일차원적으로 생각해보면\n단위테스트: 비즈니스 로직의 상세한 검증 / 통합테스트: 전체 흐름과 컴포넌트 간 상호작용 검증 (비즈니스 로직은 더이상 검증하지 않음) 이런 식으로 분리하면 되지않나? 라는 생각이 들지만 실무에서는 중복을 감수하면서도 안전한 테스트를 만드는 경우가 있는지 궁금합니다.\n\n말씀해주신 것 처럼 진행해주셔도 좋을 것 같아요! 그치만 중복을 없애려는 노력이 중복을 허용하고 유지보수하는 노력이 더 저렴할 때도 많답니다 ㅋㅋ\n저는 테스트가 결국 \"문제를 빠르게 발견하기 위한 수단\"이라고 생각해요. 이에 대한 조건만 잘 충족할 수 있다면 어떤 방식이든 크게 중요하지 않다는 입장입니다.\n\n> 케이스에따라 차이가 클 지 모르겠지만, 작은 규모의 서비스를 운영하는 스타트업의 경우 테스트가 전혀 없는 기존 프로젝트에 테스트를 도입할 때, 리소스가 제한된 상황에서 '최소한 이것만은 테스트하는 것을 권장한다'는 기준이 있을까요? 또는 도입을 추천하는지 아닌지도 궁금합니다.\n\n적어도 여기저기서 많이 참조하고 많이 쓰이는 유틸함수에 대해서는 테스트를 작성하면 좋답니다 ㅎㅎ 라이브러리 성격을 가지고 있는 것들이요!\n가령 우리는 리액트를 사용하고 있는데, 리액트라는 라이브러리를 의존하는 프로젝트가 많기 때문에 변화의 여파가 굉장히 커요. 이런 경우에는 테스트가 필수겠죠?\n\n마찬가지로 디자인 시스템 내부에서 쓰이는 UI 인터랙션 로직에 대해서도 테스트가 필요할 수 있고... 그렇습니다.\n그리고 자주 변경되는 로직에 대해서는 테스트를 작성하는게 부담이 될 수 있어요. 유지보수해야할게 많아지고 변경이 자주 발생하기 때문에 테스트를 작성해봤자 큰 의미가 없을 수 있달까..!?\n\n그리고 사실 이제 AI가 있어서 테스트 작성 비용이 굉장히 저렴해졌어요. 백그라운드로 돌려도 되고, playwright mcp 같은게 있어서 문장으로 정의된 요구사항 혹은 스펙을 토대로 e2e 테스트를 만들 수 있답니다!\n결론은... 이런 시대에 테스트를 작성하지 않는건 큰 손해라고 생각해요 ㅋㅋ\n가성비 + 효과가 제일 좋은 도구가 되지 않았나!? 라는 입장입니다.\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/12"
    }
  },
  {
    "passed": true,
    "name": "조영민",
    "feedback": "수고했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다.\n\n회고를 작성하지 않으신 것은 아쉽네요. 테스트 코드를 처음 접하는 분들이 많아서 과제를 진행하면서 어떤 어려움이 있었는지, 어떤 부분에서 성장을 느꼈는지 스스로 적어보면 빠르게 내것이 되는게 있답니다. 언제라도 적어 보길 바래요.\n\n테스트 코드 작성은 처음에는 막막하게 느껴질 수 있지만, 한번 경험해보면 생각보다 접근하기 어렵지 않다는 것을 알게 되었을거라 생각합니다. 순수 함수의 단위 테스트부터 시작해서 점진적으로 복잡한 통합 테스트까지 진행하는 과정에서 자연스럽게 테스트 코드에 대한 감을 익혔기를 바래요.\n\n테스트 코드는 우선 \"나를 대신해서 컴퓨터가 검증하도록 하는 과정\"이라는 것을 이해하는 것입니다. 내가 평소에 기능을 확인하기 위해 브라우저에서 클릭하고 입력하던 그 과정을 코드로 작성하는 것이죠. 이후에는 사용자가 이 기능을 수행할 때 기대하지 않은 동작을 할걸 예상하면서 예외처리등을 보강해가는 것이라 생각하면 조금 더 접근하기 쉬울 거에요. \n\n테스트 코드가 주는 가장 큰 가치는 심리적 안정감입니다. 코드를 수정할 때 \"다른 곳에서 에러가 나지 않을까\" 하는 불안감 없이 마음 놓고 리팩토링을 할 수 있게 되거든요.\n\n다음번에는 과제를 진행하면서 느낀 점들을 회고로 남겨주시면, 더 구체적이고 도움이 되는 피드백을 드릴 수 있을 것 같습니다. 코드를 작성하는 것도 중요하지만, 그 과정에서 무엇을 배웠고 어떤 어려움이 있었는지 돌아보는 것이 성장에 더 큰 도움이 되니까요.\n\n다음주 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/31"
    }
  },
  {
    "passed": true,
    "name": "주산들",
    "feedback": "수고했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. 회고를 보아하니 잘 수행해준 것 같아요.\n\n\"과제를 처음 시작할 때 테스트 코드 자체를 아예 처음 해보는 거라 내가 과제를 잘 수행 할 수 있을지 걱정이 많이 되었다. 그런데 막상 해보니까 생각보다 문법이 간단했고 아 뭐야! 괜히 쫄았네!!\" ㅋㅋ 좋은 반응이네요. 실제로 테스트 코드는 생각보다 진입장벽이 높지 않아요. 한번 해보면 \"아 이런 거구나\" 싶죠.\n\n\"밀린 숙제 끝낸 느낌이고... 일단은 앞으로 개발하면서 '테스트 코드를 도입해 볼까?' 라는 생각이 쉽게 들 것 같아서 좋다. 심리적 진입장벽이 많이 낮아졌다...\" 너무 좋습니다. 무엇보다 심리적 진입장벽이 많이 낮아졌다는 말이 참 좋네요. 이게 이번 과제의 가장 큰 목표였어요. 테스트 코드에 대한 막연한 두려움을 없애는 것!! 이제는 마지막 퍼즐조각인 실무에서도 어떻게든 하나 만들어 보는 것 까지 자연스럽게 시도해볼 수 있을 거예요.\n\n\"나중에는 테스트 코드가 없이 리팩토링을 할 때 불편함을 느낄 수도 있을 것 같았다\" 정확한 인사이트네요. 테스트 코드가 있는 상태에서 리팩토링을 경험해보면, 없을 때의 불안감을 더 크게 느끼게 되죠.\n\n\"최대한 공정한...? 코드를 작성하려고 노력했다. 막 어떻게든 테스트를 통과시키기 위해 기상천외한 방식으로 테스트를 작성하는 것은 최대한 지양하고자 하였고....\" 좋습니다. 공정한이라는 표현이 재밌네요. 테스트 코드는 나를 대신해서 사용자를 대신해서 하는 것인만큼 \n\nQ) 테스트 코드는 다다익선인가요! 테스트 코드가 많을 경우 생길 수 있는 단점이 있나요?\n\n=> 좋은 질문입니다. 당연히 코드는 많을 수록 좋겠죠? 가 아니라 테스트 코드도 결국 코드이기 때문에 유지보수 비용이 발생했습니다. 코드는 자산이 아니라 부채니까요. 우리가 담보 대출을 받아 집을 사고 이자를 내는 건 그 편이 더 큰 가치를 만들어 내기 때문이죠. 그러나 실제 가치를 얻기도 전에 이자에 허덕인다면 좋을 수 없습니다. 주담대도 땡길 수 있을때 많이 땡기는게 좋지만 감당할 수 있느냐가 중요하다고 생각해요.\n\n=> 테스트 코드는 그 특성상 요구사항이 변경되면 그에 맞게 테스트 코드를 수정해야 되요. 테스트 코드가 아주 세세하게 많다면 그 변화에 맞게 코드 수정까지 해야 되죠. 그리고 테스트 실행시간이 길다면 매번 코드 변경시 테스트 코드를 실행하게 되고 이게 늘어진다면 되려 속도가 느려질 수 있습니다. 그리고 테스트 코드는 꽤나 중요한 기준이 되어 주는데 테스트 코드가 틀리게 될 경우 검증을 하는게 어려워질 수 있습니다.\n\n=> 사실 이런걸 재다보면서 테스트 코드를 만들면 결국 하지 말자는 식의 결론이 내려질 가능성이 크기 때문에 일단 만들어보고 판단해도 늦지 않아요. 만들다보면 필요없는 테스트, 필요한 테스트들이 보이게 됩니다. 물론 그 규모가 커지게 되고 관리하던 누군가가 손을 떼는 순간 그 부작용을 경험하게 되겠지만 그건 그때가서 생각해보기로 하고 일단 만들어 보기로 해요! 거기까지 도착해보는 것만으로도 크게 성장할테니까요\n\n이번 경험으로 테스트에 대한 두려움이 사라진 만큼, 실무에서도 꼭 한번씩 시도해보면서 그 가치를 계속 확인해보길 바라요. 다음 과제도 화이팅입니다\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/5"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "최용훈",
    "feedback": "고생하셨어요!\n이제 테스트 작성에 어느정도 익숙해지신 것 같네요 :+1\n필요하신 내용들도 잘 정리해주셨네요.\n따로 리뷰 요청 주신 부분은 없어서 코드를 가볍게 살펴보면, 전반적으로 코드를 잘 작성해주셨습니다.\n추가로 제가 구성해뒀던 핸들러나 Setup 등 환경들 살펴보시고 하드도 꼭 도전해보시면 좋겠네요. \n\n고생하셨습니다. 다음 주 화이팅입니다.",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/46"
    }
  },
  {
    "passed": true,
    "name": "최재환",
    "feedback": "재환님 수고하셨습니다!\n\nQ. 컴포넌트와 훅을 분리한 다음에 각 계층별로 어떤 테스트 전략을 가져가게 좋을지 궁금합니다. 현재는 아래와 같이 생각하고 있습니다.\n* components: testing-library를 이용한 렌더링 및 상호작용 단위 테스트\n* hooks: renderHook을 이용한 단위 테스트\n* App.tsx: 전체 시나리오를 검증하는 통합 테스트\n\nA. 오 일반적으로 생각할 수 있는 좋은 전략인 것 같습니다!\n이프로젝트가 아니라 좀 더 큰 프로젝트라면 중겐 Page라는 레이어를 두고 통합테스트를 진행할 수 있을 것 같아요.\n그럴때는 App에 대한 통합테스트는 필요 없겠죠?\n테스트 전략에 대해 물어보시다니 오 :) 멋쟁이..\n사실 테스트 전략에서 중요한 것은 뭐를 어떻게 테스트할까보다도\n레이어를 어떻게 나누었느냐인 것 같아요.\n테스트야 뭐 빤하잖아요 단위,통합, E2E\n\n테스트를 할지 말지 결정하는 것도 전략이에요.\n\n예를들면 테스트가 불가능한 레이어는 분리해서 테스트 가능한 영역과 테스트 불가능한 영역으로 나눌 수 있는 지를 고민하는 것이죠.\n그래서 그렇게 분리된 테스트 불가능한 레이어는 최대한 얇게 유지하고 테스트를 그냥 포기하는 것도 좋은 전략이 될 수 있어요.\n보통 사이드 이펙트를 만드는 레이어죠.\n\n수고하셨습니다!\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/6"
    }
  },
  {
    "passed": true,
    "name": "한아름",
    "feedback": "수고했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. 회고를 보아하니 잘 수행해준 것 같아요. 잘했습니다!\n\n\"정말 색다른 경험이었다... 지금까지 테스트 코드를 실행만 해봤기 때문에 너무 막막하게 느껴졌지만 직접 테스트 코드를 작성해보면서 점점 익숙해지고...\" 좋은 변화입니다. 특히나 테스트 코드를 작성하지 못하는 경우가 어렵다기 보다는 그 막막한 느낌 때문에 더더욱 섣불리 하지 못하는데 다행히 이번 과제를 통해서 익숙해졌다니 좋네요. 꼭 그 마지막 벽인 실무에서 한번의 시도를 막막함을 넘어보기를 바래요!\n\n\"테스트 코드를 경험해본 사람이 많지 않은 것 같아서 실제 현업에서의 우선순위나 활용 빈도가 뭔가 멀게 느껴지기도 했고...\" 맞아요. 실제로 현업에서 테스트 코드 도입률이 높지는 않습니다. 테스크 코드를 작성하는데 들어가는 비용이 적지 않다보니 대개 많이 하지 못하는 실정이지요. 그러다 보면 테스트 코드 도입이 필요한 시점이 와도 관성 때문에 진행하지 못하게 되요. 더군더나 막막함이라는 느낌 때문에 하면 좋겠다 정도로만 생각하고 시도하지 않는 경우도 많구요. 그렇기에 할 수 있다는 것이 더 경쟁력이 될 수 있는 부분이기도 해요. 이런 경험을 해본 것 자체가 큰 자산이 될거에요!\n\n\"...리팩토링을 진행하면서 직접 작성한 테스트 코드로 변경 사항을 검증해보니, 테스트가 주는 안정성과 신뢰성을 실감할 수 있었다\" 아주 좋네요! 좋습니다.\n\nQ) setupMockHandlerUpdating 내에 존재하지 않는 이벤트를 처리할 시 에러를 반환하는 로직이 없어서 존재하지 않는 이벤트 수정 테스트를 위해 HttpResponse.error()를 반환하도록 추가해두었는데, 혹시 의도된 부분인지 궁금합니다.\n\n=> 아주 좋은 발견이고 적절한 처리였습니다. 실제 API에서는 존재하지 않는 리소스에 대한 요청 시 404나 다른 에러를 반환하는 게 정상이니까요. 테스트 코드도 다른 코드처럼 일단 만들면 버그를 만나고 수정하고 점점 보강해가면서 점점 더 안정적인 코드가 되어 갑니다. 그렇게 추가되다보면 더 현실적인 시나리오에 가까운 테스트 코드가 될거에요.\n\n이번 경험이 현업에서도 이어져서 꼭 하나라도 만들어보면서 그 가치를 지속적으로 확인해보길 바라요. 테스트 코드 경험자가 많지 않다고 하셨는데, 그래서 더 귀한 경험을 쌓은 거라고 생각합니다. 다음 과제도 화이팅입니다!\n\n",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/50"
    }
  },
  {
    "passed": false,
    "name": "허정석",
    "feedback": "안녕하세요 정석님! \n이번에는 아무래도 난이도가 좀 있고 AI 디톡스 때문에 진행하기가 어려웠구나 싶네요 ㅠㅠ\n다음 과제는 잘 진행할 수 있기를 바랍니다!! 화이팅입니다!!\n\n---\n\n> 테스트는 정적인 데이터를 활용하는게 좋다고 들었습니다. 하드코딩된 테스트 데이터를 별도 파일로 분리하는 것이 유지보수에 도움이 될지 궁금합니다.\n\n그럼요! 저희 팀에서는 그렇게 작업해놓은 상태입니다 ㅎㅎ 처음에는 각 테스트 파일에 테스트 데이터를 만들어놨었는데 테스트 케이스가 5000개 정도 넘어가니까... 유지보수하는게 너무 힘들었어요..!\n\n그래서 팀원들이랑 다같이 날잡아서 한 번에 고쳤답니다!\n\n테스트 데이터를 한 번에 모아놓고, 각 테스트에 필요한 테스트 데이터는 해당 파일에 정의하는 방식으로 만들어가는 중입니다.\n\n> beforeEach와 afterEach를 사용해서 테스트 상태를 초기화하는 것이 최선인지 궁금합니다. 또한 코치님이 사용하시는 방법이 있는지도 궁금합니다.\n\n이거 말고 다른 방법이 있을까..? 라는 생각이 들어요 ㅎㅎ 공식가이드에 가까워서..\n\n아니면 각 테스트마다 고차 함수로 랩핑해서 사용할 수 있을 것 같아요.\n\n가령..\n\ntest('테스트입니다', withInit(() => {\n // 테스트 작성  \n}))\n\n요로코롬...",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/26"
    }
  },
  {
    "passed": true,
    "name": "현지수",
    "feedback": "안녕하세요 지수님! 7주차 과제 잘 진행해주셨네요!! 고생하셨습니다 ㅎㅎ\n\n> 현재 테스트 독립성을 위해 setupMockHandlerCreation, setupMockHandlerUpdating, setupMockHandlerDeletion으로 목적별 핸들러를 분리했습니다. 이런 목적별 분리 접근법이 MSW 모범 사례에 부합하는지 검토해주실 수 있나요? 대안으로 하나의 통합 핸들러에서 테스트 ID별로 데이터를 격리하는 방법도 고려해볼 만한지 의견을 듣고 싶습니다.\n\n잘 해주셨다고 생각해요! 다만 모범사례가 무엇일까... 에 대한 고민이 있네요 ㅋㅋ 사실 제가 팀에서 MSW를 많이 쓰진 않고 있다보니..\n그래도 똑같은 상황이 벌어진다고 했을 때 지수님께서 만들어주신 것 처럼 만들 것 같아요 ㅎㅎ\n\n> 하드코딩된 대기 시간의 적절성과 대안\n\n아마 Promise를 통해 wait을 하지 않아도 정상동작 할 것 같아요 ㅎㅎ waitFor이 비슷하게 동작해서요.\n대신 기다리는 시간이 더 필요하다면 waitFor의 옵션을 추가하면 된답니다!\n\nhttps://testing-library.com/docs/dom-testing-library/api-async/#waitfor\n\n```tsx\nfunction waitFor<T>(\n  callback: () => T | Promise<T>,\n  options?: {\n    container?: HTMLElement\n    timeout?: number\n    interval?: number\n    onTimeout?: (error: Error) => Error\n    mutationObserverOptions?: MutationObserverInit\n  },\n): Promise<T>\n```\n\ntimeout을 설정해주면 되어요!",
    "assignment": {
      "name": "STEP14 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-1/pull/63"
    }
  },
  {
    "passed": false,
    "name": "강병준",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/5"
    }
  },
  {
    "passed": true,
    "name": "권지호",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/3"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/28"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "http://github.com/hanghae-plus/front_6th_chapter3-2/pull/45"
    }
  },
  {
    "passed": true,
    "name": "김소희",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/37"
    }
  },
  {
    "passed": false,
    "name": "김수민",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김수현",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/17"
    }
  },
  {
    "passed": false,
    "name": "김연수",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김유현",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/10"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/40"
    }
  },
  {
    "passed": false,
    "name": "김효진",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/15"
    }
  },
  {
    "passed": false,
    "name": "김휘린",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/35"
    }
  },
  {
    "passed": false,
    "name": "박상수",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/46"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/32"
    }
  },
  {
    "passed": false,
    "name": "박의근",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "박준형",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/24"
    }
  },
  {
    "passed": true,
    "name": "박창준",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/26"
    }
  },
  {
    "passed": true,
    "name": "신홍준",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/1"
    }
  },
  {
    "passed": false,
    "name": "신희원",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/16"
    }
  },
  {
    "passed": true,
    "name": "양성진",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/31"
    }
  },
  {
    "passed": false,
    "name": "양창훈",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/36"
    }
  },
  {
    "passed": false,
    "name": "여진석",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/14"
    }
  },
  {
    "passed": true,
    "name": "오하늘",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/44"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/12"
    }
  },
  {
    "passed": true,
    "name": "윤영서",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/7"
    }
  },
  {
    "passed": false,
    "name": "이가은",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/20"
    }
  },
  {
    "passed": true,
    "name": "이민재",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/29"
    }
  },
  {
    "passed": false,
    "name": "이유진",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/43"
    }
  },
  {
    "passed": false,
    "name": "이은지",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/42"
    }
  },
  {
    "passed": false,
    "name": "이의찬",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/30"
    }
  },
  {
    "passed": false,
    "name": "이정우",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/8"
    }
  },
  {
    "passed": true,
    "name": "이지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/22"
    }
  },
  {
    "passed": true,
    "name": "이진희",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/38"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/19"
    }
  },
  {
    "passed": false,
    "name": "임규원",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/41"
    }
  },
  {
    "passed": true,
    "name": "임두현",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/25"
    }
  },
  {
    "passed": false,
    "name": "장루빈",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "장희진",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/18"
    }
  },
  {
    "passed": false,
    "name": "정건휘",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/39"
    }
  },
  {
    "passed": true,
    "name": "정도은",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/11"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "정민기",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/9"
    }
  },
  {
    "passed": true,
    "name": "정유열",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/27"
    }
  },
  {
    "passed": true,
    "name": "조영민",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/23"
    }
  },
  {
    "passed": true,
    "name": "주산들",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/13"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "최용훈",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/4"
    }
  },
  {
    "passed": false,
    "name": "최재환",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "한아름",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/33"
    }
  },
  {
    "passed": false,
    "name": "허정석",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/21"
    }
  },
  {
    "passed": true,
    "name": "현지수",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 테스트 코드 기본과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/34"
    }
  },
  {
    "passed": false,
    "name": "강병준",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/5"
    }
  },
  {
    "passed": true,
    "name": "권지호",
    "feedback": "지호님 수고하셨습니다. ㅎㅎ\n이번에도 논문 잘 읽었습니다  :)\n\nQ1. 팀 과제에 지난 멘토링 시간에 조언해주셨던 부분을 적극적으로 적용해보고자 했습니다. 저희가 적절하게 잘 적용한게 맞을까요? 아쉬운 부분이 있다면 어떤 부분일까요?\n\nA. 와. 솔직히 이렇게까지 잘 이해하고 전략을 만들어주실지는 몰랐어요. 흠 너무 잘하셨어요\n\n특히 \n\n[“어떻게 하면 코드를 테스트하기 좋은 구조로 만들까” 라는 질문에 집중했습니다.]\n\n위 부분에서는 감동을 받았어요.. ㅎㅎ\n\n실제 실무였다면 여기에 각 레이어별로 테스트 코드를 일반화해서 주석코드와 함께 템플릿겪의 예제를 추가해달라고 요청했을 것 같아요. \n\n모든 것을 일관성있게 할 수 없지만 조금 더 테스트의 일관성을 맞춰서 리더빌리티를 높일 수 있어요.\n예를들어 testing-library를 활용하더라도 테스트 방식은 사람마다 다를 수 있거든요 ㅎㅎ\n그리고 예제를 만들다보면 또 논의해야 할 것들이 생겨나기도하고요~\n\n\nQ2. TDD에서 기능의 범위를 미리 예측하고 코드를 작성하는 것이 아직은 추상적이게 느껴집니다. 코치님이 일하고 계신 실무에서는 테스트 코드나 TDD를 어떤 방식으로 활용하고 계신지, 라이브러리나 컨벤션, 프로세스와 같이 실무에서의 실용적인 적용사례에 대해 궁금합니다\n\nA. 사실 모듈의 기능을 미리 예측해서 테스트 코드를 작성하는 방법은 없습니다~\n\n이미 요구사항은 코딩을 하기 전에 있어야하고\n해당 요구사항을 구현하기 위해 추가되어야할 모듈의 기능들을 테스트케이스에 하나씩 넣어가면서 테스트를 만드는 것이죵.\n\n개발자가 모르는 것은 테스트할 수 없어요. 개발자가 아는 것만 테스트할 수 있습니다.\n\n그렇기 때문에 의도치 않은 버그들이 테스트만 작성한다고 발생하지 않는 것이 아니에요. 물론 얻어 걸리는 경우는 있지요. 리팩토링과정에서 깨지는 것은 지금의 수정이 모듈의 기존 스펙을 해치지 않는지를 확인하는 것입니다. \n\n그래서 테스트는 어플리케이션이나 특정 과제의 구조를 “만들때는” 도움이 안되요. 미리 만들어진 구조를 테스트하기 좋게 만들기 위해 구조를 좀 더 유연한 구조로 개선될 수 있지만 말이죠.\n테스트 퍼스트에서 자주 햇갈리는 부분입니다.\n크던 작던 아무튼 아키텍처는 테스트 보다 선행되어야합니다.\n\n그리고 테스트는 요구사항에 맞게 구조는 미리 설계한다음 테스트를 통해 해당 구조가 서로 원할하게 맞물리게 하기위해, 사용자 관점에서 인터페이스를 설계하기 좋게 해줍니다. :)",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/25/files"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "민지님 수고하셨습니다~\n\n이번 과제는 민지님이 많이 힘드셨나봅니다 :)\n아직은 흥미가 없고 조금 어렵더라도 말씀하신대로,\n유틸함수등의 일부 테스트가 수월하다고 느껴지는 부분부터 실무에서 적용을 해보시면 어떨까 싶어.\n그러시면서 차츰 늘려가시면 좋을 것 같습니다.\n\n수고하셨습니다.",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/28"
    }
  },
  {
    "passed": true,
    "name": "김상수",
    "feedback": "수고하셨습니다 상수님!\n\n다음엔 회고문서도 꼭 작성하시면 좋을 것 같아요.\n역랑을 궁극적으로 발전시키는데에는 동작하는 코드도 중요하지만 코드에대한 생각 정리와 과정에 대한 복기인 것 같습니다!\n",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "http://github.com/hanghae-plus/front_6th_chapter3-2/pull/45"
    }
  },
  {
    "passed": true,
    "name": "김소희",
    "feedback": "> 테스트의 경계: recurringEvents.ts 같은 유틸리티 함수에 대해 꼼꼼한 단위 테스트를 작성했습니다. 이 함수를 사용하는 useEventOperations 같은 커스텀 훅을 테스트할 때도, 이 유틸리티 함수의 모든 엣지 케이스를 다시 테스트해야 할까요? 아니면 훅 레벨에서는 유틸 함수는 이미 검증되었으니, 훅이 유틸 함수를 올바르게 호출하는지만! 테스트하는 것이 더 효율적인지 조언을 듣고 싶습니다.\n\n저는 이럴 때 그냥 훅에서도 검증하는 편인데요, \"무엇을 테스트 해야 좋을까?\"에 대해 판단하는 시간보다 그냥 테스트를 작성하는게 더 빠르다고 느꼈기 때문이랍니다 ㅎㅎ 이걸 선별하는것도 무척... 귀찮고 어려워요.\n물론 이론상 유틸에 대해 검증하는 부분을 훅에서 하지 않아도 무방하죠. 그런데 이걸 구분하는게 쉽냐는 다른 문제라서요! 그냥 해버려~ 가 저의 기조입니다.\n\n> E2E 테스트의 독립성: 현재 작성한 E2E 테스트의 CRUD 시나리오는 생성 테스트가 성공해야 수정 테스트가 이어서 실행될 수 있는 의존적인 구조입니다. 각 테스트가 서로에게 영향을 주지 않도록 완벽하게 독립적으로 만드려면, beforeEach에서 cy.request()를 사용해 매번 테스트에 필요한 데이터를 직접 생성하고 시작해야 하거나 인터셉트 처리로 api를 모킹해야 하는 것으로 공부했습니다. 하지만 그렇게 되면 실제 api 테스트가 되지 않아서 E2E 테스트의 의미가 흐려진다고 느껴집니다. 반면에 실제 데이터를 테스트 용도로 조작하는 것이 위험하게 느껴지기도 합니다. 보통 실무에서 사용하는 일반적인 패턴은 어떤 것인지 궁금합니다!\n\n이건 팀 내에서 어떻게 합의하냐에 따라 다르다고 생각해요 ㅎㅎ 가령 CRUD를 하나의 테스트 스펙에서 진행할 수도 있답니다! 혹은 테스트 자체를 함수로 만들어서 진행한다거나!?\n\n```tsx\ndescribe('CURD 테스트', () => {\n\t생성테스트검증 = () => {}\n\t수정테스트검증 = () => {}\n\t읽기테스트검증 = () => {}\n\t삭제테스트검증 = () => {}\n\n\ttest('생성 테스트', () => {\n\t\t생성테스트검증();\n\t})\n\n\ttest('수정 테스트', () => {\n\t\t생성테스트검증();\n\t\t수정테스트검증();\n\t})\n})\n```\n\n요로코롬...\n\n\n여튼 중요한건 팀에서 어떤 전략을 토대로 테스트를 진행하냐에 따라 다르다는 점이랍니다!\n저는 테스트에서 제일 중요한게 결국 \"사이드 이펙트(문제)를 찾아내는 것\" 이라고 생각하고, 이를 찾아낼 수 있다면 뭐든 좋다고 생각해요!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/37"
    }
  },
  {
    "passed": false,
    "name": "김수민",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김수현",
    "feedback": "안녕하세요 수현님! 8주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 태영님이 젭에서 “이렇게까지 오래 걸릴 일이 아닌데” 라고 말씀하셨을 때, 저도 되돌아보니 정말 그랬던 것 같다는 생각이 들었습니다.\n\n고민을 많이 해보는건 좋다고 생각해요! 이런 과정이 있었기 때문에 다음에 시도할 때는 더 빠르게 진행할 수 있으리라 생각해요!\n\n> 확실히 테스트 코드에 대한 재미가 붙었습니다. :)\n\n제일 큰 수확이네요!! 사실 테스트에 대한 의미와 이를 해야겠다는 의지가 무엇보다 중요하다고 생각해요. 그래야 진행할 수 있으니까요!\n\n>  editing일 때에도 repeat처리를 해줘야 수정할 때 반복 일정처리가 가능할까요?\n\n현재 API에서는 기능을 제공하고 있지 않네요 ㅠㅠ \n현재 과제의 구조를 보면.. 프론트에서 처리를 해야할 것 같아요 ㅋㅋ 사용자가 \"전체 반복 일정 수정\" 항목을 체크해서 수정한다면 전체 일정이 수정되도록 payload를 만들어서 전송해야겠죠!?\n\n지금 보니까\n\n```tsx\napp.put('/api/events-list', async (req, res) => {\n  const events = await getEvents();\n  let isUpdated = false;\n\n  const newEvents = [...events.events];\n  req.body.events.forEach((event) => {\n    const eventIndex = events.events.findIndex((target) => target.id === event.id);\n    if (eventIndex > -1) {\n      isUpdated = true;\n      newEvents[eventIndex] = { ...events.events[eventIndex], ...event };\n    }\n  });\n\n  if (isUpdated) {\n    fs.writeFileSync(\n      `${__dirname}/src/__mocks__/response/realEvents.json`,\n      JSON.stringify({\n        events: newEvents,\n      })\n    );\n\n    res.json(events.events);\n  } else {\n    res.status(404).send('Event not found');\n  }\n});\n```\n\n이 API를 사용해야 할 것 같네요 ㅎㅎ\n수정할 이벤트 목록을 한 번에 전송해야하는 구조랍니다.\n",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/17"
    }
  },
  {
    "passed": false,
    "name": "김연수",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "김유현",
    "feedback": "고생하셨습니다 유현님!\n근데 ㅠㅠ 제가 전에 여러번 말씀드린것처럼 e2e 테스트나 시각적 회귀 테스트 작성에 경험을 해보셨으면 하는 맥락이기 때문에 해당 테스트를 3개 이상 작성해달라고 말씀을 드렸던거라서요.. 새로 추가된 통합 테스트도 좋은 맥락에서 추가된 테스트이지만 심화 통과 기준에 해당이 되지는 않는 것 같습니다.\n\n나머지 기능에 대한 구현이나 작성된 코드들은 좋았습니다. 필요한 설정들도 잘 추가되어있구요. 대신 timeout이 필요한 케이스나 있나 싶네요! 이런 부분들에 대해서는 적재되다보면 테스트가 느려지는 원인이 되는 부분이기도 하거든요. \n\n> saveSchedule 헬퍼 함수와 같이 테스트 코드 내에서 반복적으로 사용되는 로직을 추상화하고 재사용성을 높이는 더 좋은 방법이 있을까요?\n\n가장 먼저 생각해볼수 있는 부분은 작성해주신것처럼 스케줄을 저장하는것처럼 검증에 반복적으로 환경을 구성하는 로직, 그리고 검증하는 로직 두가지 일 것 같아요. 이렇게 검증하는 로직의 경우 assert~하는 형태로 이름을 지어서 사용하는 경우들이 많은데 (아니면 기존 API처럼 toBe~) 이런 케이스에 해당하는 함수들이 존재하는지 찾아보면 좋을것 같아요! 대신 이렇게 분리가 되면 결국 로직적인게 많이 모일 수 있기 때문에 너무 복잡도를 높이지 않는 방향으로 유지하는게 필요합니다!\n\n> generateRecurringEvents 함수에서 repeatEndDate가 없는 경우를 처리하는 현재 로직(과거 날짜일 경우 단일 이벤트만 생성) 외에 \"무기한 반복\"을 더 명확하고 유연하게 처리할 수 있는 설계 패턴이 있을까요?\n\n사실 이 구현에 대해서는 FE에서 다루게 될 경우 처리해야 하는 시나리오가 너무 많아 현실이라면 BE에서 처리를 할 것 같아요! BE라면 모든 데이터를 정적으로 생성하는게 아니라, 타입에 대해서만 정의하고 쿼링을 하는 FE의 기준에 맞춰서 해당 일정을 만들어서 (있는것처럼) 내려줄 것 같아요 ㅎㅎ\n그리고, 별개의 처리가 필요하다면 그때 별개의 일정을 생성하는 형태가 가장 무난하지 않을까 싶어요.\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/33"
    }
  },
  {
    "passed": true,
    "name": "김지혜",
    "feedback": "안녕하세요 지혜님! 8주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 피라미드 테스트 전략: 이번 과제에서 단위 테스트 → 통합 테스트 → E2E 테스트 순서로 진행했는데, 실제 프로젝트에서는 새로운 기능을 개발할 때와 기존 코드를 리팩토링할 때의 테스트 전략이 다를까요? 어떤 순서로 테스트를 작성하는 것이 효율적일까요?\n\n어떤 코드를 리팩토링 하냐에 따라 다르다고 생각해요!\n더 정확히는, 리팩토링의 범위라고 해야하나...\n\n가령 특정 페이지 하나를 리팩토링 할 때는 통합 테스트가 적절할 것이고,\n특정 페이지 내부에 있는 자잘한 함수에 대해 리팩토링 할 때는 단위테스트가 적절하겠죠!?\n\n그래서 순서가 중요하다기보단 내가 리팩토링할 범주에 대해 결정이 된다면 이에 대한 테스트 전략을 세우는거죠 ㅎㅎ\n상황에 따라 굉장히 달라진답니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/40"
    }
  },
  {
    "passed": false,
    "name": "김효진",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/15"
    }
  },
  {
    "passed": false,
    "name": "김휘린",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/31"
    }
  },
  {
    "passed": false,
    "name": "박상수",
    "feedback": "상수님 이번에는 시간이 별로 없었던 것 같습니다 .\n아쉽지만 다음에는 과제를 완수할 수 있길 기대할게요!!\n수고하셨습니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/46"
    }
  },
  {
    "passed": true,
    "name": "박소연",
    "feedback": "안녕하세요 소연님! 8주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> API목킹 뿐만아니라 테스트검증 자체도 잘못된 부분이 많아 대부분 갈아엎게 되어.. 이게 TDD가 맞나...? 싶은 과정이였어요\n\n처음부터 테스트를 잘 작성하기는 사실 무척 어려워요! 이런 과정이 익숙해지다보면 자연스럽게 완성도 높은 테스트를 만들 수 있겠죠!? 지금은 어쩔 수 없다고 생각합니다 ㅋㅋ\n\n> e2e테스트가 준일코치님이 추천해준 Playwrite CRX 사용해서 활용하니 생각!!! 보다 빠르게 작성하게 되어서, 실무에서 필요한 플로우 몇개는 적용해두면 좋을것 같다고 생각했습니다. QA부분을 어느정도 해소할 수 있지않을까라는 생각이 듭니다.\n\n오오 좋은 인사이트군요 ㅎㅎ 좋습니다. 꼭 e2e를 적용해보시면 좋겠어요!! 화이팅입니다 소연님!!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/32"
    }
  },
  {
    "passed": false,
    "name": "박의근",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "박준형",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/24"
    }
  },
  {
    "passed": true,
    "name": "박창준",
    "feedback": "수고하셨습니다 창준님!\n\nQ1. 실제로도 현업 프로젝트에서 red -> green -> refactor위주로 TDD를 진행하는것이 있다면 어떤것들이 있을까요?\n\nA. 인풋과 아웃풋이 데이터인 모듈은 TDD로 충분히 적용할 수 있을 것 같아요~ \n\n예를들어 UI에 직접적으로 사용되진 않지만 UI에 필요한 데이터 관련 코드나 구조적인 코드들일것 같아요.\n\n비니지스 로직을 담는 모듈일 수도 있고요~\n\nred-green-refactor 자체에 너무 매몰될 필요는 없을 것 같습니다.\n저도 그때그때마다 달라요 테스트부터 작성할대 있고 아닐때도 많아요!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/26"
    }
  },
  {
    "passed": true,
    "name": "신홍준",
    "feedback": "홍준님 수고하셨습니다!\n\nQ. 이번 테스트 코드를 비롯하여 항해에서 리액트도 직접 만들어 보고 클린 코드나 fsd도 배웠습니다. 하지만 이전 회사에서 사용해 보진 않았기에 이직 시 이를 어떻게 어필할 수 있을지 궁금합니다!\n\nA. 어필할수있는 가장 좋은 방법은 프로젝트나 아무튼 업무에 도입을 해야할 것 같아요.\n\n그럴수 있는 상황이 아닌 지금에는 두가지 정도 생각해볼 수 있는데요. 과제에 적용하는 만큼은 효과가 없을 것 같아요\n\n첫번째는 학습하면서 얻은 통찰로 블로그 글을 작성해서 어필할 수 있을 것 같고요.\n\n두번째는 사이드 프로젝트에서 적용해보는 것일 것 같습니다. 사이드 프로젝트 설명에 말씀하신 기술적인 성과를 적어서 말이죵\n\n수고하셨습니다 홍준님! 그리고 화이팅!!! \n분명 좋은 회사로 입사하실 수 있으실거에요!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/1"
    }
  },
  {
    "passed": false,
    "name": "신희원",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/16"
    }
  },
  {
    "passed": false,
    "name": "양성진",
    "feedback": "고생하셨습니다 ㅠㅠ\n\n근데 ㅠㅠ 제가 전에 여러번 말씀드린것처럼 e2e 테스트나 시각적 회귀 테스트 작성에 경험을 해보셨으면 하는 맥락이기 때문에 해당 테스트를 3개 이상 작성해달라고 말씀을 드렸던거라서요.. 새로 추가된 통합 테스트도 좋은 맥락에서 추가된 테스트이지만 심화 통과 기준에 해당이 되지는 않는 것 같습니다.\n\n그외에 작성해주신 기능은 모두 잘 동작하는 것 확인했습니다. 다만, TDD관점에서 구현의 방향을 잡아주는 테스트들이 좀 부족한것 같아 조금 모호한 테스트들이 남아있는 것 같긴 한데요! 추후에 좀 더 구체화를 해봐도 좋을것 같습니다.\n\n> vitest-preview로 확인해보고 알람이 두번씩 나와서 -1초를 하니까 2번 나오던게 한번 나오더라고요. 2번이 나오면 Found multiple elements with the text 이라고 나오더라고요. 그래서 저런식으로 알림작동을 하게 해서 한번만 나오게 하니까 테스트가 통과가 됐는데.\n솔직히 만들면서 너무 억측스럽게 만들었다.? 이런 느낌이였습니다. 혹시 이런 방향으로 작성을 하는게 맞을까요?\n\n음..! 이렇게 될 경우 좋은 작성법은 아니긴 한데요. 비동기 로직에 대해서 테스트를 할 때 이런 경우가 종종 있긴 한 것 같아요. 결국 핵심은 명확하게 트리거 되는 조건, 시점을 잡고 검증을 진행하는 부분인것 같아요. 만약 해당 부분에 대해 우리가 관리하는 라이브러리가 아니기 때문에 구현 방식이 변경된다면 저 테스트가 깨지게되는데 원인을 찾는데 있어서 너무 어려워지고 저희 책임이 아니게 되는거죠. 왜 두번이 나타나는지 명확한 이유를 찾고 그 관점으로 접근하는게 필요할 것 같아요 ㅎㅎ\n\n고생하셨습니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/31"
    }
  },
  {
    "passed": false,
    "name": "양창훈",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/36"
    }
  },
  {
    "passed": false,
    "name": "여진석",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "여찬규",
    "feedback": "찬규님 고생하셨어요!\n기능도 다 잘 동작하고 설정에 따른 유틸 함수들도 잘 만들어주셨네요!\n당연히 e2e 테스트에 대한 부분도 잘 해주셨구요.\n다만, 저 코드가 어떻게 들어가게 되었는지 모르겠지만 테스트 코드내에서 catch등으로 에러를 처리하는건 엄청 특이한 케이스가 아니면 불필요하거든요! 저렇게 예외처리를 두는 것보다 보통의 경우 에러를 해결하는게 필요하니 그 케이스에 해당하는지 고민해봐도 좋을것 같습니다.\n(아 이부분을 질문을 주셨군요. 추가로 해당 상황에 맞춰 작성해보면 해당 케이스별로 환경을 구성하는게 필요합니다. 명확한 노출 조건이 있다면 상황에 따라 함수를 다르게 처리하는게 나은것 같아요. 어쨋든 catch 처리 방식은 좋은 방식은 아닙니다!)\n\n그리고 e2e도 wairfor를 작성하는것보다 명시적인 처리가 있는게 좋으니까 그 방식도 고민해보세요!\n그리고 반복일정에 대한 테스트도 테스트 케이스에 맞춰 코드들이 생성되는데 TDD를 하다보면 구현 집약적인 테스트들이 많이 생길수밖에 없거든요. 이 부분에 대해서도 좀 더 보강하는 형태로 좀 느슨하게 개발이 된것 같은 느낌이긴 하네요 ㅎㅎ\n\n질문 주신 부분 답변 드려볼게요!\n\n> 현재 구현한 테스트 구성에서 테스트 트로피 전략에 맞게 했는지 아직 헷갈립니다\n특히 단위 테스트가 생각보다 많은 편이라 생각이 드는데 테스트 트로피 전략에 맞게 구현을 잘 한건지? 그리고 이 중에서 통합 테스트로 대체 가능한 부분이 있는지가 궁금합니다!\n\n딱 명확하게 나눠지기는 어려울거에요. 이미 강제로 작성되어있는 테스트들도 많이 있고 앱의 특성상 기능 자체가 많이 없을수도 있구요. 지금의 단계에서는 저라면 단위테스트를 꽤 많이 제거하고 통합테스트를 더 작성할 수 있는 부분들이 있을 것 같아요. 날짜 로직들이 엄청 복잡한 케이스들이 아니면 통합테스트에서 충분히 커버가 가능할 것들도 있는 것 같구요. \n\n고생하셨고 앞으로 즐거운 테스트 생활하시길 바랍니다! 계속 시도해보세요~",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/14"
    }
  },
  {
    "passed": true,
    "name": "오하늘",
    "feedback": "안녕하세요 하늘님! 8주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 테오가 알려 준 Given → When → Then 패턴을 회사 실무에서 적용해 보려고 했는데, 매! 일! 매! 일! 바뀌는 요건들과 당최 알 수 없는 요구사항들을 정리하기 쉽지 않아서 마음속으로 묻어두어야 하나 했지만.. 이번 과제로 인해 처음으로 패턴을 도입하게 되어 기분이 좋았다. 생각보다 많이 노가다 같지만, 기획서가 무엇을 요구하고 어떻게 해결해 나가야 하는지에 대한 힌트 같은 패턴이라고 생각되어 정말 많이 좋았다. 팀을 사랑하는 마음도.. 다들 고생했어양..\n\nㅋㅋㅋ 요구사항 정리를 AI 에게 맡기면 어땠을까!? 라는 생각이 들어요. 다만 테스트의 경우 \"변경 가능성\"에 대한 대응이기 때문에, 프로젝트의 유지보수가 자주 발생할 때 특히 유리하답니다!\n\n> 사실 TDD의 강점을 잘 모르겠습니다. 제가 TDD를 너무 많이 기대했던 걸까요. ㅎㅎ 코치님이 생각하시는 TDD의 강점? 그리고 취향은 어떤지 궁금합니다.\n\n이게 프론트엔드에서의 TDD의 경우 예측이 어려워서 더 힘든 것 같아요 ㅎㅎ UI의 변화를 예측하기가 어렵다보니..\n그래서 TDD가 효과적일 때는 확실한 비즈니스 로직이 있을 때 이에 대한 Input/Output에 작성하는 경우에 유리하답니다!\n저도 TDD를 선호하진 않아요..! 특히 인공지능이 나온 이후에는 TDD로 작업을 진행하는게... 발목을 잡을 때가 많다고 해야하나.. 그렇네요 ㅎㅎ\n\n다만 AI를 잘 사용하려면 미리 스펙을 정의해야 하는데 이것도 TDD의 일종이라고 생각해요. 목표를 먼저 정의하고 목표에 도달하기 위한 과정을 만들어가는거죠.\n가령 회의를 TDD 방식으로 진행한다거나!?\n\n이 회의가 끝났을 때의 상태를 미리 정의하고 그 상태에 도달하기 위한 회의를 하는거죠 ㅎㅎ\nTDD는 코드 뿐만 아니라 우리가 살아갈때 다양한 방식으로 응용할 수 있답니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/44"
    }
  },
  {
    "passed": true,
    "name": "유윤우",
    "feedback": "안녕하세요 윤우님!\n8주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 대표적인 e2e 테스팅 툴로 cypress, playwright가 있는 것 같습니다! 실무에서는 주로 어떤 툴을 사용하며 사용하는 이유는 무엇인지 궁금합니다!\n\n사실 저는 실무에서 써본적이 딱히 없긴 한데... 아마 쓴다고 치면 playwright을 사용할 것 같아요 ㅎㅎ 관리하기도 쉽고 작성하기도 쉽다보니..\n특히 playwright crx 확장프로그램을 사용하면 테스트를 뚝딱뚝딱 만들 수 있답니다 ㅋㅋ\n\n> e2e 테스트를 작성할 때 유저시나리오 기반으로 작성을 해보려 노력했습니다. 근데 작성하다보니 통합테스트로 충분히 커버가 되는 부분들이지 않나? 라는 생각이들었습니다. 실제 프로덕트에서 e2e 테스팅은 어떤 경우에 사용하시나요?\n\n순수하게 비즈니스 로직에 대한 부분은 통합 테스트로 충분히 커버할 수 있다고 생각해요 ㅎㅎ 다만 디바이스마다 브라우저마다 관리해야 하는 로직이 다르다거나 실제로 화면에서 보여지는 것들에 대한 검증을 해야할 때는 e2e 가 필요하다고 생각해요.\n\n그리고 통합테스트의 경우 e2e 보다 작성하는게 더 어려울 수 있어요. 그래서 빠르게 작성해서 검증 해야 할 때는 e2e가 효과적이라고 생각합니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/12"
    }
  },
  {
    "passed": true,
    "name": "윤영서",
    "feedback": "한편의 아름다운 글이네요. \n비매드에 흠뻑 빠지셨던 것 같아서 좋습니다.\n\n> bmad의 yolo옵션 사용해보셨나요? 이번 pr에서 제가 초반에도 인간의 개입을 언급했는데요,\n\n저는 따로 쓰지는 않아봤습니다! 근데 종종 어느정도 작업이 안정적이게 실행된다라는 것을 인지한다면 인간의 피드백 없이 자유롭게 하라고 뒀던 적들은 있었던 것 같아요. \n\n> 하지만 아무리 비매드 에이전트가 절차적으로 잘 구성되어있다고 해도 인간의 개입없이는 명확하게 원하는 요구사항을 수정할 수 없을거 같아서요. \n\n이 부분은 저도 동일한 생각입니다. 그래서 작업의 단위를 작게 갖고 유저의 피드백이 명확하게 있는 상태에서 사용하는게 필요하다고 생각했어요. 결국 '전부 다 한번에 못해주니까 의미없어' 보다는 '이정도만 개입해도 이만큼이나 해주잖아' 관점 때문에 AI의 중요성이 올라가는거 아닐까 싶어요.\n\n전반적으로 테스트와 기능 모두 잘 작성되어 있고 필요한 테스트도 잘 작성되어 있는것 같습니다! 문서들도 잘 정리했고, 체크리스트로 만들어서 사용되기 좋게 작성된 것 같아요. e2e테스트도 잘 작성되었구요.\n\n작업의 단위단위를 작게 가져가는게 아직은 필요한 핵심인것 같아요! 앞으로도 회사에서나 과제하시는데 있어서 잘 활용하고 좋은 의견 나눠보면 좋을것 같습니다~ 고생하셨어요~",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/7"
    }
  },
  {
    "passed": false,
    "name": "이가은",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/2"
    }
  },
  {
    "passed": false,
    "name": "이민재",
    "feedback": "안녕하세요 민재님! 이번주에는 시간이 부족했었나보군요 ㅠㅠ\n9주차 과제는 잘 진행할 수 있기를 바랍니다!! 고생하셨어요~!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/29"
    }
  },
  {
    "passed": false,
    "name": "이유진",
    "feedback": "안녕하세요 유진님..! 이번주에 많이 바쁘셨나보네요 ㅠㅠ\n9주차 과제는 테스트와는 전혀 상관 없으니 한 번 시도해보시면 좋겠어요!! 화이팅입니다!!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/43"
    }
  },
  {
    "passed": false,
    "name": "이은지",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/42"
    }
  },
  {
    "passed": false,
    "name": "이의찬",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/31"
    }
  },
  {
    "passed": false,
    "name": "이정우",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "이지현",
    "feedback": "안녕하세요 지현님! 다양한 고밋이 엿보이는 회고였어요 ㅎㅎ\n\n> 이전의 테스트 단계에서 오버엔지니어링을 한걸까? 테스트 코드의 순서를 잘못 지정한걸까? 생각이 들었는데, 아마 전자인거 같습니다. ㅎ\n\n저의 경우 TDD 보다 중요한건 결국 \"테스트 그 자체\" 라고 생각해요! 지금은 학습을 하는 과정이기 때문에 TDD를 수행하는 단계가 중요할 수 있지만, 실무에서는 TDD 보단 일단 \"테스트를 작성하는 것\"에 더 포커스를 두시면 좋을 것 같아요! \n\n> 과제 포기하지 않은 나, 칭찬 해\n\n저도 칭찬 한 스푼 얹어드립니다 ㅋㅋ\n\n> 구린내가 나요\n\n저도 제 코드 보면서 맨날 그런생각 해요.. ㅎㅎ\n\n> 통합 테스트가 medium.intergration 으로 시작하는 파일명을 갖고 있어서 역할에 맞게 파일로 분리 하고싶었습니다. 그런데 분리하고보니 테스트 속도가 현저히 지연되어 타임아웃도 발생하기도했습니다. 통합테스트의 경우는 한 파일에 모아 두고 작성하는 편인 걸까요? 아니면 현재 msw 세팅을 제대로하지 않아서 지연이 발생하고 있는 것 일까요?\n\n꼭 한 파일에 작성할필요는 없다고 생각해요 ㅎㅎ medium.integration.기능1.test 이런식으로 만들기도 한답니다!\n흠.. 타임아웃이 발생하는 이유는 아마 다른 원인이 있는 것 같은데... 이건 디버깅을 같이 해보지 않으면 원인을 알기가 지금은 어려울 것 같네요 ㅠ\n\n> 질문 있습니다! TDD를 하다보니 명확하게 내가 무엇을 만들어야겠다는 것이 명시하고 그것을 놓치지 않고 만들 수있는 장점을 느꼈습니다. 디자인시스템 컴포넌트가 확장성도 있지만, 명세에 기재된 기능들을 만족하여 구현해야하는 상황이라면 TDD 방식이 좋지 않을까 생각했습니다. 그럴까요..? 그런가? 디자인시스템 컴포넌트를 만들때 기능을 누락하거나 누락시키는 것을 종종 봐왔던 터라 TDD를 하면 미연에 방지할 수 있지 않을까, 라는 생각이 들었습니다. 어떻게 생각하시나요!?!\n\n꼭 TDD로 명시하지 않아도 된다고 생각해요 ㅎㅎ 문장으로 요구사항을 작성하기만 해도 큰 도움이 된답니다! 저희 팀은 이걸 \"인수조건과 인수테스트\"라는 이름의 문서로 만들어서 관리하고 있어요.\n말씀하신 것 처럼 명세에 기재된 기능을 만족하면서 진행하는 경우에는 TDD가 확실히 유리하겠네요!\n다만 디자인 시스템의 경우 컴포넌트 자체에 대해서 TDD를 하기보단 컴포넌트가 사용하는 로직 (hook) 에 대해서 작성하는걸 추천드려요 ㅋㅋ\n\n꼭 TDD 방식으로 무언가를 진행하진 않아도 되고, 테스트만 잘 작성해도 충분히 좋다고 생각해요. 인공지능을 이용해서 누락된 명세가 있는지 찾는 과정도 좋답니다!\n",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/8"
    }
  },
  {
    "passed": true,
    "name": "이지훈",
    "feedback": "고생하셨어요~\n작성해주신 기능도 잘 동작하고 추가된 테스트도 목적에 맞게 잘 작성된 것 확인했습니다. 꽤 많은 부분을 작성해주신걸 보니 이제 테스트 작성에는 전혀 어려움이 없으신 것 같네요.\n반복일정에 대한 테스트도 잘 작성해주셨어요 :+1\n해당 테스트에 대한 내용도 ci에 엮어서 함께 테스트 하도록 하는것도 세팅하시면 좋을 것 같네요 ㅎㅎ\n\n> 보편적으로 접근성을 활용해 테스트를 진행하는 것이 권장되는 방식이라고 이해했습니다. 하지만 테스트를 직접 작성하면서 접근성을 활용하는 것이 마냥 쉽지만은 않다고 느껴지는데, 그동안 테스트를 작성하면서 이때는 testId 를 사용해야 했다 라는 상황이 있으셨는지 궁금합니다.\n\n질문 주셨던 이 부분에서는 쉽지 않다는 것은 저도 잘 알고 있습니다 ㅎㅎ 테스트 작성에서 저도 가장 많은 시간을 쓰는게 쿼링하는 방식을 찾는 거니까요. 하지만 제가 생각하기에는 결국 접근성에 대한 지식이 있어야 하는건 FE개발자에게 필수적이고 학습이 필요한 영역인것은 맞는 것 같아요. Q&A때 말씀드린것처럼 testid는 cypress같이 쿼링을 할 때 요소에 대해 유저 관점으로 접근하기 어려운 상황, 예를 들어서 class 나 id기반 구현 기반으로 접근할 때 구현이 변하면 테스트가 꺠지는 상황이 빈번해지니 그런 상황에 있어서는 testid가 더 나은 선택이다. 이런 결정이 되면 사용하기에 좋은 선택지가 되는거거든요. 절대적인 기준은 없고 구현이 변경될 때 가능한 변하지 않는 명확한 기준인가, 유저 관점의 접근과 비슷한가 관점에서 비교해보면서 사용하면 되지 않을까 싶어요!\n\n고생하셨고 다음주도 화이팅입니다~",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/22"
    }
  },
  {
    "passed": true,
    "name": "이진희",
    "feedback": "> 1. Red 단계에서 테스트 코드 수정이 필요한 경우 처리 방법: Red 단계에서 테스트 코드를 작성할 때 한 번에 완벽한 테스트를 만들기가 쉽지 않더라구요. Green 단계에서 구현을 진행하다 보니 테스트 코드가 잘못되었다는 걸 깨닫게 되는 경우가 있었는데, 이때 Green 구현을 중단하고 Red 코드를 다시 수정해서 커밋한 후, 그에 맞춰 구현을 이어서 진행하고 Green 코드를 커밋하는 방식으로 처리해도 되는 건지 궁금합니다. 아니면 이런 상황 자체가 TDD를 잘못 접근한 것일까요?\n\n처음부터 테스트를 잘 작성하긴 어렵다고 생각해요 ㅎㅎ 말씀해주신 것 처럼 테스트의 red를 깔끔하게 유지하고 싶다면 이전 커밋을 수정해서 관리하는 방법이 있을 것 같은데, 꼭 그런 과정이 필요한가!? 라는 생각입니다. 결국 TDD도 개발을 잘 하기 위한 수단일 뿐이고 이게 목적이 되어서는 안 된다고 생각해요!\n\n\n> 2. TDD 진행 순서: Top-down vs Bottom-up: 이번 과제에서는 큰 덩어리의 통합 테스트를 먼저 작성하고, 리팩토링 과정에서 더 작은 단위의 함수로 쪼개면서 각각에 대해 다시 TDD를 적용하는 방식으로 진행하는 게 좋다고 생각했습니다. 실제 실무에서는 어떤 순서로 진행하는 것이 더 효과적인지, 그리고 코드 구조나 함수 설계를 미리 어느 정도까지 계획하고, 어떤 순서로 TDD를 진행하는 게 맞는 건지 궁금합니다.\n\n무엇이 더 효과적일까 생각을 해보자면... TopDown의 경우 큰 덩어리에 대한 테스트를 작성할 때는 변경 가능성이 높다고 생각해요. 대신 전체적인 흐름에 대해 테스트를 작성하면서 이해하기가 쉬운 효과가 있다고 생각합니다. 테스트 자체보단 \"어플리케이션에 대한 이해도\"가 높아지는거죠 ㅎㅎ\nBottomUp의 경우 작은 함수 하나에 대해 작성하다보니 테스트의 정확도가 높고 변경 가능성이 낮다고 생각해요. 더 효율적인거죠.\n\n무엇이 더 좋다기보단 상황에 맞는 선택을 해야한다고 생각해요. 내가 어떤 프로젝트에 갑자기 투입되어야 하는 상황이라면 통합테스트부터 작성하는게 좋을 수 있고, 빠르게 테스트를 토대로 리팩토링을 하고 싶다면 단위테스트부터 작성하면 되지 않을까요!?\n\n정답이 있다기보단 목적에 따라 다르다고 생각합니다!\n",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/38"
    }
  },
  {
    "passed": true,
    "name": "이태영",
    "feedback": "안녕하세요 태영님! 체계적인 회고가 인상적이네요 ㅎㅎ 고생하셨습니다!!\n\n> 가장 기억에 남았던 상황은 반복 일정 로직을 구현할 때였습니다. 31일이 없는 달이나 윤년 같은 예외 상황들을 처리하면서 단순한 날짜 계산이 얼마나 복잡할 수 있는지 깨달았습니다. 처음에는 \"그냥 날짜에 +1 하면 되겠지\"라고 생각했는데 실제로 구현해보니 엄청나게 많은 엣지 케이스가 있었습니다.\n\n맞아요. 테스트를 작성하다보면 자연스럽게 다양한 엣지케이스에 대해 생각하게 된답니다 ㅎㅎ 반대로, 테스트를 작성하는 것보다 중요한건 결국 스펙을 구체화하는 행위라고 생각해요! 테스트는 이를 코드로 승화시킨 과정인거죠.\n\n> 상태 관리 초기값 설계: 반복 일정 체크박스가 기본적으로 체크되어 있는 상태인데 useState의 초기값이 'none'으로 되어 있어서 생성 수정 할 때 문제가 발생하여 저는 초기값에 맞게 화면상에서도 체크를 해제하고 구현을 진행 했습니다. 이런 상태 불일치 문제를 해결하는 방법은 어떻게 하면 될까요?\n\n체크박스를 컴포넌트로 분리한 다음에 defaultValue로 받아오는거죠 ㅎㅎ\n\n`useState(props.chekced ?? \"none\")` 이런 느낌..?\n\n근데 이미 그렇게 해주신 것 같네요 ㅋㅋ 훅으로 분리하면 조금 더 깔끔하게 해결할 수 있답니다!\n\n> 통합 테스트 시나리오를 작성하고 테스트 실행을 하는데 5초가 넘게 되면 테스트가 실패하는 문제에 대한 해결법이 궁금합니다. 저는 이번 프로젝트에서는 setupTests 에서 일단 시간을 늘려주고 했는데 올바른 방법은 아닌 것 같다는 생각이 듭니다.\n\n말씀해주신 것 처럼 timeout을 늘리는 방법도 있고... 이보다 중요한건 실패 원인을 찾아내는거라고 생각해요 ㅎㅎ 5초 이상 걸리는건 문제가 분명 있어보이네요..! 통합 테스트의 경우 실제 브라우저 환경이 아니기 때문에 더 빠르게 실행되어야 하는게 정상일거라서, 문제의 원인을 분석해보시는걸 추천드려요!\n\n> 테스트코드 비율이 어떤 부분? 에서 기준이 되는 걸까요? 이상적인 비율: 단위 70% : 통합 20% : E2E 10% 이라는데 이 비율의 기준이 쓸대없을 수 있지만 궁금했습니다.\n\n흠... 저는 아예 비율 자체를 신경쓰지 않는 편이라서요 ㅎㅎ.. 이런 고민을 해본적이 없네요.. ㅠㅠ\n다만 비율을 코드라인으로 따지기보단 요구사항이나 테스트 커버리지를 기준으로 측정해보는걸 추천드려요!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/19"
    }
  },
  {
    "passed": false,
    "name": "임규원",
    "feedback": "규원님! 과제는 미완이지만 그래도 본인이 느꼇던 것들을 회고문서에 남겨줘서 너무 감사합니다.\n\n팀원분들과 논의하시면서 배우신것도 많은 것 같아요.\n저는 개발자가 제일 많이 성장할때는 같이 기술적인 논의를 할때라고 생각해요. 규원님을 보니 제 생각이 틀리진 않은 것 같습니다 :)\n\n수고많으셨고요. 어떻게든 실무에서 테스트를 도입해볼 수 있는 기회를 가지시면 좋을 것 같습니다!\n",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/25"
    }
  },
  {
    "passed": true,
    "name": "임두현",
    "feedback": "두현님 수고하셨습니다.\n\n\nQ. 유닛/통합의 경계가 적절한지, 통합 테스트에서 확인하는 중간 체크포인트의 수와 수준이 과하거나 부족하지 않은지 피드백을 부탁드립니다.\n\nA. 유닛과 통합테스트는 경계는 모호해요.\n의존성이 있느냐 없느냐로 보는 것이 현실적인데 실제로는 그렇게 구분하지 않는 경우가 많습니다 :)\n그래서 통합테스트가 무엇이냐라는 것도 사실 전략에서 팀이 그때마다 세워야할 것 같아요.\n정답은 없고 그때그때마다 정하기 나름인 구분이라고 생각합니다.\n\n9팀에서 세운 전략의 통합과 유닛테스트는 너무 훌륭하다고 생각합니다 :)\n모호하지 않는 것 같아요!\n\n근데 두현님이 따로 작성한 마지막부분에서 설명한 통합테스트 부분은 팀에서 정한 E2E테스트의 부분인 것 같아요!\n\n질문주신 코드상에서 의도한 중간 체크포인트를 제가 바로 캐치하지 못하고 있는데욥. 전체적으로 테스트를 보면 정말 잘해주신것 같아요 :)\n9팀은 전략도 잘짜주셨고 너무 좋네요!\n\n체크포인트관련해서는 다음에 다시 한번 코드를 보면서 이야기할 수 있으면 좋겠네요. 제가 어느부분이 체크포인트인지를 인지못하고있어요 ㅜㅜ.\n\n수고하셨습니다.",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/25"
    }
  },
  {
    "passed": false,
    "name": "장루빈",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "장희진",
    "feedback": "안녕하세요 희진님! 8주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 이번 과제를 하면서 TDD의 장점(예: 리팩터링에 대한 자신감, 테스트 자동화로 인한 안정감 등)은 이해할 수 있었지만, 동시에 단점도 크게 느꼈습니다. 학습해야 할 것도 많고, 무엇보다 코치님들이 자주 말씀하시는 “실무에 적용해봐라”라는 부분은 솔직히 아직 엄두가 나지 않았습니다. 그래서 궁금한 점은, 코치님이 생각하시기에 TDD는 실무에서 어떤 상황에 적용하는 것이 좋은지입니다. 예를 들어, 시간이 충분히 주어졌을 때라든지, 복잡한 핵심 로직을 다룰 때라든지, 혹은 장기적으로 유지보수가 필요한 서비스일 때라든지 등 어떤 맥락에서 TDD가 가장 효과적이라고 보시는지 알고 싶습니다. 또한 정말 만에 하나, 제가 지금처럼 TDD의 개념만 알고 실제 적용 방식을 잘 모르는 상태라고 했을 때, 이게 이직이나 앞으로의 커리어에 있어서 큰 불리한 점으로 작용하는지도 궁금합니다. 단순히 “알아두면 좋은 스킬” 수준인지, 아니면 “없으면 치명적인 약점이 되는 역량”인지 판단이 잘 안 서서 코치님의 생각을 듣고 싶습니다.\n\n저는 테스트에 익숙해져야 TDD를 할 수 있다고 생각하고 있어요. 그래서 TDD를 먼저 적용하기보단, 테스트를 먼저 적용하는걸 추천드려요!\n다만 TDD는 꼭 코드 뿐만 아니라 다양한 영역에 적용할 수 있답니다!\n가령, 회의를 TDD 방식으로 진행할 수 있는데요, \"이 회의가 끝났을 때의 우리 상태\"를 정의하는거죠. 그리고 그 상태에 도달하기 위한 재료나 질문들을 모아서 진행할 수 있겠죠?\n\n목표를 먼저 정의하고 목표에 도달하기 위한 행동을 하는 것. 이게 저는 TDD 라고 생각해요\n\n그리고 TDD를 모르다고 문제되는건 없답니다 ㅎㅎ 저희 팀에서는 TDD를 하고 있지 않기도 해요. 대신 테스트는 중요하게 생각하고 있어요.\n\n---\n\n현재 e2e 테스트가 실패하고 있어서... 심화과제는 불합격으로 남겨놓겠습니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/18"
    }
  },
  {
    "passed": false,
    "name": "정건휘",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/39"
    }
  },
  {
    "passed": true,
    "name": "정도은",
    "feedback": "> 저희가 CI 에서 e2e 확인해보려고 집단지성을 사용했지만 실패했습니다.. 아무리 바꿔도 안 바뀌더라구요.. 왜 일까요 ㅜㅜ 여러방면으로 시도 해도 안되길래 PR이라 그런가? main에 있는 설정 파일을 따라가는건가 하고 결국엔 포기했는데 성공하신 분이 있더라구요,,!!\n\n이게 clone을 해서 가져간 PR의 경우, 원본 CI를 덮어쓰는게 불가능해서 그런 것 같아요 ㅎㅎ\n\nhead branch의 ci를 실행하는게 아니라 base branch의 ci를 실행하는거죠\n그래서 별도의 workflow 파일을 만들어서 진행하면 아마 정상적으로 실행되었으리라 생각합니다!\n\ntrigger가 pull_request 일 때랑 pull_request_target 일 때의 차이를 한 번 찾아보시면 좋겠어요!\n\n- https://docs.github.com/en/actions/reference/workflows-and-actions/events-that-trigger-workflows#pull_request\n- https://docs.github.com/en/actions/reference/workflows-and-actions/events-that-trigger-workflows#pull_request_target\n\n\n> 되던 테스트가 어쩔때는 타임아웃 오류가 떠서 화끈하게 10000으로 늘려서 통과시켰습니다. 이렇게 테스트를 통과시켜도 될까요? 아니면 테스트가 오래 걸리면 문제가 있는것이니 코드를 개선하는게 맞을까요. 타임아웃 이유도 궁금합니다..\n\n타임아웃이 발생하는 이유 자체를 일단 찾아보시는게 좋을 것 같아요! 보통 병렬실행할 때 발생하는 문제라서, 트러블슈팅 해보시면 학습에 도움이 많이 되지 않을까요!?\n\n> 치님만의 테스트 팁이 있나요.. 멘토링때 알려주신 palywright CRX 덕분에 e2e 편하게 작성했습니다. 통합 테스트할때는 vitest-preview 덕분에 디버깅하기 수월했구요..혹시 더 있나요? 테스트 꿀팁.. 👀\n\nㅋㅋㅋ 인공지능을 잘 사용해보세요! 이미 작성된 테스트 코드를 토대로 \"이런 방식으로 테스트를 이어서 작성해줘!\" 라고 하면 무척 잘 만들어준답니다.\nplaywright의 경우 playwright mcp 연동해서 사용하면 요구사항을 그대로 테스트 스펙으로 만들어주는 등의 작업을 해줄 수 있답니다! 인공지능 쵝오!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/11"
    }
  },
  {
    "passed": false,
    "name": "정명훈",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "정민기",
    "feedback": "안녕하세요 민기님! 8주차 과제 잘 진행해주셨네요 ㅎㅎ \n\n> 이번에 테스트 코드를 작성하면서 '어떤걸' 테스트 해야할까? 라는 부분이 좀 헷갈립니다. 이번 과제에 통합 테스트를 했기에 사용자 흐름 및 예상치 못한 내용에 대해 테스트 코드를 작성했습니다. 하지만 여기에 불필요한 테스트 코드가 분명 있다고 생각합니다. 이러한 불필요한 테스트 코드를 분간하는 방법에 대해 어떤식으로 알아야할지 좀 고민됩니다. 발제 내용에도 이러한 내용이 있긴한데 아직 조금 어려운거같습니다. 혹시 이러한 부분에 대해 괜찮은 책이나 블로그등 추천해주실만한 게 있을까요..? 아니면 불필요한 테스트 코드를 분별하는 방법에 대한 따로 노하우가 있으실까요.. ㅜㅜ\n\n흠.. 제가 책이나 블로그를 토대로 테스트를 익히질 않다보니.. 이에 대해 설명드리기가 조금 어렵네요 ㅠㅠ\n이건 프로젝트 성격에 따라 무척 달라진다고 생각해요.\n가령, 저는 이전 회사에서 \"포털 서비스\"를 만들었는데 그러다보니 \"비즈니스 로직\"보다는 \"보여지는 것\"이 더 중요했습니다. 단위테스트나 통합테스트 대신 비주얼 테스트 같은걸 하면 더 효과적으로 사이드 이펙트를 검증할 수 있었어요.\n\n그런데 지금의 경우 웹빌더를 만들고 있고 여기에서는 비즈니스 로직에 대해 촘촘하게 검사를 해야 했어요. 통합테스트나 e2e 테스트로 커버하기가 굉장히 어렵고 오래걸렸죠.\n\n결론은 우리 서비스에서 중요한 코드가 무엇이고, 이를 검증하기 위해 어떤 도구가 필요할지를 판단해야 하다고 생각해요.\n가령 지금 과제의 경우 \"반복 일정\"이 핵심이 되는 로직이고 이에 대한 검증은 통합 테스트로 하는게 제일 효과적일 수 있죠.\n그치만 1~3주차 과제인 쇼핑몰의 경우 e2e 테스트가 더 효과적일 수 있고, 4~6주차에서는 쇼핑몰의 할인로직이 핵심인데 이 때는 단위테스트가 효과적입니다.\n\n어떤 상황이냐에 따라 다르다는 점만 인지해도 좋을 것 같아요!\n",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/9"
    }
  },
  {
    "passed": true,
    "name": "정유열",
    "feedback": "유열님 벌써 8주차네요 정말 고생하셨습니다 :)\n체력 안배하시고 다음주에는 더 달리시면 될 것 같아요!\n수고하셨습니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/27"
    }
  },
  {
    "passed": false,
    "name": "조영민",
    "feedback": "안녕하세요 영민님! 8주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n다만 심화과제는 시간이 많이 부족했나보네요 ㅠㅠ\n9주차 과제는 기본과제만 잘 풀이하면 심화과제도 큰 무리 없이 진행할 수 있으니 한 번 시도해보세요! 화이팅입니다!!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/23"
    }
  },
  {
    "passed": true,
    "name": "주산들",
    "feedback": "수고했습니다. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다라는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. 회고를 보아하니 잘 수행해준 것 같아요.\n\n\"과제를 처음 시작할 때 테스트 코드 자체를 아예 처음 해보는 거라 내가 과제를 잘 수행 할 수 있을지 걱정이 많이 되었다. 그런데 막상 해보니까 생각보다 문법이 간단했고 아 뭐야! 괜히 쫄았네!!\" ㅋㅋ 좋은 반응이네요. 실제로 테스트 코드는 생각보다 진입장벽이 높지 않아요. 한번 해보면 \"아 이런 거구나\" 싶죠.\n\n\"밀린 숙제 끝낸 느낌이고... 일단은 앞으로 개발하면서 '테스트 코드를 도입해 볼까?' 라는 생각이 쉽게 들 것 같아서 좋다. 심리적 진입장벽이 많이 낮아졌다...\" 너무 좋습니다. 무엇보다 심리적 진입장벽이 많이 낮아졌다는 말이 참 좋네요. 이게 이번 과제의 가장 큰 목표였어요. 테스트 코드에 대한 막연한 두려움을 없애는 것!! 이제는 마지막 퍼즐조각인 실무에서도 어떻게든 하나 만들어 보는 것 까지 자연스럽게 시도해볼 수 있을 거예요.\n\n\"나중에는 테스트 코드가 없이 리팩토링을 할 때 불편함을 느낄 수도 있을 것 같았다\" 정확한 인사이트네요. 테스트 코드가 있는 상태에서 리팩토링을 경험해보면, 없을 때의 불안감을 더 크게 느끼게 되죠.\n\n\"최대한 공정한...? 코드를 작성하려고 노력했다. 막 어떻게든 테스트를 통과시키기 위해 기상천외한 방식으로 테스트를 작성하는 것은 최대한 지양하고자 하였고....\" 좋습니다. 공정한이라는 표현이 재밌네요. 테스트 코드는 나를 대신해서 사용자를 대신해서 하는 것인만큼 \n\nQ) 테스트 코드는 다다익선인가요! 테스트 코드가 많을 경우 생길 수 있는 단점이 있나요?\n\n=> 좋은 질문입니다. 당연히 코드는 많을 수록 좋겠죠? 가 아니라 테스트 코드도 결국 코드이기 때문에 유지보수 비용이 발생했습니다. 코드는 자산이 아니라 부채니까요. 우리가 담보 대출을 받아 집을 사고 이자를 내는 건 그 편이 더 큰 가치를 만들어 내기 때문이죠. 그러나 실제 가치를 얻기도 전에 이자에 허덕인다면 좋을 수 없습니다. 주담대도 땡길 수 있을때 많이 땡기는게 좋지만 감당할 수 있느냐가 중요하다고 생각해요.\n\n=> 테스트 코드는 그 특성상 요구사항이 변경되면 그에 맞게 테스트 코드를 수정해야 되요. 테스트 코드가 아주 세세하게 많다면 그 변화에 맞게 코드 수정까지 해야 되죠. 그리고 테스트 실행시간이 길다면 매번 코드 변경시 테스트 코드를 실행하게 되고 이게 늘어진다면 되려 속도가 느려질 수 있습니다. 그리고 테스트 코드는 꽤나 중요한 기준이 되어 주는데 테스트 코드가 틀리게 될 경우 검증을 하는게 어려워질 수 있습니다.\n\n=> 사실 이런걸 재다보면서 테스트 코드를 만들면 결국 하지 말자는 식의 결론이 내려질 가능성이 크기 때문에 일단 만들어보고 판단해도 늦지 않아요. 만들다보면 필요없는 테스트, 필요한 테스트들이 보이게 됩니다. 물론 그 규모가 커지게 되고 관리하던 누군가가 손을 떼는 순간 그 부작용을 경험하게 되겠지만 그건 그때가서 생각해보기로 하고 일단 만들어 보기로 해요! 거기까지 도착해보는 것만으로도 크게 성장할테니까요\n\n이번 경험으로 테스트에 대한 두려움이 사라진 만큼, 실무에서도 꼭 한번씩 시도해보면서 그 가치를 계속 확인해보길 바라요. 다음 과제도 화이팅입니다\n",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/13"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "최용훈",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/4"
    }
  },
  {
    "passed": false,
    "name": "최재환",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "한아름",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/33"
    }
  },
  {
    "passed": false,
    "name": "허정석",
    "feedback": "정석님 너무 아숩군요.\n바쁘셨나보네여. 그럼에도 테스트 전략은 잘 이야기를 나눠주셨던 것 같고 그걸 기반으로 테스트를 좀 더 채워봤으면 어땠을까 싶네요 ㅠㅠ\n기간이 지나도 사실 과제가 사라지는건 아니니까 잘 마무리하시고 여유가 있으실때 꼭 해보신 다음에 이야기 저랑 함께 나눠보시면 좋을것 같습니다.\n\n다음 주차도 화이팅입니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/21"
    }
  },
  {
    "passed": true,
    "name": "현지수",
    "feedback": "지수님 수고하셨습니다!\n\nQ. 이번 과제를 통해 비즈니스 로직(날짜 계산, 반복 일정 생성)에서 TDD의 효과를 체감했는데, 실무에서는 기존 레거시 코드베이스에 테스트를 어떻게 점진적으로 도입하는 것이 현실적일까요?\n\nA. 제가 추천하는 방법은 가급적 모킹을 할 필요가 없는 방법을 먼저 사용하는 것을 추천드려요.\n\n두가지 방안이 있는데,\n디펜던시가 거의없거나 적은 모듈들을 위주로 테스트 커버리지를 늘려가는 방법과 E2E 테스트만 시작해서 사용자의 크리티컬한 패스부터 중요한 시나리오순으로 커버리지를 늘려가는 방법입니다.\n\n모킹을 많이 사용되게되면 초반에 테스트를 적응하기 전에 너무 많은 피로를 느끼게 될 것 같아요 :)\n\n수고하셨습니다!\n",
    "assignment": {
      "name": "STEP16 프론트엔드 테스트 코드 심화과제",
      "url": "https://github.com/hanghae-plus/front_6th_chapter3-2/pull/27"
    }
  }
]